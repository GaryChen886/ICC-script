//**************************************************************************************
//* CALIBRE DRC COMMAND FILE - CL13S_8M.22d (VER 2.2d, 03/27/2007)	
//* FOR TSMC 0.13UM CMOS LOGIC (G/LV/LP) 1P8M PROCESS 
//* (DESIGN RULE DOCUMENT: T-013-LO-DR-001 Rev 2.2)
//**************************************************************************************
//**************************************************************************************
// Revision history has been moved to the file "4_ReleaseNotes.txt".
//******************************************************************************************


//***********************************************************************************
// 	OPTIONAL SEETINGS FOR CALIBRE:
//***********************************************************************************
//
//DRC INCREMENTAL CONNECT YES
//DRC EXCLUDE FALSE NOTCH YES   // Please enable this line to fix violations caused by
				// FALSE NOTCH feature. But the DRC runtime will increase.
//LAYOUT ALLOW DUPLICATE CELL YES

#DEFINE 3.3V 	// when HIGH_VOLTAGE = 3.3V
//#DEFINE 2.5V 	// when HIGH_VOLTAGE = 2.5V
//#DEFINE 1.8V 	// when HIGH_VOLTAGE = 1.8V
#DEFINE FULL_CHIP 		// when chip corner/sealring is considered
//#DEFINE BigSealringCorner         // Turn on to use big seal-ring corner for whole chip design
//#DEFINE SmallSealringCorner     // Turn on to use small seal-ring corner for whole chip design
//#DEFINE LmarkSealringCorner   // Turn on to use L-mark seal-ring corner
//#DEFINE LK                   //  Turn on to check Low-K process

#DEFINE DATATYPE_WARNING  // Turn on to check OD/PO/NW datatype warning.
//#DEFINE GUIDELINE_LDD		// when you want to check LDD guideline
//#DEFINE GUIDELINE_RES 	// Turn on to check PO/OD resistor guidelines.
#DEFINE GUIDELINE_ESD             // Turn on by default, check ESD protection guidelines

#DEFINE SUGGESTED 		// when you want to check suggested rule

//#DEFINE SRAMDMY_USED_ONLY	// replace EXCL and DMSRM with SRAM_DUMMY layers
#DEFINE CHECK_DENSITY_IN_ODBLK // include the ODBLK region to be checked with OD density rules

#DEFINE CHECK_DENSITY_IN_DMxEXCL_ONLY	// check metal density only inside the DMxEXCL regions



//#DEFINE THICK_TOP2_METAL	// when M7 and M8 are thick metal
//#DEFINE THICK_TOP3_METAL	// when M6, M7 and M8 are thick metal


//  OPTION SETUP OF DFM RULES
//=============================

//#DEFINE DFM           // Turn on to check DFM rules
//#DEFINE DFM_ONLY      // Turn on to check DFM rules only
   #DEFINE Required
   #DEFINE Recommended
   #DEFINE Analog       // must select by layer RRuleAnalog(182;3) or cell CellsForRRuleAnalog to enable analog checks.

// Start of Action-required DFM rules 
#DEFINE _POS2_
#DEFINE _POS4_
#DEFINE _POEX2_
// End of Action-required DFM rules

// Start of recommended DFM rules
#DEFINE _OPCR1_
#DEFINE _OPCR3_
#DEFINE _DNWEN1_
#DEFINE _ODW1_
#DEFINE _ODS1_
#DEFINE _ODS7_
#DEFINE _POS1_
#DEFINE _POS5_
#DEFINE _RPOEX1_
#DEFINE _RPOEX3_
#DEFINE _VARS2_
#DEFINE _VARA1_
#DEFINE _COS3_
#DEFINE _COEN1_
#DEFINE _COEN2_
#DEFINE _M1S5_
#DEFINE _M1EN21_
#DEFINE _M1EN22_
	#DEFINE _VIA1EN1_VIA1EN2_

	#DEFINE _VIA2EN1_VIA2EN2_

	#DEFINE _VIA3EN1_VIA3EN2_

	#DEFINE _VIA4EN1_VIA4EN2_

	#DEFINE _VIA5EN1_VIA5EN2_

	#DEFINE _VIA6EN1_VIA6EN2_

	#DEFINE _VIA7EN2_

	#DEFINE _M2W3_
	#DEFINE _M3W3_
	#DEFINE _M4W3_
	#DEFINE _M5W3_
	#DEFINE _M6W3_
	#DEFINE _M7W3_
	#DEFINE _M2S5_
	#DEFINE _M2S6_
	#DEFINE _M2S7_
	#DEFINE _M2EN1_M2EN2_
	#DEFINE _M3S5_
	#DEFINE _M3S6_
	#DEFINE _M3S7_
	#DEFINE _M3EN1_M3EN2_
	#DEFINE _M4S5_
	#DEFINE _M4S6_
	#DEFINE _M4S7_
	#DEFINE _M4EN1_M4EN2_
	#DEFINE _M5S5_
	#DEFINE _M5S6_
	#DEFINE _M5S7_
	#DEFINE _M5EN1_M5EN2_
	#DEFINE _M6S5_
	#DEFINE _M6S6_
	#DEFINE _M6S7_
	#DEFINE _M6EN1_M6EN2_
	#DEFINE _M7S5_
	#DEFINE _M7S6_
	#DEFINE _M7S7_
	#DEFINE _M7EN1_M7EN2_
    	#DEFINE _M1DN3_
    	#DEFINE _M2DN3_
    	#DEFINE _M3DN3_
    	#DEFINE _M4DN3_
    	#DEFINE _M5DN3_
	#DEFINE _M6W2_
	#DEFINE _M7W2_

        #DEFINE _M8W2_
// End of recommended DFM rules    

// Start of analog DFM rules   
#DEFINE _POEX1m_
#DEFINE _POS4m_
#DEFINE _POEX2m_
#DEFINE _BJTR2R_
#DEFINE _BJTR3R_
#DEFINE _BJTR4R_
#DEFINE _BJTR5R_
#DEFINE _BJTR6R_
#DEFINE _BJTR7R_
#DEFINE _ANR17mg_
#DEFINE _ANR19mg_
// End of analog DFM rules

VARIABLE CellsForRRuleRequired "*"
VARIABLE CellsForRRuleRecommended "*"
VARIABLE CellsForRRuleAnalog " "
VARIABLE ExclCellsForRRuleRequired " "
VARIABLE ExclCellsForRRuleRecommended " "
VARIABLE ExclCellsForRRuleAnalog " "






// ENVIRONMENT SETUP
//------------------

PRECISION    1000
RESOLUTION      5    // Layout grid is 0.005um

LAYOUT SYSTEM GDSII
LAYOUT PATH "CHIP_pr.gds"
LAYOUT PRIMARY "CHIP"

DRC RESULTS DATABASE "DRC_RES.db"
DRC SUMMARY REPORT "DRC.rep" // HIER  
DRC CHECK TEXT ALL

FLAG OFFGRID YES  // For layout grid check, default grid space is value of resolution.
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES
DRC MAXIMUM RESULTS ALL
//DRC INCREMENTAL CONNECT YES
//LAYOUT ALLOW DUPLICATE CELL YES
//LAYOUT ERROR ON INPUT NO


VARIABLE  MS_R_1_W_s 5.999
VARIABLE  MS_R_1_W   12
VARIABLE  MS_R_1_L   30
VARIABLE  MS_DN_1    0.09
VARIABLE  BJT_R_1    0.3
VARIABLE  BJT_R_2R_A  2.0
VARIABLE  BJT_R_2R_B  5.0
VARIABLE  BJT_R_2R_C  10.0
VARIABLE  BJT_R_3R    3.0
VARIABLE  BJT_R_4R    0.8
VARIABLE  BJT_R_5R    2.5
VARIABLE  BJT_R_6R    2.0

VARIABLE  DOD_W_1   2.0 
VARIABLE  DOD_S_1   1.2 
VARIABLE  DOD_S_2   1.2 
VARIABLE  DOD_S_3   1.2 
VARIABLE  DOD_S_5   0.6 
VARIABLE  DOD_S_6   1.2 
VARIABLE  DOD_S_7   1.2 
VARIABLE  DOD_S_8   1.2 
VARIABLE  DOD_S_10   1.2 
VARIABLE  DOD_EN_1   0.6 
VARIABLE  DOD_EN_2   2.5 

VARIABLE  DPO_W_1   0.6 
VARIABLE  DPO_S_1   0.3 
VARIABLE  DPO_S_2   1.2 
VARIABLE  DPO_S_3   1.2 
VARIABLE  DPO_S_5   1.2 
VARIABLE  DPO_S_6   1.2 
VARIABLE  DPO_S_8   1.2
VARIABLE  DPO_S_9   0.3
VARIABLE  DPO_EN_1  2.5 
VARIABLE  LD_SIZE1 0.28
VARIABLE  LD_SIZE2 0.14
VARIABLE  LD_SIZE3 0.58
VARIABLE  LD_SIZE4 0.29
VARIABLE  LDN_EX_1   0.31 
VARIABLE  LDN_O_1   0.31 
VARIABLE  LDP_EX_1   0.31 
VARIABLE  LDP_O_1   0.31 
VARIABLE  VT_S_1   0.31 
VARIABLE  VT_S_4   0.31
VARIABLE  VT_EX_1   0.31 
VARIABLE  VT_EX_2   0.31 
VARIABLE  VT_EX_3   0.31

VARIABLE  GRID     0.005  
VARIABLE  BIG_AREA 4000000

VARIABLE  NW_W_1   0.62 
VARIABLE  NW_S_1   0.62 
VARIABLE  NW_S_2   1.0 
VARIABLE  NW_S_3   1.2 
VARIABLE  NW_S_4   1.2 
VARIABLE  NW_A_1   1.0 
VARIABLE  NW_A_2   0.384 

VARIABLE  NWROD_W_1   1.8 
VARIABLE  NWROD_S_1   1.2 
VARIABLE  NWROD_S_2   0.3 
VARIABLE  NWROD_EN_1   1.0 
VARIABLE  NWROD_EN_2   0.3 
VARIABLE  NWROD_EX_1   0.22
VARIABLE  NWROD_O_1   0.4 
VARIABLE  NWRSTI_EN_3   0.18 

VARIABLE  DNW_W_1   3.0
VARIABLE  DNW_S_1   5.0
VARIABLE  DNW_S_2   3.5 
VARIABLE  DNW_S_3   1.0 
VARIABLE  DNW_S_4   1.2 
VARIABLE  DNW_S_5   2.93 
VARIABLE  DNW_O_1   2.0 

VARIABLE  NT_N_W_1   0.62 
VARIABLE  NT_N_W_2   0.30 
VARIABLE  NT_N_W_3   1.20	 
VARIABLE  NT_N_S_1   0.62 
VARIABLE  NT_N_S_2   0.38   
VARIABLE  NT_N_S_3   1.20  	
VARIABLE  NT_N_EN_1  0.26
VARIABLE  NT_N_EX_1  0.35

VARIABLE  VTL_N_W_1   0.31 
VARIABLE  VTL_N_W_2   0.13 
VARIABLE  VTL_N_S_1   0.31 
VARIABLE  VTL_N_S_2   0.18 
VARIABLE  VTL_N_S_3   0.27 
VARIABLE  VTL_N_EX_1   0.18
VARIABLE  VTL_N_EX_2   0.27

VARIABLE  VTL_P_W_1   0.31 
VARIABLE  VTL_P_W_2   0.13 
VARIABLE  VTL_P_S_1   0.31 
VARIABLE  VTL_P_S_2   0.18 
VARIABLE  VTL_P_S_3   0.27 
VARIABLE  VTL_P_EX_1   0.18
VARIABLE  VTL_P_EX_2   0.27

VARIABLE  VTH_N_W_1   0.31 
VARIABLE  VTH_N_W_2   0.13 
VARIABLE  VTH_N_S_1   0.31 
VARIABLE  VTH_N_S_2   0.18 
VARIABLE  VTH_N_S_3   0.27 
VARIABLE  VTH_N_EX_1   0.18
VARIABLE  VTH_N_EX_2   0.27

VARIABLE  LVID_W_1    0.31
VARIABLE  LVID_S_1    0.31
VARIABLE  LVID_S_2    0.40
VARIABLE  LVID_S_3    0.27
VARIABLE  LVID_EX_1   0.27
VARIABLE  LVID_R_1_1  0.03
VARIABLE  LVID_R_1_2  0.27

VARIABLE  VTH_P_W_1   0.31 
VARIABLE  VTH_P_W_2   0.13 
VARIABLE  VTH_P_S_1   0.31 
VARIABLE  VTH_P_S_2   0.18 
VARIABLE  VTH_P_S_3   0.27 
VARIABLE  VTH_P_EX_1   0.18
VARIABLE  VTH_P_EX_2   0.27

VARIABLE  OD_W_1   0.15 
VARIABLE  OD_S_1   0.21
VARIABLE  OD_S_3   0.31
VARIABLE  OD_S_4   0.24
VARIABLE  OD_S_5   0.32
VARIABLE  OD_EN_1   0.24
VARIABLE  OD_EN_2   0.31
VARIABLE  OD_A_1   0.122
VARIABLE  OD_A_2   0.15
VARIABLE  OD_DN_1   0.2
VARIABLE  OD_DN_2   0.8
VARIABLE  OD_DN_3   0.25
VARIABLE  OD_DN_4   0.75
VARIABLE  OD_R_1_W   0.30
VARIABLE  OD_R_1_L   0.6

VARIABLE  OD2_W_1   0.62 
VARIABLE  OD2_S_1   0.86 
VARIABLE  OD2_S_2   0.27 
VARIABLE  OD2_S_3   0.34 
VARIABLE  OD2_S_4   0.62 
VARIABLE  OD2_EN_1   0.34 
VARIABLE  OD2_EX_1   0.27 
VARIABLE  OD2_EX_2   0.62 
VARIABLE  OD2_EX_3   0.62 
VARIABLE  OD2_O_1   0.62 

VARIABLE  PO_W_1_18v  0.18
VARIABLE  PO_W_1_25v  0.28
VARIABLE  PO_W_1_33v  0.30
VARIABLE  PO_W_2_18v  0.18
VARIABLE  PO_W_2_25v  0.28
VARIABLE  PO_W_2_33v  0.35
VARIABLE  PO_W_3   0.13 	
VARIABLE  PO_W_4   0.16
VARIABLE  PO_W_4_L   0.39
VARIABLE  PO_S_1   0.18 
VARIABLE  PO_S_2   0.18 
VARIABLE  PO_S_3   0.25 
VARIABLE  PO_S_4   0.07 
VARIABLE  PO_S_5   0.18 
VARIABLE  PO_EX_1  0.18 	
VARIABLE  PO_EX_2   0.23 
VARIABLE  PO_A_1   0.09 
VARIABLE  PO_A_2   0.15 

VARIABLE  NP_W_1   0.31 
VARIABLE  NP_S_1   0.31 
VARIABLE  NP_S_2   0.18 
VARIABLE  NP_S_3   0.03
VARIABLE  NP_S_4   0.40 
VARIABLE  NP_S_7   0.20 
VARIABLE  NP_EN_1   0.20 
VARIABLE  NP_EN_2   0.03 
VARIABLE  NP_EX_1   0.18 
VARIABLE  NP_EX_3   0.20 
VARIABLE  NP_EX_4   0.40 
VARIABLE  NP_O_1   0.18 
VARIABLE  NP_A_1   0.25  	
VARIABLE  NP_A_2   0.25 
VARIABLE  NP_R_1  0.27
VARIABLE  NP_R_1_1  0.03

VARIABLE  PP_W_1   0.31 
VARIABLE  PP_S_1   0.31 
VARIABLE  PP_S_2   0.18 
VARIABLE  PP_S_3   0.03
VARIABLE  PP_S_4   0.40 
VARIABLE  PP_S_7   0.20 
VARIABLE  PP_EN_1   0.2 
VARIABLE  PP_EN_2   0.03 
VARIABLE  PP_EX_1   0.18 
VARIABLE  PP_EX_3   0.20 
VARIABLE  PP_EX_4   0.40 
VARIABLE  PP_O_1   0.18 
VARIABLE  PP_A_1   0.25  	
VARIABLE  PP_A_2   0.25 
VARIABLE  PP_R_1  0.27
VARIABLE  PP_R_1_1 0.03


VARIABLE  RPO_W_1   0.43 
VARIABLE  RPO_S_1   0.43 
VARIABLE  RPO_S_2   0.22 
VARIABLE  RPO_S_3   0.22 
VARIABLE  RPO_S_4   0.38 
VARIABLE  RPO_S_5   0.30
VARIABLE  RPO_EX_1   0.22 
VARIABLE  RPO_EX_2   0.22 
VARIABLE  RPO_EX_3   0.22 
VARIABLE  RPO_A_1   1.0 
VARIABLE  RPO_A_2   1.0

VARIABLE  RES_2G_OD_W 1.0
VARIABLE  RES_2G_OD_L 2.0
VARIABLE  RES_2G_PO_W 1.0
VARIABLE  RES_2G_PO_L 2.0
VARIABLE  RES_9G    0.4
VARIABLE  RES_10G    0.2

VARIABLE  VAR_W_1  0.3
VARIABLE  VAR_L_1  0.5
VARIABLE  VAR_S_1  0.18
VARIABLE  VAR_EN_1 0.3
VARIABLE  VAR_R_4  0.3
VARIABLE  VAR_R_5a 0.22
VARIABLE  VAR_R_5b 0.18

VARIABLE  CO_W_1   0.16 
VARIABLE  CO_W_2   0.16
VARIABLE  CO_S_1   0.18 
VARIABLE  CO_S_2   0.20 
VARIABLE  CO_S_2_1  0.21 
VARIABLE  CO_S_3   0.11 
VARIABLE  CO_S_4   0.13
VARIABLE  CO_S_5   0.14
VARIABLE  CO_EN_1  0.07
VARIABLE  CO_EN_2  0.07
VARIABLE  CO_EN_3  0.09 	
VARIABLE  CO_EN_4  0.09
VARIABLE  CO_EN_5  0.05

VARIABLE  M1_W_1   0.16 
VARIABLE  M1_W_2   0.20 
VARIABLE  M1_W_2_L   0.5 
VARIABLE  M1_S_1   0.18 
VARIABLE  M1_S_2   0.6 
VARIABLE  M1_S_2_B   1.0 
VARIABLE  M1_S_3   0.22 
VARIABLE  M1_S_3_L   1.0 	
VARIABLE  M1_S_4   0.22 
VARIABLE  M1_EN_1  0.0
VARIABLE  M1_EN_2  0.05  	
VARIABLE  M1_A_1   0.122 	
VARIABLE  M1_A_2   0.2
VARIABLE  DM1_DN_2L 0.15
VARIABLE  DM1_DN_2H 0.80
VARIABLE  M1_DN_1L  0.15
VARIABLE  M1_DN_1H  0.80

VARIABLE  VIA1_W_1     0.19 
VARIABLE  VIA1_W_2     0.13 
VARIABLE  VIA1_S_1     0.22 
VARIABLE  VIA1_S_2     0.29 
VARIABLE  VIA1_S_2_S   0.31 
VARIABLE  VIA1_EN_1    0.01 
VARIABLE  VIA1_EN_2    0.05 

VARIABLE  M2_W_1     0.20 
VARIABLE  M2_W_2     0.24
VARIABLE  M2_W_2_L   0.5
VARIABLE  M2_S_1     0.21 
VARIABLE  M2_S_2     0.6 
VARIABLE  M2_S_2_B   1.0 	
VARIABLE  M2_S_3     0.24 
VARIABLE  M2_S_3_L   1.0 	
VARIABLE  M2_S_4     0.24 
VARIABLE  M2_EN_1    0.005 
VARIABLE  M2_EN_2    0.05  	
VARIABLE  M2_A_1     0.144 
VARIABLE  M2_A_2     0.265 	
VARIABLE  DM2_DN_2L 0.15
VARIABLE  DM2_DN_2H 0.80
VARIABLE  M2_DN_1L  0.15
VARIABLE  M2_DN_1H  0.80
VARIABLE  M2_S_5     1.0

VARIABLE  M3_W_1     0.20 
VARIABLE  M3_W_2     0.24
VARIABLE  M3_W_2_L   0.5
VARIABLE  M3_S_1     0.21 
VARIABLE  M3_S_2     0.6 
VARIABLE  M3_S_2_B   1.0 	
VARIABLE  M3_S_3     0.24 
VARIABLE  M3_S_3_L   1.0 	
VARIABLE  M3_S_4     0.24 
VARIABLE  M3_EN_1    0.005 
VARIABLE  M3_EN_2    0.05  	
VARIABLE  M3_A_1     0.144 
VARIABLE  M3_A_2     0.265 	
VARIABLE  DM3_DN_2L 0.15
VARIABLE  DM3_DN_2H 0.80
VARIABLE  M3_DN_1L  0.15
VARIABLE  M3_DN_1H  0.80
VARIABLE  M3_S_5     1.0

VARIABLE  M4_W_1     0.20 
VARIABLE  M4_W_2     0.24
VARIABLE  M4_W_2_L   0.5
VARIABLE  M4_S_1     0.21 
VARIABLE  M4_S_2     0.6 
VARIABLE  M4_S_2_B   1.0 	
VARIABLE  M4_S_3     0.24 
VARIABLE  M4_S_3_L   1.0 	
VARIABLE  M4_S_4     0.24 
VARIABLE  M4_EN_1    0.005 
VARIABLE  M4_EN_2    0.05  	
VARIABLE  M4_A_1     0.144 
VARIABLE  M4_A_2     0.265 	
VARIABLE  DM4_DN_2L 0.15
VARIABLE  DM4_DN_2H 0.80
VARIABLE  M4_DN_1L  0.15
VARIABLE  M4_DN_1H  0.80
VARIABLE  M4_S_5     1.0

VARIABLE  M5_W_1     0.20 
VARIABLE  M5_W_2     0.24
VARIABLE  M5_W_2_L   0.5
VARIABLE  M5_S_1     0.21 
VARIABLE  M5_S_2     0.6 
VARIABLE  M5_S_2_B   1.0 	
VARIABLE  M5_S_3     0.24 
VARIABLE  M5_S_3_L   1.0 	
VARIABLE  M5_S_4     0.24 
VARIABLE  M5_EN_1    0.005 
VARIABLE  M5_EN_2    0.05  	
VARIABLE  M5_A_1     0.144 
VARIABLE  M5_A_2     0.265 	
VARIABLE  DM5_DN_2L 0.15
VARIABLE  DM5_DN_2H 0.80
VARIABLE  M5_DN_1L  0.15
VARIABLE  M5_DN_1H  0.80
VARIABLE  M5_S_5     1.0

#IFDEF THICK_TOP3_METAL

VARIABLE  M6_W_1    0.4 
VARIABLE  M6_S_1    0.42
VARIABLE  M6_S_2    0.6 
VARIABLE  M6_S_2_B  1.0 	
VARIABLE  M6_EN_1    0.02 
VARIABLE  M6_EN_2    0.11
VARIABLE  M6_EN_2_A  0.09
VARIABLE  M6_A_1     0.562 
VARIABLE  M6_A_2     0.565
VARIABLE  DM6_DN_2L 0.20
VARIABLE  DM6_DN_2H 0.80
VARIABLE  M6_DN_1L  0.20
VARIABLE  M6_DN_1H  0.80
#ELSE

VARIABLE  M6_W_1     0.20 
VARIABLE  M6_W_2     0.24
VARIABLE  M6_W_2_L   0.5
VARIABLE  M6_S_1     0.21 
VARIABLE  M6_S_2     0.6 
VARIABLE  M6_S_2_B   1.0 	
VARIABLE  M6_S_3     0.24 
VARIABLE  M6_S_3_L   1.0 	
VARIABLE  M6_S_4     0.24 
VARIABLE  M6_EN_1    0.005 
VARIABLE  M6_EN_2    0.05  	
VARIABLE  M6_A_1     0.144 
VARIABLE  M6_A_2     0.265 	
VARIABLE  DM6_DN_2L 0.15
VARIABLE  DM6_DN_2H 0.80
VARIABLE  M6_DN_1L  0.15
VARIABLE  M6_DN_1H  0.80
#ENDIF
VARIABLE  M6_S_5     1.0

#IFDEF THICK_TOP2_METAL

VARIABLE  M7_W_1    0.4 
VARIABLE  M7_S_1    0.42
VARIABLE  M7_S_2    0.6 
VARIABLE  M7_S_2_B  1.0 	
VARIABLE  M7_EN_1    0.02 
VARIABLE  M7_EN_2    0.11
VARIABLE  M7_EN_2_A  0.09
VARIABLE  M7_A_1     0.562 
VARIABLE  M7_A_2     0.565
VARIABLE  DM7_DN_2L 0.20
VARIABLE  DM7_DN_2H 0.80
VARIABLE  M7_DN_1L  0.20
VARIABLE  M7_DN_1H  0.80
#ELSE
#IFDEF THICK_TOP3_METAL

VARIABLE  M7_W_1    0.4 
VARIABLE  M7_S_1    0.42
VARIABLE  M7_S_2    0.6 
VARIABLE  M7_S_2_B  1.0 	
VARIABLE  M7_EN_1    0.02 
VARIABLE  M7_EN_2    0.11
VARIABLE  M7_EN_2_A  0.09
VARIABLE  M7_A_1     0.562 
VARIABLE  M7_A_2     0.565
VARIABLE  DM7_DN_2L 0.20
VARIABLE  DM7_DN_2H 0.80
VARIABLE  M7_DN_1L  0.20
VARIABLE  M7_DN_1H  0.80
#ELSE

VARIABLE  M7_W_1     0.20 
VARIABLE  M7_W_2     0.24
VARIABLE  M7_W_2_L   0.5
VARIABLE  M7_S_1     0.21 
VARIABLE  M7_S_2     0.6 
VARIABLE  M7_S_2_B   1.0 	
VARIABLE  M7_S_3     0.24 
VARIABLE  M7_S_3_L   1.0 	
VARIABLE  M7_S_4     0.24 
VARIABLE  M7_EN_1    0.005 
VARIABLE  M7_EN_2    0.05  	
VARIABLE  M7_A_1     0.144 
VARIABLE  M7_A_2     0.265 	
VARIABLE  DM7_DN_2L 0.15
VARIABLE  DM7_DN_2H 0.80
VARIABLE  M7_DN_1L  0.15
VARIABLE  M7_DN_1H  0.80
#ENDIF
#ENDIF
VARIABLE  M7_S_5     1.0



VARIABLE  VIA2_W_1     0.19 
VARIABLE  VIA2_W_2     0.13 
VARIABLE  VIA2_S_1     0.22 
VARIABLE  VIA2_S_2     0.29 
VARIABLE  VIA2_S_2_S   0.31 
VARIABLE  VIA2_EN_1    0.005
VARIABLE  VIA2_EN_2    0.05 

VARIABLE  VIA3_W_1     0.19 
VARIABLE  VIA3_W_2     0.13 
VARIABLE  VIA3_S_1     0.22 
VARIABLE  VIA3_S_2     0.29 
VARIABLE  VIA3_S_2_S   0.31 
VARIABLE  VIA3_EN_1    0.005
VARIABLE  VIA3_EN_2    0.05 

VARIABLE  VIA4_W_1     0.19 
VARIABLE  VIA4_W_2     0.13 
VARIABLE  VIA4_S_1     0.22 
VARIABLE  VIA4_S_2     0.29 
VARIABLE  VIA4_S_2_S   0.31 
VARIABLE  VIA4_EN_1    0.005
VARIABLE  VIA4_EN_2    0.05 

#IFDEF THICK_TOP3_METAL

VARIABLE  VIA5_W_1     0.36 
VARIABLE  VIA5_W_2     0.28 
VARIABLE  VIA5_S_1     0.35 
VARIABLE  VIA5_S_2     0.54 
VARIABLE  VIA5_S_2_S   0.56 
VARIABLE  VIA5_EN_1    0.01
VARIABLE  VIA5_EN_2    0.05 
#ELSE

VARIABLE  VIA5_W_1     0.19 
VARIABLE  VIA5_W_2     0.13 
VARIABLE  VIA5_S_1     0.22 
VARIABLE  VIA5_S_2     0.29 
VARIABLE  VIA5_S_2_S   0.31 
VARIABLE  VIA5_EN_1    0.005
VARIABLE  VIA5_EN_2    0.05 
#ENDIF

#IFDEF THICK_TOP2_METAL

VARIABLE  VIA6_W_1     0.36 
VARIABLE  VIA6_W_2     0.28 
VARIABLE  VIA6_S_1     0.35 
VARIABLE  VIA6_S_2     0.54 
VARIABLE  VIA6_S_2_S   0.56 
#IFDEF THICK_TOP3_METAL
VARIABLE  VIA6_EN_1    0.02
VARIABLE  VIA6_EN_2    0.11
VARIABLE  VIA6_EN_2_A   0.09
#ELSE

VARIABLE  VIA6_EN_1    0.01
VARIABLE  VIA6_EN_2    0.05 
#ENDIF
#ELSE
#IFDEF THICK_TOP3_METAL

VARIABLE  VIA6_W_1     0.36 
VARIABLE  VIA6_W_2     0.28 
VARIABLE  VIA6_S_1     0.35 
VARIABLE  VIA6_S_2     0.54 
VARIABLE  VIA6_S_2_S   0.56 
#IFDEF THICK_TOP3_METAL
VARIABLE  VIA6_EN_1    0.02
VARIABLE  VIA6_EN_2    0.11
VARIABLE  VIA6_EN_2_A   0.09
#ELSE

VARIABLE  VIA6_EN_1    0.01
VARIABLE  VIA6_EN_2    0.05 
#ENDIF
#ELSE

VARIABLE  VIA6_W_1     0.19 
VARIABLE  VIA6_W_2     0.13 
VARIABLE  VIA6_S_1     0.22 
VARIABLE  VIA6_S_2     0.29 
VARIABLE  VIA6_S_2_S   0.31 
VARIABLE  VIA6_EN_1    0.005
VARIABLE  VIA6_EN_2    0.05 
#ENDIF
#ENDIF



VARIABLE  M8_W_1    0.4 
VARIABLE  M8_S_1    0.42
VARIABLE  M8_S_2    0.6 
VARIABLE  M8_S_2_B  1.0 	
VARIABLE  M8_EN_1    0.02 
VARIABLE  M8_EN_2    0.11
VARIABLE  M8_EN_2_A  0.09
VARIABLE  M8_A_1     0.562 
VARIABLE  M8_A_2     0.565
VARIABLE  DM8_DN_2L 0.20
VARIABLE  DM8_DN_2H 0.80
VARIABLE  M8_DN_1L  0.20
VARIABLE  M8_DN_1H  0.80

VARIABLE  VIA7_W_1     0.36 
VARIABLE  VIA7_W_2     0.28 
VARIABLE  VIA7_S_1     0.35 
VARIABLE  VIA7_S_2     0.54 
VARIABLE  VIA7_S_2_S   0.56 
#IFDEF THICK_TOP2_METAL
VARIABLE  VIA7_EN_1    0.02
VARIABLE  VIA7_EN_2    0.11
VARIABLE  VIA7_EN_2_A    0.09
#ELSE
#IFDEF THICK_TOP3_METAL
VARIABLE  VIA7_EN_1    0.02
VARIABLE  VIA7_EN_2    0.11
VARIABLE  VIA7_EN_2_A   0.09
#ELSE

VARIABLE  VIA7_EN_1    0.01
VARIABLE  VIA7_EN_2    0.05 
#ENDIF
#ENDIF

VARIABLE  MD_W_1    0.4 
VARIABLE  MD_S_1    0.42
VARIABLE  MD_S_2    0.6 
VARIABLE  MD_S_2_B  1.0 	
VARIABLE  MD_EN_1    0.02 
VARIABLE  MD_EN_2    0.11
VARIABLE  MD_EN_2_A  0.09
VARIABLE  MD_A_1     0.562 
VARIABLE  MD_A_2     0.565 

VARIABLE  VIAD_W_1     0.36 
VARIABLE  VIAD_W_2     0.28
VARIABLE  VIAD_S_1     0.35 
VARIABLE  VIAD_S_2     0.54 
VARIABLE  VIAD_S_2_S   0.56 
VARIABLE  VIAD_EN_1    0.02
VARIABLE  VIAD_EN_2    0.11
VARIABLE  VIAD_EN_2_A  0.09

VARIABLE  LOGO_S_1  10.0

VARIABLE  CSR_S_1   0.32 
VARIABLE  CSR_S_2   0.29 
VARIABLE  CSR_S_3   0.36 
VARIABLE  CSR_W_1   10.0
VARIABLE  CSR_L_1_1 20.0
VARIABLE  CSR_L_1_2 25.0
VARIABLE  CSR_EN_4_1 4.0
VARIABLE  CSR_EN_4_2 6.0
VARIABLE  CSR_EN_5_1 28.0
VARIABLE  CSR_EN_5_2 29.0
VARIABLE  CSR_W_2_1  6.0
VARIABLE  CSR_W_2_2  8.0
VARIABLE  CSR_EN_6  0.60
VARIABLE  CSR_EN_6_1 0.52 
VARIABLE  CSR_EN_7  0.25
VARIABLE  SR_S_1    10.0







// DRAWN LAYER DEFINITIONS
//------------------------

LAYER DNWELLi    1     			// DNWELL deep-nwell
LAYER NWELLi     3000      		// NWELL  nwell technology
LAYER MAP 3 DATATYPE >=0 <=255 3000
LAYER NWi_OTHERS  3001     
LAYER MAP 3 DATATYPE >=1 <=255 3001
LAYER ODi      355 7 8     		// DIFF PDIFF NDIFF active areas
LAYER MAP 6 DATATYPE 0 355
LAYER MAP 6 DATATYPE >=2 <=255 355
LAYER ODi_RFDRAIN 391 
LAYER MAP 6 DATATYPE 3 391
LAYER ODi_OTHERS  354 7 8
LAYER MAP 6 DATATYPE >=2 <=255 354
LAYER DOD        340    		// Dummy OD (DIFF)
LAYER MAP 6   DATATYPE 1 340  		// Mapping (6;1) to 340 for dummy OD as default
// DOD should be an individual CAD layer and different from real OD
LAYER ODBLK      350    		// DOD and DPO blocking for insertion
LAYER MAP 150 DATATYPE 20 350
LAYER OD2i       15     		// OD2 define thick oxides for HV gates
LAYER POLYGi     365    			// POLYG polysilicon gates, interconnect
LAYER MAP 17 DATATYPE 0 365
LAYER MAP 17 DATATYPE >=2 <=255 365
LAYER DPO        342   	 		// Dummy Poly
LAYER MAP 17  DATATYPE 1 342  		// Mapping (17;1) to 342 for dummy PO
LAYER POi_OTHERS 364            
LAYER MAP 17 DATATYPE >=2 <=255 364
// DPO should be an individual CAD layer and different from real POLGY
LAYER POBLK      351    		// DPO blocking for insertion
LAYER MAP 150 DATATYPE 21 351
LAYER PIMPi      25     		// PIMP P+ imlant
LAYER NIMPi      26     		// NIMP N+ imlant
LAYER CONTi      30     		// CONT Define connect for M1 to S/D and Gate

LAYER METAL1i    31     		// METAL1
LAYER M1SLOTi    321    		// Metal1 slot (if drawn)
LAYER MAP 31  DATATYPE 2 321  		// Mapping (31;2) to 321 for M1SLOTi
LAYER DUM1       331  			// dummy Metal1
LAYER MAP 31  DATATYPE 1 331  		// Mapping (31;1) to 331 for DUM1
LAYER DM1EXCL    371
LAYER MAP 150 DATATYPE 1 371
LAYER METAL2i    32     		// METAL2
LAYER M2SLOTi    322    		// Metal2 slot (if drawn)
LAYER MAP 32  DATATYPE 2 322  		// Mapping (32;2) to 322 for M2SLOTi
LAYER DUM2       332  			// dummy Metal2
LAYER MAP 32  DATATYPE 1 332  		// Mapping (32;1) to 332 for DUM2
LAYER DM2EXCL    372
LAYER MAP 150 DATATYPE 2 372
LAYER METAL3i    33     		// METAL3
LAYER M3SLOTi    323    		// Metal3 slot (if drawn)
LAYER MAP 33  DATATYPE 2 323  		// Mapping (33;2) to 323 for M3SLOTi
LAYER DUM3       333  			// dummy Metal3
LAYER MAP 33  DATATYPE 1 333  		// Mapping (33;1) to 333 for DUM3
LAYER DM3EXCL    373
LAYER MAP 150 DATATYPE 3 373
LAYER METAL4i    34     		// METAL4
LAYER M4SLOTi    324    		// Metal4 slot (if drawn)
LAYER MAP 34  DATATYPE 2 324  		// Mapping (34;2) to 324 for M4SLOTi
LAYER DUM4       334  			// dummy Metal4
LAYER MAP 34  DATATYPE 1 334  		// Mapping (34;1) to 334 for DUM4
LAYER DM4EXCL    374
LAYER MAP 150 DATATYPE 4 374
LAYER METAL5i    35     		// METAL5
LAYER M5SLOTi    325    		// Metal5 slot (if drawn)
LAYER MAP 35  DATATYPE 2 325  		// Mapping (35;2) to 325 for M5SLOTi
LAYER DUM5       335  			// dummy Metal5
LAYER MAP 35  DATATYPE 1 335  		// Mapping (35;1) to 335 for DUM5
LAYER DM5EXCL    375
LAYER MAP 150 DATATYPE 5 375
LAYER METAL6i    36     		// METAL6
LAYER M6SLOTi    326    		// Metal6 slot (if drawn)
LAYER MAP 36  DATATYPE 2 326  		// Mapping (36;2) to 326 for M6SLOTi
LAYER DUM6       336  			// dummy Metal6
LAYER MAP 36  DATATYPE 1 336  		// Mapping (36;1) to 336 for DUM6
LAYER DM6EXCL    376
LAYER MAP 150 DATATYPE 6 376
LAYER METAL7i    37     		// METAL7
LAYER M7SLOTi    327    		// Metal7 slot (if drawn)
LAYER MAP 37  DATATYPE 2 327  		// Mapping (37;2) to 327 for M7SLOTi
LAYER DUM7       337  			// dummy Metal7
LAYER MAP 37  DATATYPE 1 337  		// Mapping (37;1) to 337 for DUM7
LAYER DM7EXCL    377
LAYER MAP 150 DATATYPE 7 377
LAYER METAL8i    38     		// METAL8
LAYER M8SLOTi    328    		// Metal8 slot (if drawn)
LAYER MAP 38  DATATYPE 2 328  		// Mapping (38;2) to 328 for M8SLOTi
LAYER DUM8       338  			// dummy Metal8
LAYER MAP 38  DATATYPE 1 338  		// Mapping (38;1) to 338 for DUM8
LAYER DM8EXCL    378
LAYER MAP 150 DATATYPE 8 378
LAYER METAL9i    39     		// METAL9
LAYER M9SLOTi    329    		// Metal9 slot (if drawn)
LAYER MAP 39  DATATYPE 2 329  		// Mapping (39;2) to 329 for M9SLOTi
LAYER DUM9       339  			// dummy Metal9
LAYER MAP 39  DATATYPE 1 339  		// Mapping (39;1) to 339 for DUM9
LAYER DM9EXCL    379
LAYER MAP 150 DATATYPE 9 379
LAYER MDi        168    		// MD For RDL interconnection
LAYER MDSLOTi    343    		// MD slot (if drawn)
LAYER MAP 168 DATATYPE 2 343  		// Mapping (168;2) to 343 for MDSLOTi
LAYER DUMD       344  			// dummy MD
LAYER MAP 168 DATATYPE 1 344  		// Mapping (168;1) to 344 for DUMD
LAYER DMDEXCL    380
LAYER MAP 150 DATATYPE 15 380

LAYER VIA12i     51     		// VIA12 Define connection from M2 to M1
LAYER VIA23i     52     		// VIA23 Define connection from M3 to M2
LAYER VIA34i     53     		// VIA34 Define connection from M4 to M3
LAYER VIA45i     54     		// VIA45 Define connection from M5 to M4
LAYER VIA56i     55     		// VIA56 Define connection from M6 to M5
LAYER VIA67i     56     		// VIA67 Define connection from M7 to M6
LAYER VIA78i     57     		// VIA78 Define connection from M8 to M7
LAYER VIA89i     58     		// VIA89 Define connection from M9 to M8
LAYER VIADi      167    		// VIAD	Connection between MD and Mtop for RDL
LAYER RVi         85                    // Via hole for AlRDL
LAYER APi        42
LAYER PADi       43     		// PAD(CB) Passivation opening for Bond Pad

LAYER CB2i       86                     // Passivation 2 for AP RDL used.
LAYER CBDi       169    		// CBD for solder bump and RDL layer (filp-chip design) 
LAYER UBMi       170    		// UBM for solder bump and RDL layer 
LAYER WBDMY      183			// WBDMY for CUP structure recognition

LAYER RPOi       29     		// RPO Silicide blockage layer
LAYER NT_Ni      11     		// NTN Native NMOS implant blockage
LAYER VTL_Ni     12     		// VT1MN 1.2V Low Vt NMOS Implant
LAYER VTL_Pi     13     		// VT1MP 1.2V Low Vt PMOS Implant
LAYER VTH_Ni     67     		// VT2MN 1.0V or 1.2V High Vt NMOS Implant
LAYER VTH_Pi     68     		// VT2MP 1.0V or 1.2V High Vt PMOS Implant
LAYER LVIDi       73                    // 1.5V Low Vt NMOS/PMOS Implant
LAYER CTMi       77     		// CTM MiM capacitor
LAYER HRIi       70     		// HRI High resistor implant
LAYER FWi        95     		// FW Fuse passivation window


LAYER PLMIDEi    5      		// PLMIDE Polymide (PM)
LAYER SEALRING   162	 		// SEALRING Layer used seal ring area
LAYER CSRDMY	 166	 		// CSRDMY Layer to cover chip corner areas

// Dummy Layers

LAYER NWDMY      114    		// NWDMY NWEL resistor dummy layer
LAYER HOTWL	 112    		// HOTWL Dummy layer to mark hot-NWELL for DRC 
LAYER RHDMY      117    		// RHDMY Dummy layer for OD/POLY resistoris
LAYER RPDMY      115    		// RPDMY Dummy layer for precision high poly resistor
LAYER PMDMY      106    		// PMDMY Dummy layer for fuse window and protection ring structure
LAYER SDI        122    		// SDI DRC purpose for ESD protection devices
LAYER ESD1DMY    145	 		// ESD1DMY for ESD protection devices
LAYER ESD2DMY    146    		// ESD2DMY for ESD protection devices
LAYER ESD3DMY    147    		// ESD3DMY for ESD protection devices
LAYER LMARK      109    		// LMARK Alignment Mark Rule for Laser Repair
LAYER RHRIDMY    120    		// RHRIDMY Dummy layer for precision HRI poly resistor
LAYER VARDMY     143    		// VARDMY Dummy layer for both MOS and junction type varactor
LAYER LOGO       158  			// Dummy layer for product labels and LOGO
LAYER INDDMY     144    		// INDDMY Dummy layer to cover inductor devices
LAYER CBMi       88       		// Definition of capacitor bottom metal
LAYER CDUDMY     165    		// CDUDMY Dummy layer to cover CDU pattern 
LAYER EXCLi      121    		// EXCL Exclude all layers for DRC except SRAM region
LAYER MAP 128 DATATYPE 0 3400 
LAYER IO_buffer 3400        	// Dummy layer to define I/O BUFFER.
LAYER DMSRMi     50	 		// DMSRM dummy layer to cover SRAM cells to exclude DRC 
			 		// below M2. DRC still checks M2 and above. 
LAYER HVTSRM     60	 		// HVTSRM dummy layer to cover high Vt SRAM cells 
LAYER SRAMDMY    400  			// SRAM DRC violations waive layer
LAYER MAP 186 DATATYPE 0 400 
LAYER RRuleRequired 1821	// marker layer for action-required DFM rules
LAYER MAP 182 DATATYPE 1 1821
LAYER RRuleRecommended 1822	// marker layer for recommended DFM rules
LAYER MAP 182 DATATYPE 2 1822
LAYER RRuleAnalog 1823		// marker layer for DFM guidelines for analog circuits
LAYER MAP 182 DATATYPE 3 1823
LAYER RFDMY      161  // For RF circuit
LAYER BJTDMY 110              // BJT dummy layer to cover BJT device
LAYER DIODMY 119  	       // dummy layer for diode
LAYER CTMDMY     148    		// CTMDMY Dummy layer for MiM capacitor bottom plate

LAYOUT TOP LAYER DOD ODBLK DPO POBLK
LAYOUT TOP LAYER METAL1i M1SLOTi DUM1 DM1EXCL VIA12i
LAYOUT TOP LAYER METAL2i M2SLOTi DUM2 DM2EXCL VIA23i
LAYOUT TOP LAYER METAL3i M3SLOTi DUM3 DM3EXCL VIA34i
LAYOUT TOP LAYER METAL4i M4SLOTi DUM4 DM4EXCL VIA45i
LAYOUT TOP LAYER METAL5i M5SLOTi DUM5 DM5EXCL VIA56i
LAYOUT TOP LAYER METAL6i M6SLOTi DUM6 DM6EXCL VIA67i
LAYOUT TOP LAYER METAL7i M7SLOTi DUM7 DM7EXCL VIA78i
LAYOUT TOP LAYER METAL8i M8SLOTi DUM8 DM8EXCL VIA89i
LAYOUT TOP LAYER METAL9i M9SLOTi DUM9 DM9EXCL
LAYOUT TOP LAYER VIADi MDi MDSLOTi DUMD DMDEXCL CTMi CTMDMY INDDMY
LAYOUT TOP LAYER PADi CBDi UBMi FWi LMARK PLMIDEi SEALRING CSRDMY
LAYOUT TOP LAYER HOTWL EXCLi LOGO DMSRMi HVTSRM
LAYOUT TOP LAYER RHDMY PMDMY SDI ESD1DMY ESD2DMY ESD3DMY
LAYOUT TOP LAYER APi WBDMY CBMi CDUDMY SRAMDMY

ALL_OD   = ODi     OR  DOD  		//For OD density checks
ALL_POLY = POLYGi  OR  DPO

LAYOUT BASE LAYER POLYGi ODi CONTi PIMPi NIMPi NWELLi  

// Metal in silicon

M1x = METAL1i NOT M1SLOTi
ALL_M1        = M1x OR DUM1

M2x = METAL2i NOT M2SLOTi
ALL_M2        = M2x OR DUM2

M3x = METAL3i NOT M3SLOTi
ALL_M3        = M3x OR DUM3

M4x = METAL4i NOT M4SLOTi
ALL_M4        = M4x OR DUM4

M5x = METAL5i NOT M5SLOTi
ALL_M5        = M5x OR DUM5

M6x = METAL6i NOT M6SLOTi
ALL_M6        = M6x OR DUM6

M7x = METAL7i NOT M7SLOTi
ALL_M7        = M7x OR DUM7

M8x = METAL8i NOT M8SLOTi
ALL_M8        = M8x OR DUM8

M9x = METAL9i NOT M9SLOTi
ALL_M9        = M9x OR DUM9

MDx = MDi     NOT MDSLOTi
ALL_MD        = MDx OR DUMD

 MT_LAYERS =  (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((DNWELLi OR NWELLi) OR ODi) OR ODi_RFDRAIN) OR DOD) OR OD2i) OR POLYGi) OR DPO) OR PIMPi) OR NIMPi) OR CONTi) OR METAL1i) OR M1SLOTi) OR DUM1) OR METAL2i) OR M2SLOTi) OR DUM2) OR METAL3i) OR M3SLOTi) OR DUM3) OR METAL4i) OR M4SLOTi) OR DUM4) OR METAL5i) OR M5SLOTi) OR DUM5) OR METAL6i) OR M6SLOTi) OR DUM6) OR METAL7i) OR M7SLOTi) OR DUM7) OR METAL8i) OR M8SLOTi) OR DUM8) OR METAL9i) OR M9SLOTi) OR DUM9) OR MDi) OR MDSLOTi) OR DUMD) OR VIA12i) OR VIA23i) OR VIA34i) OR VIA45i) OR VIA56i) OR VIA67i) OR VIA78i) OR VIA89i) OR VIADi) OR RVi) OR APi) OR PADi) OR CB2i) OR CBDi) OR UBMi) OR RPOi) OR NT_Ni) OR VTL_Ni) OR VTL_Pi) OR VTH_Ni) OR VTH_Pi) OR LVIDi) OR CTMi) OR HRIi) OR FWi) OR PLMIDEi) OR SEALRING) OR HOTWL) OR LMARK) OR CBMi) OR EXCLi) OR IO_buffer) OR DMSRMi) OR HVTSRM

// GLOBAL DERIVED LAYERS FOR RULE CHECKS
//--------------------------------------

CHIP         = EXTENT MT_LAYERS
//CHIP     = EXTENT CELL "*" ORIGINAL 


BULK       = SIZE CHIP BY 1.0
PWELi 	   = BULK NOT NWELLi

// EXCLUDE UNCHECKED REGIONS
//--------------------------

#IFDEF SRAMDMY_USED_ONLY
  EXCL     = CHIP NOT BULK  // An empty layer to disable the usage of EXCL
  EXCL_SRM = COPY SRAMDMY
#ELSE
  DMSRM    = DMSRMi OR SRAMDMY
  EXCL     = EXCLi  NOT DMSRM
  EXCL_SRM = EXCL   OR DMSRM
#ENDIF

EXCL_SRM_CDUDMY = EXCL_SRM OR CDUDMY 	// exclude the patterns inside the CDU
PWEL    = PWELi   NOT EXCL_SRM

DNW     = DNWELLi NOT INSIDE EXCL_SRM
NWEL    = NWELLi  NOT INSIDE EXCL_SRM
OD      = ODi     NOT EXCL_SRM_CDUDMY


OD2     = OD2i    NOT EXCL_SRM
POLY    = POLYGi  NOT EXCL_SRM_CDUDMY
PP      = PIMPi   NOT INSIDE EXCL_SRM
NP      = NIMPi   NOT INSIDE EXCL_SRM
RPO     = RPOi    NOT EXCL_SRM
NTN     = NT_Ni   NOT EXCL_SRM
VTLN    = VTL_Ni  NOT EXCL_SRM
VTLP    = VTL_Pi  NOT EXCL_SRM
VTHN    = VTH_Ni  NOT EXCL_SRM
VTHP    = VTH_Pi  NOT EXCL_SRM
LVID    = LVIDi   NOT EXCL_SRM
HRI	= HRIi	  NOT EXCL_SRM
CO      = CONTi   NOT EXCL_SRM_CDUDMY
M1      = M1x     NOT EXCL_SRM_CDUDMY
VIA1    = VIA12i  NOT EXCL_SRM
// M2 and above layers inside DMSRM/SRAMDMY will be checked.
M2      = M2x     NOT INSIDE EXCL
VIA2    = VIA23i  NOT INSIDE EXCL
M3      = M3x     NOT INSIDE EXCL
VIA3    = VIA34i  NOT INSIDE EXCL
M4      = M4x     NOT INSIDE EXCL
VIA4    = VIA45i  NOT INSIDE EXCL
M5      = M5x     NOT INSIDE EXCL
VIA5    = VIA56i  NOT INSIDE EXCL
M6      = M6x     NOT INSIDE EXCL
VIA6    = VIA67i  NOT INSIDE EXCL
M7      = M7x     NOT INSIDE EXCL
VIA7    = VIA78i  NOT INSIDE EXCL
M8      = M8x     NOT INSIDE EXCL
VIA8    = VIA89i  NOT INSIDE EXCL
M9	= M9x     NOT INSIDE EXCL
VIAD    = VIADi   NOT INSIDE EXCL
MD      = MDx     NOT INSIDE EXCL


CB      = PADi    NOT INSIDE EXCL	// CB/PAD for wire bond
CBD     = CBDi    NOT INSIDE EXCL  	// CBD for flip chip
UBM     = UBMi    NOT INSIDE EXCL	// UBM for ground-up
CB2     = CB2i    NOT INSIDE EXCL        

FW      = FWi     NOT INSIDE EXCL
PLMIDE  = PLMIDEi NOT INSIDE EXCL

CTM	= CTMi	  NOT INSIDE EXCL	// Capacitor top metal
CBM     = CBMi    NOT INSIDE EXCL	// Capacitor bottom metal

// Bond Pads

ALL_PAD = (PADi OR CBDi) OR RVi
LMARK_MD = LMARK INTERACT MDi     // LMARK for Cu-RDL
LMARK_MT = LMARK NOT INTERACT MDi // LMARK for non-RDL & Al-RDL

LMARK_METAL = (METAL8i AND LMARK_MT) OR (MDi AND LMARK) // might be slot or solid
LSLOT = HOLES LMARK_METAL EMPTY  // L shaped oxide in L-mark metal in corner or pad
LSOLID = LMARK_METAL NOT INTERACT LSLOT // L solid metal

LMARK_SLOT  = LMARK INTERACT LSLOT 
LMARK_SOLID = LMARK INTERACT LSOLID

RNGX    = PMDMY   NOT FW
VIA_EXD = RNGX    OR  SEALRING			// for line via waiving
// Bonding pad, chip corner dummy pad, and inductor need not put slot

CB_NON_CUP = PADi NOT INTERACT WBDMY
SLT_EXD = ( LMARK OR CSRDMY ) OR CB_NON_CUP

FC_NOT   = MDx OR CB2
PAD_EXD  = UBM NOT INTERACT FC_NOT    		// for ground-up 

// For NW checks

RPO_RPDMY  = (RPOi   OR  RPDMY) NOT EXCL_SRM	// for resistor recognition
NRODi      = ODi     NOT RPDMY		
NPODi      = NIMPi   AND NRODi
NONWRi     = NWELLi  NOT INTERACT NWDMY // for NW.S.1/NW.S.2/NW.S.3
NSTPi      = NPODi   AND NONWRi         // NWell pickup 
PPODi      = PIMPi   AND NRODi
PSTPi      = PPODi   NOT NWELLi         // Substrate (pwell) tap diffusion
NACTi      = NPODi   NOT NWELLi         // NMOS device active diffusion including regions of SRAM
PACTi      = PPODi   AND NONWRi		// PMOS 
NSDi       = NACTi   NOT POLYGi         // NMOS source/drain
PSDi       = PACTi   NOT POLYGi		// PMOS source/drain
ILP1i      = POLYGi  NOT RPO_RPDMY	// interconnect poly

NW2V	= NWEL    AND OD2
NW1V	= NWEL    NOT OD2

// For NW (within OD) resistor checks

RNWEL        = NWEL INTERACT NWDMY	// NW resistor (UNDER OD & STI)
NONWR        = NWEL NOT INTERACT NWDMY	// NW exclude resistor area
ODWR         = OD   INTERACT RNWEL	// OD area of NW resistor

IMP          = NP OR  PP
NPOD         = OD AND NP
PPOD         = OD AND PP
COOD         = CO AND OD		// Contact diffusions 
COPO         = CO NOT OD		// Contacts on poly + floating contacts
//COPO       = POLY AND CO              // POLY contacts + floating contacts

NSTP         = NPOD AND NONWR		// NW strap diffusion
NACT         = NPOD NOT NWEL		// NMOS device active diffusion
PSTP         = PPOD NOT NWEL		// Substrate (pwell) strap diffusion
PACT         = PPOD AND NWEL		// PMOS device active diffusion

DACT         = NACT OR PACT		// NMOS/PMOS device active diffusion
GATE         = POLY AND OD		// Gate regions for NMOS and PMOS
SD           = (DACT ENCLOSE GATE) NOT GATE  // Source, drain areas
DSTP         = NSTP OR PSTP		// All straps

FPO1         = POLY NOT ODi		// Field poly
HV_GATE      = GATE AND OD2
LV_GATE      = GATE NOT OD2

GATE_NP      = GATE AND NP
GATE_PP      = GATE AND PP

GATE_W       = POLY INSIDE EDGE OD     		// Gate width
GATE_L       = OD   INSIDE EDGE POLY   		// Coincident edge of interconnect POLY

GATEN_W      = GATE_W INSIDE EDGE NP
GATEP_W      = GATE_W INSIDE EDGE PP

HV_GATE_W    = GATE_W INSIDE EDGE OD2		// 2.5V MOS gates
LV_GATE_W    = GATE_W NOT INSIDE EDGE OD2	// 1.2V/1.0V MOS gates
HV_NGATE_W   = HV_GATE_W INSIDE EDGE NP		// 2.5V NMOS gate edges
HV_PGATE_W   = HV_GATE_W INSIDE EDGE PP		// 2.5V PMOS gate edges
LV_NGATE_W   = LV_GATE_W INSIDE EDGE NP		// 1.2V/1.0V NMOS gate edges
LV_PGATE_W   = LV_GATE_W INSIDE EDGE PP		// 1.2V/1.0V PMOS gate edges

// For poly and od resistors identify

RES_NOT_SDI  = RPO_RPDMY NOT SDI 	// For OD/poly resistors
PORES_IN_SDI = (SDI   AND RPO_RPDMY) AND FPO1
PORES_NOT_SDI= RES_NOT_SDI AND FPO1
PORES	     = ( ( PORES_IN_SDI OR PORES_NOT_SDI ) OUTSIDE BJTDMY ) OUTSIDE INDDMY	// POLY resistor region
FOD          = (( (OD    OUTSIDE NWDMY) OUTSIDE GATE ) OUTSIDE BJTDMY ) OUTSIDE INDDMY  // field oxide
ODRES        = RPO_RPDMY AND FOD 	// OD resistor region
ODPO_RES     = ODRES  OR  PORES		// All OD/poly resitors

// For VTL/H_N/P.R.2 checks

RPO_OD       = RPO AND OD
RPO_PO       = RPO AND POLY

// For ESD checks

PMOS  	     = PACT ENCLOSE GATE
NMOS  	     = NACT ENCLOSE GATE
PASD  	     = PMOS NOT GATE		// Source/Drain of PMOS
NASD  	     = NMOS NOT GATE		// Source/Drain of NMOS
EPMOS 	     = SDI  AND PMOS		// ESD PMOS device
ENMOS 	     = SDI  AND NMOS		// ESD NMOS device

// For SEAL-RING and CHIP CORNER checks.

#IFDEF LmarkSealringCorner
SR_M1 = ((M1x INTERACT SEALRING) NOT ((M1x AND CSRDMY) NOT SEALRING)) NOT INTERACT PMDMY
#ELSE
SR_M1        = (M1x INTERACT SEALRING) NOT INTERACT PMDMY
#ENDIF   
SR_M2        = (M2x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M3        = (M3x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M4        = (M4x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M5        = (M5x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M6        = (M6x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M7        = (M7x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M8        = (M8x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M9        = (M9x INTERACT SEALRING) NOT INTERACT PMDMY
SR_MD        = (MDx INTERACT SEALRING) NOT INTERACT PMDMY

#IFDEF FULL_CHIP
CHIP_CORE    = SIZE CHIP BY -20		// Width of the seal-ring + assembly isolation
#ELSE
CHIP_CORE    = COPY CHIP
#ENDIF

PADH         = HOLES ALL_PAD
SCORE        = CHIP_CORE INSIDE PADH
CHIP_WISR    = CHIP INTERACT SCORE
SR_EDGE      =   CHIP_WISR NOT SCORE 
CHIP_NOSR    = CHIP  NOT INTERACT SR_EDGE
CHIP_NOSR1 = COPY CHIP_NOSR
CHIP_NOSR2 = COPY CHIP_NOSR







// For big chip corner
// without seal-ring

// with seal-ring

#IFDEF FULL_CHIP
#IFDEF BigSealringCorner
CHIP_US = SIZE CHIP_NOSR BY -157
CHIP_EXP = EXPAND EDGE CHIP_US OUTSIDE BY 157
CHIP_NO_CORNER = CHIP_US OR CHIP_EXP
CHIP_CORNER = CHIP_NOSR NOT CHIP_NO_CORNER
CORNER_TRI = EXT CHIP_NO_CORNER < 72 ABUT == 90 REGION INTERSECTING ONLY
// without seal-ring
EMPTY_AREA = ( CHIP_CORNER NOT CORNER_TRI ) AND CHIP_NOSR
// with seal-ring
CHIP_WISR_CORE = SIZE((SIZE CHIP_WISR BY -20) NOT CSRDMY) BY 15 UNDEROVER  
SRCSR = CHIP_WISR NOT CHIP_WISR_CORE // sealring+corner+assembly isolation
#ELSE
#IFDEF SmallSealringCorner
// without seal-ring
EMPTY_AREA = INT CHIP_NOSR1 < 157 ABUT == 90 REGION INTERSECTING ONLY
// with seal-ring
CHIP_WISR_CORE = (SIZE CHIP_WISR BY -20) NOT CSRDMY
SRCSR = CHIP_WISR NOT CHIP_WISR_CORE // sealring+corner+assembly isolation
#ELSE
#IFDEF LmarkSealringCorner
// without seal-ring
EMPTY_AREA = INT CHIP_NOSR2 < 70.5 ABUT == 90 REGION INTERSECTING ONLY
// with seal-ring
CHIP_WISR_CORE = SIZE (CHIP_WISR NOT CSRDMY) BY -20  
SRCSR = CHIP_WISR NOT CHIP_WISR_CORE // sealring+corner+assembly isolation
#ELSE  // not specify seal-ring structure, use BigSealringCorner
CHIP_US = SIZE CHIP_NOSR BY -157
CHIP_EXP = EXPAND EDGE CHIP_US OUTSIDE BY 157
CHIP_NO_CORNER = CHIP_US OR CHIP_EXP
CHIP_CORNER = CHIP_NOSR NOT CHIP_NO_CORNER
CORNER_TRI = EXT CHIP_NO_CORNER < 72 ABUT == 90 REGION INTERSECTING ONLY
// without seal-ring
EMPTY_AREA = ( CHIP_CORNER NOT CORNER_TRI ) AND CHIP_NOSR
// with seal-ring
CHIP_WISR_CORE = SIZE((SIZE CHIP_WISR BY -20) NOT CSRDMY) BY 15 UNDEROVER  
SRCSR = CHIP_WISR NOT CHIP_WISR_CORE // sealring+corner+assembly isolation
#ENDIF
#ENDIF
#ENDIF

CHIP_CHAMFERED = CHIP NOT EMPTY_AREA
#ENDIF
#IFDEF FULL_CHIP
  OD_DEN_EXC_L1    = ((((NWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY) OR EMPTY_AREA // exclude check
  PO_DEN_EXC       = (ODBLK OR POBLK) OR OD_DEN_EXC_L1 // SRCSR is included to check
  METAL_DEN_EXC = (((FWi OR LMARK) OR LOGO) OR INDDMY) OR EMPTY_AREA
#ELSE
  OD_DEN_EXC_L1    = (((NWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY
  PO_DEN_EXC       = (ODBLK OR POBLK) OR OD_DEN_EXC_L1
  METAL_DEN_EXC = ((FWi OR LMARK) OR LOGO) OR INDDMY
#ENDIF

// For DFM rules
Block = ((((PADi OR PMDMY) OR CSRDMY) OR LOGO) OR SEALRING) OR LMARK
SRAM_EXCLUDE = COPY EXCL_SRM

COL    = ENCLOSE RECTANGLE CONTi 0.005 200
SR_CO  = COL AND SR_M1   
SR_V1  = (VIA12i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V2  = (VIA23i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V3  = (VIA34i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V4  = (VIA45i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V5  = (VIA56i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V6  = (VIA67i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V7  = (VIA78i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V8  = (VIA89i INTERACT SEALRING) NOT INTERACT PMDMY
SR_VD  = (VIADi INTERACT SEALRING) NOT INTERACT PMDMY 




#IFNDEF DFM_ONLY

// Rules of User Guide
//====================

G.1.DNWELLi { @ grid must be an integer multiple of ^GRID um
  OFFGRID DNWELLi 5
}
G.1.NWELLi { @ grid must be an integer multiple of ^GRID um
  OFFGRID NWELLi 5
}
G.1.NWi_OTHERS { @ grid must be an integer multiple of ^GRID um
  OFFGRID NWi_OTHERS 5
}
G.1.ODi { @ grid must be an integer multiple of ^GRID um
  OFFGRID ODi 5
}
G.1.ODi_RFDRAIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID ODi_RFDRAIN 5
}
G.1.ODi_OTHERS { @ grid must be an integer multiple of ^GRID um
  OFFGRID ODi_OTHERS 5
}
G.1.DOD { @ grid must be an integer multiple of ^GRID um
  OFFGRID DOD 5
}
G.1.ODBLK { @ grid must be an integer multiple of ^GRID um
  OFFGRID ODBLK 5
}
G.1.OD2i { @ grid must be an integer multiple of ^GRID um
  OFFGRID OD2i 5
}
G.1.POLYGi { @ grid must be an integer multiple of ^GRID um
  OFFGRID POLYGi 5
}
G.1.DPO { @ grid must be an integer multiple of ^GRID um
  OFFGRID DPO 5
}
G.1.POi_OTHERS { @ grid must be an integer multiple of ^GRID um
  OFFGRID POi_OTHERS 5
}
G.1.POBLK { @ grid must be an integer multiple of ^GRID um
  OFFGRID POBLK 5
}
G.1.PIMPi { @ grid must be an integer multiple of ^GRID um
  OFFGRID PIMPi 5
}
G.1.NIMPi { @ grid must be an integer multiple of ^GRID um
  OFFGRID NIMPi 5
}
G.1.CONTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID CONTi 5
}
G.1.M1SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M1SLOTi 5
}
G.1.DUM1 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM1 5
}
G.1.DM1EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM1EXCL 5
}
G.1.M2SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M2SLOTi 5
}
G.1.DUM2 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM2 5
}
G.1.DM2EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM2EXCL 5
}
G.1.M3SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M3SLOTi 5
}
G.1.DUM3 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM3 5
}
G.1.DM3EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM3EXCL 5
}
G.1.M4SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M4SLOTi 5
}
G.1.DUM4 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM4 5
}
G.1.DM4EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM4EXCL 5
}
G.1.M5SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M5SLOTi 5
}
G.1.DUM5 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM5 5
}
G.1.DM5EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM5EXCL 5
}
G.1.M6SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M6SLOTi 5
}
G.1.DUM6 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM6 5
}
G.1.DM6EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM6EXCL 5
}
G.1.M7SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M7SLOTi 5
}
G.1.DUM7 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM7 5
}
G.1.DM7EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM7EXCL 5
}
G.1.M8SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M8SLOTi 5
}
G.1.DUM8 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM8 5
}
G.1.DM8EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM8EXCL 5
}
G.1.M9SLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID M9SLOTi 5
}
G.1.DUM9 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM9 5
}
G.1.DM9EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM9EXCL 5
}
G.1.MDi { @ grid must be an integer multiple of ^GRID um
  OFFGRID MDi 5
}
G.1.MDSLOTi { @ grid must be an integer multiple of ^GRID um
  OFFGRID MDSLOTi 5
}
G.1.DUMD { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUMD 5
}
G.1.DMDEXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DMDEXCL 5
}
G.1.VIA12i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA12i 5
}
G.1.VIA23i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA23i 5
}
G.1.VIA34i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA34i 5
}
G.1.VIA45i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA45i 5
}
G.1.VIA56i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA56i 5
}
G.1.VIA67i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA67i 5
}
G.1.VIA78i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA78i 5
}
G.1.VIA89i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA89i 5
}
G.1.VIADi { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIADi 5
}
G.1.RVi { @ grid must be an integer multiple of ^GRID um
  OFFGRID RVi 5
}
G.1.APi { @ grid must be an integer multiple of ^GRID um
  OFFGRID APi 5
}
G.1.PADi { @ grid must be an integer multiple of ^GRID um
  OFFGRID PADi 5
}
G.1.CB2i { @ grid must be an integer multiple of ^GRID um
  OFFGRID CB2i 5
}
G.1.CBDi { @ grid must be an integer multiple of ^GRID um
  OFFGRID CBDi 5
}
G.1.UBMi { @ grid must be an integer multiple of ^GRID um
  OFFGRID UBMi 5
}
G.1.WBDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID WBDMY 5
}
G.1.RPOi { @ grid must be an integer multiple of ^GRID um
  OFFGRID RPOi 5
}
G.1.NT_Ni { @ grid must be an integer multiple of ^GRID um
  OFFGRID NT_Ni 5
}
G.1.VTL_Ni { @ grid must be an integer multiple of ^GRID um
  OFFGRID VTL_Ni 5
}
G.1.VTL_Pi { @ grid must be an integer multiple of ^GRID um
  OFFGRID VTL_Pi 5
}
G.1.VTH_Ni { @ grid must be an integer multiple of ^GRID um
  OFFGRID VTH_Ni 5
}
G.1.VTH_Pi { @ grid must be an integer multiple of ^GRID um
  OFFGRID VTH_Pi 5
}
G.1.LVIDi { @ grid must be an integer multiple of ^GRID um
  OFFGRID LVIDi 5
}
G.1.CTMi { @ grid must be an integer multiple of ^GRID um
  OFFGRID CTMi 5
}
G.1.HRIi { @ grid must be an integer multiple of ^GRID um
  OFFGRID HRIi 5
}
G.1.FWi { @ grid must be an integer multiple of ^GRID um
  OFFGRID FWi 5
}
G.1.PLMIDEi { @ grid must be an integer multiple of ^GRID um
  OFFGRID PLMIDEi 5
}
G.1.SEALRING { @ grid must be an integer multiple of ^GRID um
  OFFGRID SEALRING 5
}
G.1.CSRDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID CSRDMY 5
}
G.1.NWDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID NWDMY 5
}
G.1.HOTWL { @ grid must be an integer multiple of ^GRID um
  OFFGRID HOTWL 5
}
G.1.RHDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID RHDMY 5
}
G.1.RPDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID RPDMY 5
}
G.1.PMDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID PMDMY 5
}
G.1.SDI { @ grid must be an integer multiple of ^GRID um
  OFFGRID SDI 5
}
G.1.ESD1DMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID ESD1DMY 5
}
G.1.ESD2DMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID ESD2DMY 5
}
G.1.ESD3DMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID ESD3DMY 5
}
G.1.LMARK { @ grid must be an integer multiple of ^GRID um
  OFFGRID LMARK 5
}
G.1.RHRIDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID RHRIDMY 5
}
G.1.VARDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID VARDMY 5
}
G.1.LOGO { @ grid must be an integer multiple of ^GRID um
  OFFGRID LOGO 5
}
G.1.INDDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID INDDMY 5
}
G.1.CBMi { @ grid must be an integer multiple of ^GRID um
  OFFGRID CBMi 5
}
G.1.CDUDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID CDUDMY 5
}
G.1.EXCLi { @ grid must be an integer multiple of ^GRID um
  OFFGRID EXCLi 5
}
G.1.IO_buffer { @ grid must be an integer multiple of ^GRID um
  OFFGRID IO_buffer 5
}
G.1.DMSRMi { @ grid must be an integer multiple of ^GRID um
  OFFGRID DMSRMi 5
}
G.1.HVTSRM { @ grid must be an integer multiple of ^GRID um
  OFFGRID HVTSRM 5
}
G.1.SRAMDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID SRAMDMY 5
}
G.1.RRuleRequired { @ grid must be an integer multiple of ^GRID um
  OFFGRID RRuleRequired 5
}
G.1.RRuleRecommended { @ grid must be an integer multiple of ^GRID um
  OFFGRID RRuleRecommended 5
}
G.1.RRuleAnalog { @ grid must be an integer multiple of ^GRID um
  OFFGRID RRuleAnalog 5
}
G.1.RFDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID RFDMY 5
}
G.1.BJTDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID BJTDMY 5
}
G.1.DIODMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID DIODMY 5
}
G.1.CTMDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID CTMDMY 5
}
G.1.M1x { @ M1x grid must be an integer multiple of ^GRID um.
  OFFGRID M1x 5
}
G.1.M2x { @ M2x grid must be an integer multiple of ^GRID um.
  OFFGRID M2x 5
}
G.1.M3x { @ M3x grid must be an integer multiple of ^GRID um.
  OFFGRID M3x 5
}
G.1.M4x { @ M4x grid must be an integer multiple of ^GRID um.
  OFFGRID M4x 5
}
G.1.M5x { @ M5x grid must be an integer multiple of ^GRID um.
  OFFGRID M5x 5
}
G.1.M6x { @ M6x grid must be an integer multiple of ^GRID um.
  OFFGRID M6x 5
}
G.1.M7x { @ M7x grid must be an integer multiple of ^GRID um.
  OFFGRID M7x 5
}
G.1.M8x { @ M8x grid must be an integer multiple of ^GRID um.
  OFFGRID M8x 5
}
G.1.M9x { @ M9x grid must be an integer multiple of ^GRID um.
  OFFGRID M9x 5
}
G.1.MDx { @ MDx grid must be an integer multiple of ^GRID um.
  OFFGRID MDx 5
}


G.2.DNWELLi { @ DNWELLi shapes with acute angles between line segments are not allowed.
  INT DNWELLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DNWELLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NWELLi { @ NWELLi shapes with acute angles between line segments are not allowed.
  INT NWELLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWELLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NWi_OTHERS { @ NWi_OTHERS shapes with acute angles between line segments are not allowed.
  INT NWi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODi { @ ODi shapes with acute angles between line segments are not allowed.
  INT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODi_RFDRAIN { @ ODi_RFDRAIN shapes with acute angles between line segments are not allowed.
  INT ODi_RFDRAIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi_RFDRAIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODi_OTHERS { @ ODi_OTHERS shapes with acute angles between line segments are not allowed.
  INT ODi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DOD { @ DOD shapes with acute angles between line segments are not allowed.
  INT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODBLK { @ ODBLK shapes with acute angles between line segments are not allowed.
  INT ODBLK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODBLK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD2i { @ OD2i shapes with acute angles between line segments are not allowed.
  INT OD2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POLYGi { @ POLYGi shapes with acute angles between line segments are not allowed.
  INT POLYGi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POLYGi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DPO { @ DPO shapes with acute angles between line segments are not allowed.
  INT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POi_OTHERS { @ POi_OTHERS shapes with acute angles between line segments are not allowed.
  INT POi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POBLK { @ POBLK shapes with acute angles between line segments are not allowed.
  INT POBLK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POBLK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PIMPi { @ PIMPi shapes with acute angles between line segments are not allowed.
  INT PIMPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PIMPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NIMPi { @ NIMPi shapes with acute angles between line segments are not allowed.
  INT NIMPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NIMPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CONTi { @ CONTi shapes with acute angles between line segments are not allowed.
  INT CONTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CONTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL1i { @ METAL1i shapes with acute angles between line segments are not allowed.
  INT METAL1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M1SLOTi { @ M1SLOTi shapes with acute angles between line segments are not allowed.
  INT M1SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM1 { @ DUM1 shapes with acute angles between line segments are not allowed.
  INT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM1EXCL { @ DM1EXCL shapes with acute angles between line segments are not allowed.
  INT DM1EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM1EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL2i { @ METAL2i shapes with acute angles between line segments are not allowed.
  INT METAL2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M2SLOTi { @ M2SLOTi shapes with acute angles between line segments are not allowed.
  INT M2SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM2 { @ DUM2 shapes with acute angles between line segments are not allowed.
  INT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM2EXCL { @ DM2EXCL shapes with acute angles between line segments are not allowed.
  INT DM2EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM2EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL3i { @ METAL3i shapes with acute angles between line segments are not allowed.
  INT METAL3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M3SLOTi { @ M3SLOTi shapes with acute angles between line segments are not allowed.
  INT M3SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM3 { @ DUM3 shapes with acute angles between line segments are not allowed.
  INT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM3EXCL { @ DM3EXCL shapes with acute angles between line segments are not allowed.
  INT DM3EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM3EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL4i { @ METAL4i shapes with acute angles between line segments are not allowed.
  INT METAL4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M4SLOTi { @ M4SLOTi shapes with acute angles between line segments are not allowed.
  INT M4SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM4 { @ DUM4 shapes with acute angles between line segments are not allowed.
  INT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM4EXCL { @ DM4EXCL shapes with acute angles between line segments are not allowed.
  INT DM4EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM4EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL5i { @ METAL5i shapes with acute angles between line segments are not allowed.
  INT METAL5i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL5i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M5SLOTi { @ M5SLOTi shapes with acute angles between line segments are not allowed.
  INT M5SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM5 { @ DUM5 shapes with acute angles between line segments are not allowed.
  INT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM5EXCL { @ DM5EXCL shapes with acute angles between line segments are not allowed.
  INT DM5EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM5EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL6i { @ METAL6i shapes with acute angles between line segments are not allowed.
  INT METAL6i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL6i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M6SLOTi { @ M6SLOTi shapes with acute angles between line segments are not allowed.
  INT M6SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM6 { @ DUM6 shapes with acute angles between line segments are not allowed.
  INT DUM6 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM6EXCL { @ DM6EXCL shapes with acute angles between line segments are not allowed.
  INT DM6EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM6EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL7i { @ METAL7i shapes with acute angles between line segments are not allowed.
  INT METAL7i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL7i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M7SLOTi { @ M7SLOTi shapes with acute angles between line segments are not allowed.
  INT M7SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM7 { @ DUM7 shapes with acute angles between line segments are not allowed.
  INT DUM7 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM7 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM7EXCL { @ DM7EXCL shapes with acute angles between line segments are not allowed.
  INT DM7EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM7EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL8i { @ METAL8i shapes with acute angles between line segments are not allowed.
  INT METAL8i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL8i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M8SLOTi { @ M8SLOTi shapes with acute angles between line segments are not allowed.
  INT M8SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M8SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM8 { @ DUM8 shapes with acute angles between line segments are not allowed.
  INT DUM8 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM8 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM8EXCL { @ DM8EXCL shapes with acute angles between line segments are not allowed.
  INT DM8EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM8EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL9i { @ METAL9i shapes with acute angles between line segments are not allowed.
  INT METAL9i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL9i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M9SLOTi { @ M9SLOTi shapes with acute angles between line segments are not allowed.
  INT M9SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M9SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM9 { @ DUM9 shapes with acute angles between line segments are not allowed.
  INT DUM9 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM9 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM9EXCL { @ DM9EXCL shapes with acute angles between line segments are not allowed.
  INT DM9EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM9EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MDi { @ MDi shapes with acute angles between line segments are not allowed.
  INT MDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MDSLOTi { @ MDSLOTi shapes with acute angles between line segments are not allowed.
  INT MDSLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MDSLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUMD { @ DUMD shapes with acute angles between line segments are not allowed.
  INT DUMD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUMD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DMDEXCL { @ DMDEXCL shapes with acute angles between line segments are not allowed.
  INT DMDEXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DMDEXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA12i { @ VIA12i shapes with acute angles between line segments are not allowed.
  INT VIA12i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA12i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA23i { @ VIA23i shapes with acute angles between line segments are not allowed.
  INT VIA23i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA23i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA34i { @ VIA34i shapes with acute angles between line segments are not allowed.
  INT VIA34i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA34i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA45i { @ VIA45i shapes with acute angles between line segments are not allowed.
  INT VIA45i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA45i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA56i { @ VIA56i shapes with acute angles between line segments are not allowed.
  INT VIA56i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA56i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA67i { @ VIA67i shapes with acute angles between line segments are not allowed.
  INT VIA67i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA67i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA78i { @ VIA78i shapes with acute angles between line segments are not allowed.
  INT VIA78i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA78i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA89i { @ VIA89i shapes with acute angles between line segments are not allowed.
  INT VIA89i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA89i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIADi { @ VIADi shapes with acute angles between line segments are not allowed.
  INT VIADi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIADi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RVi { @ RVi shapes with acute angles between line segments are not allowed.
  INT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.APi { @ APi shapes with acute angles between line segments are not allowed.
  INT APi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT APi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PADi { @ PADi shapes with acute angles between line segments are not allowed.
  INT PADi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PADi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CB2i { @ CB2i shapes with acute angles between line segments are not allowed.
  INT CB2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CB2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBDi { @ CBDi shapes with acute angles between line segments are not allowed.
  INT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.UBMi { @ UBMi shapes with acute angles between line segments are not allowed.
  INT UBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT UBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.WBDMY { @ WBDMY shapes with acute angles between line segments are not allowed.
  INT WBDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT WBDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RPOi { @ RPOi shapes with acute angles between line segments are not allowed.
  INT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NT_Ni { @ NT_Ni shapes with acute angles between line segments are not allowed.
  INT NT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTL_Ni { @ VTL_Ni shapes with acute angles between line segments are not allowed.
  INT VTL_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTL_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTL_Pi { @ VTL_Pi shapes with acute angles between line segments are not allowed.
  INT VTL_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTL_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTH_Ni { @ VTH_Ni shapes with acute angles between line segments are not allowed.
  INT VTH_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTH_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTH_Pi { @ VTH_Pi shapes with acute angles between line segments are not allowed.
  INT VTH_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTH_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LVIDi { @ LVIDi shapes with acute angles between line segments are not allowed.
  INT LVIDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LVIDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMi { @ CTMi shapes with acute angles between line segments are not allowed.
  INT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HRIi { @ HRIi shapes with acute angles between line segments are not allowed.
  INT HRIi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HRIi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.FWi { @ FWi shapes with acute angles between line segments are not allowed.
  INT FWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PLMIDEi { @ PLMIDEi shapes with acute angles between line segments are not allowed.
  INT PLMIDEi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PLMIDEi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SEALRING { @ SEALRING shapes with acute angles between line segments are not allowed.
  INT SEALRING < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRING < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CSRDMY { @ CSRDMY shapes with acute angles between line segments are not allowed.
  INT CSRDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CSRDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NWDMY { @ NWDMY shapes with acute angles between line segments are not allowed.
  INT NWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HOTWL { @ HOTWL shapes with acute angles between line segments are not allowed.
  INT HOTWL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HOTWL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RHDMY { @ RHDMY shapes with acute angles between line segments are not allowed.
  INT RHDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RHDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RPDMY { @ RPDMY shapes with acute angles between line segments are not allowed.
  INT RPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PMDMY { @ PMDMY shapes with acute angles between line segments are not allowed.
  INT PMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SDI { @ SDI shapes with acute angles between line segments are not allowed.
  INT SDI < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SDI < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD1DMY { @ ESD1DMY shapes with acute angles between line segments are not allowed.
  INT ESD1DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD1DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD2DMY { @ ESD2DMY shapes with acute angles between line segments are not allowed.
  INT ESD2DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD2DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD3DMY { @ ESD3DMY shapes with acute angles between line segments are not allowed.
  INT ESD3DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD3DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LMARK { @ LMARK shapes with acute angles between line segments are not allowed.
  INT LMARK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LMARK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RHRIDMY { @ RHRIDMY shapes with acute angles between line segments are not allowed.
  INT RHRIDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RHRIDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VARDMY { @ VARDMY shapes with acute angles between line segments are not allowed.
  INT VARDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VARDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LOGO { @ LOGO shapes with acute angles between line segments are not allowed.
  INT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.INDDMY { @ INDDMY shapes with acute angles between line segments are not allowed.
  INT INDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT INDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBMi { @ CBMi shapes with acute angles between line segments are not allowed.
  INT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CDUDMY { @ CDUDMY shapes with acute angles between line segments are not allowed.
  INT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.EXCLi { @ EXCLi shapes with acute angles between line segments are not allowed.
  INT EXCLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT EXCLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.IO_buffer { @ IO_buffer shapes with acute angles between line segments are not allowed.
  INT IO_buffer < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT IO_buffer < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DMSRMi { @ DMSRMi shapes with acute angles between line segments are not allowed.
  INT DMSRMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DMSRMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HVTSRM { @ HVTSRM shapes with acute angles between line segments are not allowed.
  INT HVTSRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVTSRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY { @ SRAMDMY shapes with acute angles between line segments are not allowed.
  INT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RRuleRequired { @ RRuleRequired shapes with acute angles between line segments are not allowed.
  INT RRuleRequired < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RRuleRequired < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RRuleRecommended { @ RRuleRecommended shapes with acute angles between line segments are not allowed.
  INT RRuleRecommended < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RRuleRecommended < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RRuleAnalog { @ RRuleAnalog shapes with acute angles between line segments are not allowed.
  INT RRuleAnalog < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RRuleAnalog < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RFDMY { @ RFDMY shapes with acute angles between line segments are not allowed.
  INT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.BJTDMY { @ BJTDMY shapes with acute angles between line segments are not allowed.
  INT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DIODMY { @ DIODMY shapes with acute angles between line segments are not allowed.
  INT DIODMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DIODMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMDMY { @ CTMDMY shapes with acute angles between line segments are not allowed.
  INT CTMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}


G.3.DNWELLi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DNWELLi >0 <90
  NOT ANGLE Y == 45
}
G.3.NWELLi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NWELLi >0 <90
  NOT ANGLE Y == 45
}
G.3.NWi_OTHERS { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NWi_OTHERS >0 <90
  NOT ANGLE Y == 45
}
G.3.ODi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ODi >0 <90
  NOT ANGLE Y == 45
}
G.3.ODi_RFDRAIN { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ODi_RFDRAIN >0 <90
  NOT ANGLE Y == 45
}
G.3.ODi_OTHERS { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ODi_OTHERS >0 <90
  NOT ANGLE Y == 45
}
G.3.DOD { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DOD >0 <90
  NOT ANGLE Y == 45
}
G.3.ODBLK { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ODBLK >0 <90
  NOT ANGLE Y == 45
}
G.3.OD2i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE OD2i >0 <90
  NOT ANGLE Y == 45
}
G.3.POLYGi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE POLYGi >0 <90
  NOT ANGLE Y == 45
}
G.3.DPO { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DPO >0 <90
  NOT ANGLE Y == 45
}
G.3.POi_OTHERS { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE POi_OTHERS >0 <90
  NOT ANGLE Y == 45
}
G.3.POBLK { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE POBLK >0 <90
  NOT ANGLE Y == 45
}
G.3.PIMPi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PIMPi >0 <90
  NOT ANGLE Y == 45
}
G.3.NIMPi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NIMPi >0 <90
  NOT ANGLE Y == 45
}
G.3.CONTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CONTi >0 <90
  NOT ANGLE Y == 45
}
G.3.M1SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M1SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM1 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM1 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM1EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM1EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M2SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M2SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM2 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM2 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM2EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM2EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M3SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M3SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM3 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM3 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM3EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM3EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M4SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M4SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM4 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM4 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM4EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM4EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M5SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M5SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM5 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM5 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM5EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM5EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M6SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M6SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM6 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM6 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM6EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM6EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M7SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M7SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM7 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM7 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM7EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM7EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M8SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M8SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM8 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM8 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM8EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM8EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M9SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M9SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM9 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM9 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM9EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM9EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.MDi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE MDi >0 <90
  NOT ANGLE Y == 45
}
G.3.MDSLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE MDSLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUMD { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUMD >0 <90
  NOT ANGLE Y == 45
}
G.3.DMDEXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DMDEXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA12i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA12i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA23i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA23i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA34i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA34i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA45i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA45i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA56i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA56i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA67i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA67i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA78i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA78i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA89i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA89i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIADi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIADi >0 <90
  NOT ANGLE Y == 45
}
G.3.RVi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RVi >0 <90
  NOT ANGLE Y == 45
}
G.3.APi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE APi >0 <90
  NOT ANGLE Y == 45
}
G.3.PADi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PADi >0 <90
  NOT ANGLE Y == 45
}
G.3.CB2i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CB2i >0 <90
  NOT ANGLE Y == 45
}
G.3.CBDi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CBDi >0 <90
  NOT ANGLE Y == 45
}
G.3.UBMi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE UBMi >0 <90
  NOT ANGLE Y == 45
}
G.3.WBDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE WBDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.RPOi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RPOi >0 <90
  NOT ANGLE Y == 45
}
G.3.NT_Ni { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NT_Ni >0 <90
  NOT ANGLE Y == 45
}
G.3.VTL_Ni { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VTL_Ni >0 <90
  NOT ANGLE Y == 45
}
G.3.VTL_Pi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VTL_Pi >0 <90
  NOT ANGLE Y == 45
}
G.3.VTH_Ni { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VTH_Ni >0 <90
  NOT ANGLE Y == 45
}
G.3.VTH_Pi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VTH_Pi >0 <90
  NOT ANGLE Y == 45
}
G.3.LVIDi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE LVIDi >0 <90
  NOT ANGLE Y == 45
}
G.3.CTMi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CTMi >0 <90
  NOT ANGLE Y == 45
}
G.3.HRIi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE HRIi >0 <90
  NOT ANGLE Y == 45
}
G.3.FWi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE FWi >0 <90
  NOT ANGLE Y == 45
}
G.3.PLMIDEi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PLMIDEi >0 <90
  NOT ANGLE Y == 45
}
G.3.SEALRING { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE SEALRING >0 <90
  NOT ANGLE Y == 45
}
G.3.CSRDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CSRDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.NWDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NWDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.HOTWL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE HOTWL >0 <90
  NOT ANGLE Y == 45
}
G.3.RHDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RHDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.RPDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RPDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.PMDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PMDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.SDI { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE SDI >0 <90
  NOT ANGLE Y == 45
}
G.3.ESD1DMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ESD1DMY >0 <90
  NOT ANGLE Y == 45
}
G.3.ESD2DMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ESD2DMY >0 <90
  NOT ANGLE Y == 45
}
G.3.ESD3DMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ESD3DMY >0 <90
  NOT ANGLE Y == 45
}
G.3.LMARK { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE LMARK >0 <90
  NOT ANGLE Y == 45
}
G.3.RHRIDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RHRIDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.VARDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VARDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.LOGO { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE LOGO >0 <90
  NOT ANGLE Y == 45
}
G.3.INDDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE INDDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.CBMi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CBMi >0 <90
  NOT ANGLE Y == 45
}
G.3.CDUDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CDUDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.EXCLi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE EXCLi >0 <90
  NOT ANGLE Y == 45
}
G.3.IO_buffer { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE IO_buffer >0 <90
  NOT ANGLE Y == 45
}
G.3.DMSRMi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DMSRMi >0 <90
  NOT ANGLE Y == 45
}
G.3.HVTSRM { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE HVTSRM >0 <90
  NOT ANGLE Y == 45
}
G.3.SRAMDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE SRAMDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.RRuleRequired { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RRuleRequired >0 <90
  NOT ANGLE Y == 45
}
G.3.RRuleRecommended { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RRuleRecommended >0 <90
  NOT ANGLE Y == 45
}
G.3.RRuleAnalog { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RRuleAnalog >0 <90
  NOT ANGLE Y == 45
}
G.3.RFDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RFDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.BJTDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE BJTDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.DIODMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DIODMY >0 <90
  NOT ANGLE Y == 45
}
G.3.CTMDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CTMDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.M1x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M1x >0 <90
  NOT ANGLE Y == 45
}
G.3.M2x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M2x >0 <90
  NOT ANGLE Y == 45
}
G.3.M3x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M3x >0 <90
  NOT ANGLE Y == 45
}
G.3.M4x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M4x >0 <90
  NOT ANGLE Y == 45
}
G.3.M5x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M5x >0 <90
  NOT ANGLE Y == 45
}
G.3.M6x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M6x >0 <90
  NOT ANGLE Y == 45
}
G.3.M7x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M7x >0 <90
  NOT ANGLE Y == 45
}
G.3.M8x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M8x >0 <90
  NOT ANGLE Y == 45
}
G.3.M9x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M9x >0 <90
  NOT ANGLE Y == 45
}


#IFDEF DATATYPE_WARNING
NW_DATATYPE.WARNING1 { @ It is strongly recommended to use NW;drawing (3;0) layer to define NW region 
    COPY NWi_OTHERS
}
OD_DATATYPE.WARNING1 { @ It is strongly recommended to use OD;drawing (6;0) layer to define OD region and OD;dummy (6;1) layer to defind DOD region.    
  COPY ODi_OTHERS
}
OD_DATATYPE.WARNING2 { @ RFMOS DRAIN OD (6;3) lvs dummy layer are only allowed in RFDMY region. 
   ODi_RFDRAIN NOT RFDMY
}
PO_DATATYPE.WARNING1 { @ It is strongly recommended to use PO;drawing (17;0) layer to define PO region and PO;dummy (17;1)layer to define DPO region. 
   COPY POi_OTHERS
}

#ENDIF


//NT_N CHECKS
//============
NTN_OD        = OD     AND NTN
NTN_PO        = POLY   AND NTN
NTN_GATE_W    = NTN_PO INSIDE EDGE NTN_OD
NTN_HV_GATE_W = NTN_GATE_W INSIDE EDGE OD2

NT_N.W.1 { @ Width >= 0.62 
  INT NTN < NT_N_W_1 ABUT < 90 SINGULAR REGION
}
NT_N.W.2 { @ Channel length of a 1.0V or 1.2V native device >= 0.30 
  INT NTN_GATE_W <  NT_N_W_2 ABUT < 90 REGION
}
NT_N.W.3 { @ Channel length of a 2.5V or 3.3V native device >= 1.20 
  INT NTN_HV_GATE_W < NT_N_W_3 ABUT < 90 REGION
}
NT_N.S.1 { @ Space >= 0.62 
  EXT NTN < NT_N_S_1 ABUT < 90 SINGULAR REGION
}

NT_N.S.2 { @ Space to {Active outside NT_N} >= 0.38 
  EXT DACT NTN < NT_N_S_2 ABUT < 90 OVERLAP SINGULAR
}
NT_N.S.3 { @ Space to NW [overlap is not allowed] >= 1.20 
  EXT NTN NWELLi < NT_N_S_3 ABUT < 90 INSIDE ALSO SINGULAR
}

NT_N.EN.1 { @ Enclosure of N+OD (minimum = maximum) = 0.26 
  A = NTN INTERACT OD
  B = OD INTERACT NTN
  C = SIZE B BY NT_N_EN_1
  D = SIZE A BY -NT_N_EN_1
  A XOR C
  B XOR D
}
NT_N.EX.1 { @ PO extension on {OD inside NT_N} (PO endcap) >= 0.35 
  ENC NTN_OD POLY < NT_N_EX_1 ABUT < 90 SINGULAR
}
NT_N.R.1 { @ Overlap of DNW is not allowed.   
  NTN AND DNW
}
NT_N.R.2 { @ Only one OD is allowed in an NT_N (except for NMOS capacitors with same potential).   
  NTN ENCLOSE OD > 1
}
NT_N.R.3 { @ P+OD is not allowed in an NT_N.   
  PPOD AND NTN
}



//VTL_N CHECKS
//============

VTL_N.W.1 { @ Width >= 0.31 
  INT VTLN < VTL_N_W_1 ABUT < 90 SINGULAR REGION
}
VTL_N.W.2 { @ Channel length of 1.2V low Vt NMOS >= 0.13 
  A = LV_NGATE_W INSIDE EDGE VTLN
  INT A < VTL_N_W_2 ABUT < 90 REGION
}
VTL_N.S.1 { @ Space >= 0.31 
  EXT VTLN < VTL_N_S_1 ABUT < 90 SINGULAR REGION
}
VTL_N.S.2 { @ Space to GATE in poly endcap direction >= 0.18 
  A = GATE NOT INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTL_N_S_3 - VTL_N_S_2)) OR A
  C = SIZE B BY VTL_N_S_2
  VTLN AND C
}

// VTL_N.S.3 is checked by VTL_N.S.2

VTL_N.EX.1 { @ Extension on GATE in poly endcap direction >= 0.18 
  A = GATE INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTL_N_EX_2 - VTL_N_EX_1)) OR A
  C = SIZE B BY VTL_N_EX_1
  C NOT VTLN
}

// VTL_N.EX.2 is checked by VTL_N.EX.1

VTL_N.R.1 { @ Overlap of {NW OR NT_N} is not allowed.   
  VTLN AND NWEL
  VTLN AND NTN
}

//VTL_P CHECKS
//============

VTL_P.W.1 { @ Width >= 0.31 
  INT VTLP < VTL_P_W_1 ABUT < 90 SINGULAR REGION
}
VTL_P.W.2 { @ Channel length of 1.2V low Vt PMOS >= 0.13 
  A = LV_PGATE_W INSIDE EDGE VTLP
  INT A < VTL_P_W_2 ABUT < 90 REGION
}
VTL_P.S.1 { @ Space >= 0.31 
  EXT VTLP < VTL_P_S_1 ABUT < 90 SINGULAR REGION
}
VTL_P.S.2 { @ Space to GATE in poly endcap direction >= 0.18 
  A = GATE NOT INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTL_P_S_3 - VTL_P_S_2)) OR A
  C = SIZE B BY VTL_P_S_2
  VTLP AND C
}

// VTL_P.S.3 is checked by VTL_P.S.2

VTL_P.EX.1 { @ Extension on GATE in poly endcap direction >= 0.18 
  A = GATE INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTL_P_EX_2 - VTL_P_EX_1)) OR A
  C = SIZE B BY VTL_P_EX_1
  C NOT VTLP
}

// VTL_P.EX.2 is checked by VTL_P.EX.1

VTL_P.R.1 { @ Overlap of {PW OR NT_N} is not allowed.   
  VTLP NOT NWEL
  VTLP AND NTN
}



// LVID CHECKS
//============

LOVT_GATE = LV_GATE INTERACT LVID

LVID.W.1 { @ Width >= 0.31 
   INT LVID < LVID_W_1 ABUT < 90 SINGULAR REGION 
}

LVID.S.1 { @ Space >= 0.31 
    EXT LVID < LVID_S_1 ABUT < 90 SINGULAR REGION 
}

LVID.S.2 { @ Space to GATE in poly endcap direction >= 0.4 
  A = GATE NOT INTERACT LVID
  X = A INSIDE EDGE POLY
  B = (EXPAND EDGE X OUTSIDE BY (LVID_S_2 - LVID_S_3)) OR A
  C = SIZE B BY LVID_S_3
  LVID AND C
}

// LVID.S.3 is checked by LVID.S.2

LVID.EX.1 { @ Extension on gate is S/D direction >= 0.27
    A = GATE INTERACT LVID
    X = A INSIDE EDGE OD
    ENC X LVID < LVID_EX_1 ABUT < 90 OPPOSITE REGION 
}

LVID.R.1 { @ LVID must fully cover {(((LVID and gate) SIZING 0.03) AND PO) SIZING 0.27}
  A = GATE INTERACT LVID
  X = A INSIDE EDGE POLY
  B = (EXPAND EDGE X OUTSIDE BY LVID_R_1_1) OR A
  C = SIZE B BY LVID_R_1_2
  C NOT LVID
}



//VTH_N CHECKS
//============

VTH_N.TITLE { @ Only core (1.0V, 1.2V) has high Vt devices.
  VTHN AND OD2
}  
VTH_N.W.1 { @ Width >= 0.31 
  INT VTHN < VTH_N_W_1 ABUT < 90 SINGULAR REGION
}
VTH_N.W.2 { @ Channel length of 1.0V or 1.2V high Vt NMOS >= 0.13 
  A = LV_NGATE_W INSIDE EDGE VTHN
  INT A < VTH_N_W_2 ABUT < 90 REGION
}
VTH_N.S.1 { @ Space >= 0.31 
  EXT VTHN < VTH_N_S_1 ABUT < 90 SINGULAR REGION
}
VTH_N.S.2 { @ Space to GATE in poly endcap direction >= 0.18 
  A = GATE NOT INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTH_N_S_3 - VTH_N_S_2)) OR A
  C = SIZE B BY VTH_N_S_2
  VTHN AND C
}

// VTH_N.S.3 is checked by VTH_N.S.2

VTH_N.EX.1 { @ Extension on GATE in poly endcap direction. >= 0.18 
  A = GATE INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTH_N_EX_2 - VTH_N_EX_1)) OR A
  C = SIZE B BY VTH_N_EX_1
  C NOT VTHN
}

// VTH_N.EX.2 is checked by VTH_N.EX.1

VTH_N.R.1 { @ Overlap of {NW OR NT_N} is not allowed.   
  VTHN AND NWEL
  VTHN AND NTN
}

//VTH_P CHECKS
//============

VTH_P.TITLE { @ Only core (1.0V, 1.2V) has high Vt devices.
  VTHP AND OD2
}  
VTH_P.W.1 { @ Width >= 0.31 
  INT VTHP < VTH_P_W_1 ABUT < 90 SINGULAR REGION
}
VTH_P.W.2 { @ Channel length of a 1.0V or 1.2V high Vt PMOS >= 0.13 
  A = LV_PGATE_W INSIDE EDGE VTHP
  INT A < VTH_P_W_2 ABUT < 90 REGION
}
VTH_P.S.1 { @ Space >= 0.31 
  EXT VTHP < VTH_P_S_1 ABUT < 90 SINGULAR REGION
}
VTH_P.S.2 { @ Space to GATE in poly endcap direction >= 0.18 
  A = GATE NOT INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTH_P_S_3 - VTH_P_S_2)) OR A
  C = SIZE B BY VTH_P_S_2
  VTHP AND C
}

// VTH_P.S.3 is checked by VTH_P.S.2

VTH_P.EX.1 { @ Extension on GATE in poly endcap direction >= 0.18 
  A = GATE INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTH_P_EX_2 - VTH_P_EX_1)) OR A
  C = SIZE B BY VTH_P_EX_1
  C NOT VTHP
}

// VTH_P.EX.2 is checked by VTH_P.EX.1

VTH_P.R.1 { @ Overlap of {PW OR NT_N} is not allowed.   
  VTHP NOT NWEL
  VTHP AND NTN
}


//OD CHECKS
//=========

#IFDEF CHECK_DENSITY_IN_ODBLK
OD_EXC = (((NWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY
#ELSE
OD_EXC = ((((NWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY) OR ODBLK
#ENDIF

#IFDEF FULL_CHIP
ODx = ALL_OD NOT EMPTY_AREA
CHIP_NOT_OD_EXC = COPY CHIP_CHAMFERED  
#ELSE
ODx = COPY ALL_OD 
CHIP_NOT_OD_EXC = COPY CHIP 
#ENDIF

OD.W.1 { @ Width [Active] >= 0.150 
  INT OD < OD_W_1 ABUT < 90 SINGULAR REGION
}

// OD.W.2 is checked by OD.W.1

OD.S.1 { @ Space >= 0.210 
  EXT OD < OD_S_1 ABUT < 90 SINGULAR REGION
}

// OD.S.2 is checked by PP.R.2

OD.S.3 { @ N+ACTIVE space to NW >= 0.310 
  A = NPOD NOT ODWR
  (EXT A NWELLi < OD_S_3 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
  ( A CUT NWELLi ) NOT INSIDE EXCL_SRM
}
OD.S.4 { @ PW STRAP space to NW >= 0.240 
  (EXT PPOD NWELLi < OD_S_4 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
  ( PPOD CUT NWELLi ) NOT INSIDE EXCL_SRM    
}
OD.S.5 { @ GATE space to Butted_STRAP [point projection]. Please also refer to NP.S.6/ PP.S.6 for related rules. >= 0.320 
  X = EXPAND EDGE GATEN_W OUTSIDE BY OD_S_5
  X TOUCH PSTP
  Y = EXPAND EDGE GATEP_W OUTSIDE BY OD_S_5
  Y TOUCH NSTP
}
OD.EN.1 { @ NW STRAP enclosure by NW >= 0.240 
  (ENC NPOD NONWR < OD_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
  ( NPOD CUT NONWR ) NOT INSIDE EXCL_SRM    
}
OD.EN.2 { @ P+ACTIVE enclosure by NW >= 0.310 
  (ENC PPOD NONWR < OD_EN_2 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
  ( PPOD CUT NONWR ) NOT INSIDE EXCL_SRM    
}
OD.A.1 { @ Area >= 0.122 
  AREA OD < OD_A_1
}
OD.A.2 { @ Enclosed area >= 0.150 
  HOLES OD < OD_A_2 INNER
}  

CHIPU_od25   = SIZE CHIP BY 25
CHIPU_od50   = SIZE CHIP BY 50
CHIPU_od75   = SIZE CHIP BY 75
CHIPU_od100   = SIZE CHIP BY 100
CHIPU_od125   = SIZE CHIP BY 125
CHIPU_od150   = SIZE CHIP BY 150
CHIPU_od175   = SIZE CHIP BY 175
CHIPU_od200   = SIZE CHIP BY 200
CHIPU_od225   = SIZE CHIP BY 225

OD.DN.1 { @ {OD OR DOD} local density (minimum) over window 500um x 500um stepping 250um >= 20%
  D0 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP PRINT OD_DN_1.density 
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D = RECTANGLE D0 == 500
  ERR1 = ( D0 NOT D ) NOT OD_EXC
  AREA ERR1 >= 62500
  D1 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od25
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D2 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od50
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D3 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od75
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D4 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od100
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D5 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od125
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D6 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od150
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D7 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od175
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D8 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od200
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D9 = DENSITY ODx CHIP_NOT_OD_EXC < OD_DN_1 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od225
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)  
  AREA ( ERR2 NOT OD_EXC ) >= 62500
}
OD.DN.2 { @ {OD OR DOD} local density (maximum) over window 500um x 500um stepping 250um <= 80% 
  D0 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP PRINT OD_DN_2.density 
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D = RECTANGLE D0 == 500
  ERR1 = ( D0 NOT D ) NOT OD_EXC
  AREA ERR1 >= 62500
  D1 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od25
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D2 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od50
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D3 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od75
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D4 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od100
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D5 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od125
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D6 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od150
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D7 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od175
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D8 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od200
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D9 = DENSITY ODx CHIP_NOT_OD_EXC > OD_DN_2 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od225
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  AREA ( ERR2 NOT OD_EXC ) >= 62500
}
#IFDEF FULL_CHIP
OD.DN.3 { @ {OD OR DOD} density across full chip (minimum) >= 25%
  DENSITY ALL_OD < OD_DN_3 PRINT OD_DN_3.density
}
OD.DN.4 { @ {OD OR DOD} density across full chip (maximum) <= 75%
  DENSITY ALL_OD > OD_DN_4 PRINT OD_DN_4.density
}  
#ENDIF
OD.R.1 { @ Width (J) of at least one segment of boundary between ACTIVE and Butted STRAP >= 0.30
	@ When J<0.3um, length (T) of {ACTIVE (source) interact with Butted_STRAP}. <= 0.60
  BUTT_EDGE = SD COIN OUTSIDE EDGE DSTP
  BUTT_LONG_EDGE = LENGTH BUTT_EDGE >= OD_R_1_W
  BUTT_EXP = (EXPAND EDGE BUTT_EDGE INSIDE BY 0.005 EXTEND BY 0.005) AND SD
  BUTT_EXP_SHORT = BUTT_EXP NOT WITH EDGE BUTT_LONG_EDGE
  CHECK_SD = SD INTERACT BUTT_EXP_SHORT
  CHECK_EDGE = (CHECK_SD OUTSIDE EDGE GATE) OUTSIDE EDGE DSTP
  CHECK_EDGE_LONG = PATH LENGTH CHECK_EDGE > OD_R_1_L
  NARROW_SD1 = INT CHECK_EDGE_LONG < OD_R_1_W ABUT < 90 OPPOSITE REGION
  NARROW_SD2 = NARROW_SD1 INTERACT BUTT_EXP_SHORT
  NARROW_SD3 = ((SIZE (NARROW_SD1 OUTSIDE NARROW_SD2) BY 0.001) AND SD) INTERACT NARROW_SD2
  NARROW_SD = NARROW_SD2 OR NARROW_SD3
  NARROW_SD_EDGE = NARROW_SD COIN INSIDE EDGE OD
  PATH LENGTH NARROW_SD_EDGE > OD_R_1_L
}
OD.R.2 { @ OD must be fully covered by N+/P+ except for DOD
  (((OD NOT ODWR) NOT LOGO) NOT CDUDMY) NOT IMP
}


//OD2 CHECKS
//==========

OD2.W.1 { @ Width >= 0.62 
  INT OD2 < OD2_W_1 ABUT < 90 SINGULAR REGION
}

OD2.S.1 { @ Space >= 0.86 
  EXT OD2 < OD2_S_1 ABUT < 90 SINGULAR REGION
}
OD2.S.2 { @ Space to ACTIVE >= 0.27 
  EXT OD2 DACT < OD2_S_2 ABUT < 90 SINGULAR REGION
}
OD2.S.3 { @ Space to 1.0V or 1.2V GATE >= 0.34 
   A = OD2 INSIDE EDGE OD
   EXT A GATE_W < OD2_S_3 ABUT < 90 REGION
}
OD2.S.4 { @ Space to NW. Space = 0 is allowed. >= 0.62 
  EXT OD2 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EN.1 { @ Enclosure of 2.5V or 3.3v gate in S/D direction.
  ENC GATE_W OD2 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
  GATE CUT OD2
}
OD2.EX.1 { @ Extension on { Active OR Gate } >= 0.27
   DACTG = DACT OR GATE 
   CHECK_EDGE = ENC [DACTG] OD2 < OD2_EX_1 ABUT < 90 SINGULAR
   CHECK_EDGE NOT COIN OUTSIDE EDGE DSTP
   OD2 INSIDE DACT
}
OD2.EX.2 { @ NW extension on OD2. Extension = 0 is allowed. >= 0.62 
  ENC OD2 NWEL < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.3 { @ Extension on NW. Extension = 0 is allowed. >= 0.62 
  ENC NWEL OD2 < OD2_EX_3 ABUT < 90 > 0 SINGULAR REGION
}
OD2.O.1 { @ Overlap of NW. Overlap = 0 is allowed. >= 0.62 
  X = OD2 AND NWEL
  INT X < OD2_O_1 ABUT < 90 SINGULAR REGION
}


//PO CHECKS
//=========

POLY_EDGE_45 = POLY ANGLE == 45
POLY_EDGE_45L = LENGTH POLY_EDGE_45 >= PO_W_4_L

// PO.W.1_1.0V_1.2V_1.5V is checked by PO.W.3
// PO.W.2_1.0V_1.2V_1.5V is checked by PO.W.3

#IFDEF 1.8V
PO.W.1_1.8V { @ Channel length of 1.8V PMOS	>=	0.18 
  INT HV_PGATE_W < PO_W_1_18v ABUT < 90 REGION
}
PO.W.2_1.8V { @ Channel length of 1.8V NMOS	>=	0.18 
  INT HV_NGATE_W < PO_W_2_18v ABUT < 90 REGION
}
#ENDIF

#IFDEF 2.5V
PO.W.1_2.5V { @ Channel length of 2.5V PMOS	>=	0.28 
  INT HV_PGATE_W < PO_W_1_25v ABUT < 90 REGION
}
PO.W.2_2.5V { @ Channel length of 2.5V NMOS	>=	0.28 
  INT HV_NGATE_W < PO_W_2_25v ABUT < 90 REGION
}
#ENDIF

#IFDEF 3.3V
PO.W.1_3.3V { @ Channel length of 3.3V PMOS	>=	0.30 
  INT HV_PGATE_W < PO_W_1_33v ABUT < 90 REGION
}
PO.W.2_3.3V { @ Channel length of 3.3V NMOS	>=	0.35 
  INT HV_NGATE_W < PO_W_2_33v ABUT < 90 REGION
}
#ENDIF

PO.W.3 { @ Width [interconnect] >= 0.13 
  INT POLY < PO_W_3 ABUT < 90 SINGULAR REGION
}
PO.W.4 { @ Width of 45-degree FIELD PO [for length >= 0.39] >= 0.16 
  INT POLY_EDGE_45L < PO_W_4 ABUT < 90 REGION
}
PO.S.1 { @ Space >= 0.18 
  EXT POLY < PO_S_1 ABUT < 90 SINGULAR REGION
}
PO.S.2 { @ GATE space in the same OD >= 0.18 
  EXT LV_GATE < PO_S_2 ABUT < 90 SINGULAR REGION
}
PO.S.3 { @ {GATE inside OD2} space in the same OD >= 0.25 
    EXT HV_GATE_W < PO_S_3 ABUT < 90 REGION 
    EXT HV_GATE < PO_S_3 ABUT < 90 CORNER TO CORNER	
}
PO.S.4 { @ FIELD PO space to OD >= 0.07 
  EXT POLY OD < PO_S_4 ABUT < 89.5 SINGULAR REGION
}
PO.EX.1 { @ Extension on OD (endcap) Poly endcap must contain a rectangular area where width = the width of the poly gate, and length >= 0.18 um. PO.S.4, FIELD PO space to OD, will be automatic. >= 0.18 
  ENC OD POLY < PO_EX_1 ABUT < 89.5 SINGULAR REGION
}
PO.EX.2 { @ OD extension on PO >= 0.23 
  ENC POLY OD < PO_EX_2 ABUT < 89.5 OPPOSITE SINGULAR REGION
}
PO.A.1 { @ Area >= 0.09 
  AREA POLY < PO_A_1
}
PO.A.2 { @ Enclosed area >= 0.15 
  HOLES POLY < PO_A_2 INNER
}  

#IFDEF FULL_CHIP
PO_DENSITY = DENSITY ALL_POLY < 0.14 PRINT PO_DN_1.density

PO.DN.1 { @ {PO OR DPO} density across full chip 14%  
  COPY PO_DENSITY
}
#ENDIF
PO.R.1 { @ The gate must be a rectangle orthogonal to the grid. (A bent gate is not allowed).   
  NORM_GATE_W = GATE_W OUTSIDE EDGE VARDMY
  EXT GATE_W < PO_W_3 ABUT == 135 INTERSECTING ONLY
  INT GATE_W < PO_W_3 ABUT == 135 INTERSECTING ONLY
  EXT NORM_GATE_W < PO_W_3 ABUT == 90 INTERSECTING ONLY
  INT NORM_GATE_W < PO_W_3 ABUT == 90 INTERSECTING ONLY
}

// PO.R.2 is not able to check

PO.R.3 { @ PO intersecting OD must form two or more diffusions except LOGO.   
  GATEW = GATE INSIDE EDGE OD
  X = GATE NOT WITH EDGE GATEW == 2
  X NOT LOGO
}  




//NP CHECKS
//=========

NP_BEDGE = NP INSIDE EDGE OD   // NP edge to form/abut butted tap

NP.W.1 { @ Width >= 0.31 
  (INT NP < NP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NP.S.1 { @ Space >= 0.31 
  (EXT NP < NP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NP.S.2 { @ Space to P+ACTIVE (non-butted) >= 0.18 
  (EXT NP PACT < NP_S_2 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  ( NP AND PACT ) NOT INSIDE EXCL_SRM    
  X = EXT NP [PACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE EXCL_SRM
}
NP.S.3 { @ Space to PW STRAP (non-butted) >= 0.03 
  (EXT NP PSTP < NP_S_3 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  ( NP AND PSTP ) NOT INSIDE EXCL_SRM    
  X = EXT NP [PSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE EXCL_SRM
}
NP.S.4 { @ {NP edge on OD} space to PMOS GATE >= 0.40 
  (EXT GATEP_W NP_BEDGE < NP_S_4 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXCL_SRM
}

// NP.S.5 is checked by PP.R.2
// NP.S.6 is checked by PP.R.1/PP.R.2
ODPO_RES_unsi = ODPO_RES INTERACT RPO
NP.S.7 { @ Space to P type unsilicided PO/OD >= 0.20 
  PYRE = ODPO_RES_unsi AND PP 		// P-type PO and OD resistor
  (EXT PYRE NP < NP_S_7 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}

// NP.EN.1 is checked by PP.EN.1

NP.EN.2 { @ Enclosure of NW STRAP >= 0.03 
  (ENC NSTP NP < NP_EN_2 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = ENC [NSTP] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE EXCL_SRM
}
NP.EX.1 { @ Extension on N+ACTIVE >= 0.18 
  A = NACT NOT ODWR
  (ENC A NP < NP_EX_1 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = ENC [A] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE EXCL_SRM
}

// NP.EX.2 is checked by NP.EN.2/PP.R.2

NP.EX.3 { @ Extension on N type unsilicided PO/OD >= 0.20 
  (ENC ODPO_RES_unsi NP < NP_EX_3 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NP.EX.4 { @ {NP edge on OD} extension on NMOS GATE >= 0.40 
  (ENC GATEN_W NP_BEDGE < NP_EX_4 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXCL_SRM
}
NP.O.1 { @ Overlap of OD >= 0.18 
  (INT OD NP < NP_O_1 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NP.A.1 { @ Area >= 0.25 
  AREA NP < NP_A_1
}
NP.A.2 { @ Enclosed area >= 0.25 
  (HOLES NP < NP_A_2 INNER) NOT INSIDE EXCL_SRM
}  
NP.R.1 { @ NP must fully cover {((NMOS GATE SIZING 0.03) AND PO) SIZING 0.27}.   
  EXGATE_NP = SIZE ((SIZE GATE_NP BY NP_R_1_1) AND POLY) BY NP_R_1
  (EXGATE_NP NOT NP) NOT INSIDE EXCL_SRM
}

// NP.R.2 is checked by PP.R.2


//PP CHECKS
//=========

// Expand edges outward from OD and extended side to side to form a rectangle.

PP_BEDGE = PP INSIDE EDGE OD   // PP edge to form/abut butted tap
SR_EXC   = EXT SR_EDGE < 75 ABUT == 90 REGION INTERSECTING ONLY
PP_CORE  = ((PP NOT CSRDMY) NOT SR_EXC) NOT SR_EDGE

PP.W.1 { @ Width >= 0.31 
  (INT PP < PP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.S.1 { @ Space >= 0.31 
  (EXT PP < PP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.S.2 { @ Space to N+ACTIVE (non-butted) >= 0.18 
  (EXT PP NACT < PP_S_2 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  ( PP AND NACT ) NOT INSIDE EXCL_SRM    
  X = EXT PP [NACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE EXCL_SRM
}
PP.S.3 { @ Space to NW STRAP (non-butted) >= 0.03 
  (EXT PP NSTP < PP_S_3 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  ( PP AND NSTP ) NOT INSIDE EXCL_SRM    
  X = EXT PP [NSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE EXCL_SRM
}
PP.S.4 { @ {PP edge on OD} space to NMOS GATE >= 0.40 
  (EXT GATEN_W PP_BEDGE < PP_S_4 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXCL_SRM
}

// PP.S.5 is checked by PP.R.2
// PP.S.6 is checked by NP.R.1/PP.R.2

PP.S.7 { @ Space to N type unsilicided PO/OD >= 0.20 
  NYRE = ODPO_RES_unsi AND NP 		// N-type PO and OD resistor
  (EXT NYRE PP < PP_S_7 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.EN.1 { @ {NP OR PP} enclosure of PO (except DPO and LOGO) >= 0.20 
  ILP_NOT_LOGO = ( POLY NOT LOGO) NOT CDUDMY
  (ENC ILP_NOT_LOGO IMP < PP_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
  (ILP_NOT_LOGO NOT IMP) NOT INSIDE EXCL_SRM 
}
PP.EN.2 { @ Enclosure of PW STRAP >= 0.03 
  (ENC PSTP PP_CORE < PP_EN_2 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = ENC [PSTP] PP_CORE < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE EXCL_SRM
}
PP.EX.1 { @ Extension on P+ACTIVE >= 0.18 
  IMP1 = NP OR PP_CORE
  (ENC PACT PP_CORE < PP_EX_1 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = ENC [PACT] PP_CORE < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE EXCL_SRM
  OD COIN INSIDE EDGE IMP1 
  // IMP cannot coincident OD except butting diffusion edge. PP.EX.1,PP.EN.2/NP.EX.1,NP.EN.2
}

// PP.EX.2 is checked by PP.EN.2/PP.R.2

PP.EX.3 { @ Extension on P type unsilicided PO/OD >= 0.20 
  (ENC ODPO_RES_unsi PP < PP_EX_3 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.EX.4 { @ {PP edge on OD} extension on PMOS GATE >= 0.40 
  (ENC GATEP_W PP_BEDGE < PP_EX_4 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXCL_SRM
}
PP.O.1 { @ Overlap of OD >= 0.18 
  (INT OD PP_CORE < PP_O_1  ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.A.1 { @ Area >= 0.25 
  AREA PP < PP_A_1
}
PP.A.2 { @ Enclosed area >= 0.25 
  (HOLES PP < PP_A_2 INNER) NOT INSIDE EXCL_SRM
}  
PP.R.1 { @ PP must fully cover {((PMOS GATE SIZING 0.03) AND PO) SIZING 0.27}.   
  EXGATE_PP = SIZE ((SIZE GATE_PP BY PP_R_1_1) AND POLY) BY PP_R_1
  (EXGATE_PP NOT PP) NOT INSIDE EXCL_SRM
}
PP.R.2 { @ Overlap of NP is not allowed.   
  (PP AND NP) NOT INSIDE EXCL_SRM
}


//LDN CHECKS
//==========

OD2D = SIZE OD2 BY -0.03
OD2U = SIZE OD2 BY 0.03

NP_NOT_NW = NP NOT NWEL
NLDDN1 = ((NP_NOT_NW NOT OD2D) NOT RHDMY) NOT VARDMY
NLDDN1V = SIZE (SIZE (SIZE NLDDN1 BY LD_SIZE2) BY -LD_SIZE1) BY LD_SIZE2
NLDDN2 = ((NP_NOT_NW AND OD2U) NOT RHDMY) NOT VARDMY
NLDDN2V = SIZE (SIZE (SIZE NLDDN2 BY LD_SIZE2) BY -LD_SIZE1) BY LD_SIZE2

PP_AND_NW = PP AND NWEL
PLDDP1 = ((PP_AND_NW NOT OD2D) NOT RHDMY) NOT VARDMY
PLDDP1V = SIZE (SIZE (SIZE PLDDP1 BY LD_SIZE2) BY -LD_SIZE1) BY LD_SIZE2
PLDDP2 = ((PP_AND_NW AND OD2U) NOT RHDMY) NOT VARDMY
PLDDP2V = SIZE (SIZE (SIZE PLDDP2 BY LD_SIZE2) BY -LD_SIZE1) BY LD_SIZE2

VTC_N = SIZE (SIZE (SIZE (DMSRMi NOT NWELLi) BY LD_SIZE4) BY -LD_SIZE3) BY LD_SIZE4
VTL_N_LD = SIZE (SIZE (SIZE ((OD2 OR NWEL) OR ( VTLN OR LVID )) BY LD_SIZE2) BY -LD_SIZE1) BY LD_SIZE2
VTL_P_LD = SIZE (SIZE (SIZE ((NWEL NOT OD2) NOT ( VTLP OR LVID )) BY LD_SIZE2) BY -LD_SIZE1) BY LD_SIZE2
CHIP_HVTSRM = CHIP INTERACT HVTSRM
VTHNx = VTHN INTERACT CHIP_HVTSRM
VTHPx = VTHP INTERACT CHIP_HVTSRM
VTH_N_LD = SIZE (SIZE (SIZE ((HVTSRM NOT NWEL) OR VTHNx) BY LD_SIZE2) BY -LD_SIZE1) BY LD_SIZE2
VTH_P_LD = SIZE (SIZE (SIZE ((HVTSRM AND NWEL) OR VTHPx) BY LD_SIZE2) BY -LD_SIZE1) BY LD_SIZE2

LDN.EX.1 { @ NP extension on OD2D >= 0.31 
  A = INT NLDDN1V < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN1V < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN1V < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN1V < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN1V < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN1V < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
LDN.O.1 { @ NP overlap of OD2U >= 0.31 
  A = INT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE1 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE1 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDN.EX.2 is checked by LDN.EX.1


//LDN GUIDELINES
//==============

// LDN.EX.3 is checked by LDN.EX.1
// LDN.EX.4 is checked by LDN.EX.1


//LDP CHECKS
//==========

LDP.EX.1 { @ PP extension on OD2D >= 0.31 
  A = INT PLDDP1V < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP1V < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP1V < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP1V < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP1V < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP1V < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
LDP.O.1 { @ PP overlap of OD2U >= 0.31 
  A = INT PLDDP2V < LDP_O_1 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP2V < LDP_O_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE1 LDP_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE1 LDP_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP2V < LDP_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP2V < LDP_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDP.O.2 is checked by LDP.EX.1


//LDP GUIDELINES
//==============

// LDP.EX.3 is checked by LDP.EX.1
// LDP.EX.4 is checked by LDP.EX.1


//VT CHECKS
//=========

#IFDEF GUIDELINE_LDD

VT.S.1 { @ OD2 space to VTL_N >= 0.31 
  A = INT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
  B = EXT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE1 VT_S_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE1 VT_S_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT VTL_N_LD < VT_S_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTL_N_LD < VT_S_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
//VT.S.1.1g and VT.S.2g are checked by VT.S.1 

// VT.S.2 is checked by VT.S.1
// VT.S.3 is checked by VT.EX.2

VT.S.4 { @ HVTSRM space to VTH_P >= 0.31 
  A = INT VTH_P_LD < VT_S_4 ABUT < 90 OPPOSITE REGION
  B = EXT VTH_P_LD < VT_S_4 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE1 VT_S_4 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE1 VT_S_4 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT VTH_P_LD < VT_S_4 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT VTH_P_LD < VT_S_4 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTH_P_LD < VT_S_4 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTH_P_LD < VT_S_4 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
VT.EX.1 { @ DMSRM extension on NW >= 0.31 
  A = INT VTC_N < VT_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT VTC_N < VT_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE3 VT_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE3 VT_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT VTC_N < VT_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT VTC_N < VT_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTC_N < VT_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTC_N < VT_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
VT.EX.2 { @ HVTSRM extension on NW >= 0.31 
  A = INT VTH_N_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
  B = EXT VTH_N_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE1 VT_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE1 VT_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT VTH_N_LD < VT_EX_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT VTH_N_LD < VT_EX_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTH_N_LD < VT_EX_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTH_N_LD < VT_EX_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
VT.EX.3 { @ NW extension on VTL_P >= 0.31 
  A = INT VTL_P_LD < VT_EX_3 ABUT < 90 OPPOSITE REGION
  B = EXT VTL_P_LD < VT_EX_3 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A LD_SIZE1 VT_EX_3 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B LD_SIZE1 VT_EX_3 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT VTL_P_LD < VT_EX_3 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT VTL_P_LD < VT_EX_3 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTL_P_LD < VT_EX_3 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTL_P_LD < VT_EX_3 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
//VT.EX.3.1g is checked by VT.EX.3
#ENDIF //end of GUIDELINE_LDD


//RPO CHECKS
//==========

NOGT  = (GATE NOT ESD1DMY) NOT ESD2DMY  // Normal gates
FPO1A = (FPO1 NOT ESD1DMY) NOT ESD2DMY

RPO.W.1 { @ Width >= 0.43 
  INT RPO < RPO_W_1 ABUT < 90 SINGULAR REGION
}
RPO.S.1 { @ Space >= 0.43 
  EXT RPO < RPO_S_1 ABUT < 90 SINGULAR REGION
}
RPO.S.2 { @ Space to OD >= 0.22 
  EXT RPO OD < RPO_S_2 ABUT < 90 SINGULAR
}
RPO.S.3 { @ Space to CO [overlap is not allowed] >= 0.22 
  EXT RPO CO < RPO_S_3 ABUT < 90 INSIDE ALSO SINGULAR
}
RPO.S.4 { @ Space to GATE [overlap is not allowed except ESD circuit] >= 0.38 
  RPO AND NOGT
  EXT RPO GATE < RPO_S_4 ABUT < 90 SINGULAR
}
RPO.S.5 { @ Space to PO >= 0.30 
  EXT RPO FPO1 < RPO_S_5 ABUT < 90 SINGULAR
}
RPO.EX.1 { @ Extension on unsilicided OD >= 0.22 
  ENC OD RPO < RPO_EX_1 ABUT < 90 SINGULAR
}
RPO.EX.2 { @ OD extension on RPO >= 0.22 
  ENC RPO OD < RPO_EX_2 ABUT < 90 SINGULAR
}
RPO.EX.3 { @ Extension on unsilicided PO >= 0.22 
  ENC FPO1A RPO < RPO_EX_3 ABUT < 90 SINGULAR
}
RPO.A.1 { @ Area >= 1.00 
  AREA RPO < RPO_A_1
}
RPO.R.1.PO { @ Butted NP/PP on unsilicided PO is not allowed.
    NX = RPO_PO AND NP
    PX = RPO_PO AND PP    
    Y  = NX INTERACT PX
    RPO_PO INTERACT Y
}  
RPO.R.1.OD { @ Butted NP/PP on unsilicided OD is not allowed.
    NX = RPO_OD AND NP
    PX = RPO_OD AND PP    
    Y  = NX INTERACT PX
    RPO_OD INTERACT Y
}  

RPO.A.2 { @ Enclosed Area >= 1.00  
  A = HOLES RPO INNER
  B = A NOT RPO
  AREA B < RPO_A_2
}

RES.9g.WARN { @ For unsilicided OD resistor, RHDMY overlap gate is not allow 
  RH_RES = RHDMY NOT OUTSIDE ODPO_RES
  RH_RES AND GATE
  GATE INSIDE RHDMY // RH can not fully cover GATE
}

#IFDEF GUIDELINE_RES

PORESg = PORES NOT INTERACT SDI

RES.2g.OD { @ Recommended width >= 1.0um and length >= 2.0um for unsilicided OD resistor
  INT ODRES < RES_2G_OD_W ABUT < 90 SINGULAR REGION
  RES_L = ODRES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < RES_2G_OD_L
  CHECK_RES = ODRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (RES_2G_OD_L/2 - GRID*2) INSIDE OF ODRES STEP OD_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
RES.2g.PO { @ Recommended width >= 1.0um and length >= 2.0um for unsilicided PO resistor
  INT PORESg < RES_2G_PO_W ABUT < 90 SINGULAR REGION
  RES_L = PORESg INSIDE EDGE RPO
  X = PATH LENGTH RES_L < RES_2G_PO_L
  CHECK_RES = PORESg WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (RES_2G_PO_L/2 - GRID*2) INSIDE OF PORESg STEP PO_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
RES.5g.OD { @ CO space to unsilicided OD resistor should be equal to 0.22um (RPO_S_3)
  ODR_TRM = SIZE ODRES BY RPO_S_3 INSIDE OF OD STEP OD_S_1*0.7
  ODR_TRM NOT INTERACT CO
}
RES.5g.PO { @ CO space to unsilicided PO resistor should be equal to 0.22um (RPO_S_3)
  POR_TRM = SIZE PORESg BY RPO_S_3 INSIDE OF POLY STEP PO_S_1*0.7
  POR_TRM NOT INTERACT CO
}
RES.9g { @ For unsilicided OD resistor in the s/d of MOS, RHDMY space to gate >= 0.4um
  RH_RES = RHDMY NOT OUTSIDE ODPO_RES
  EXT RH_RES GATE < RES_9G ABUT < 90 SINGULAR REGION
  RH_RES AND GATE
  GATE INSIDE RHDMY // RH can not fully cover GATE
}
RES.10g { @ For unsilicided OD resistor in the s/d of MOS, RHDMY extension on {RPO AND OD} >= 0.20um
  ODRES_SD = ODRES AND SD  
  ENC ODRES_SD RHDMY < RES_10G ABUT < 90 SINGULAR REGION
  ODRES_SD NOT RHDMY
}
#ENDIF



//VARDMY CHECKS
//==========

VAR_GATE = GATE NOT OUTSIDE VARDMY

VAR.W.1 { @  Width of {gate AND VARDMY}	>= 0.3
  X = GATE_W INSIDE EDGE VARDMY  
  INT X  < VAR_W_1 ABUT < 90 REGION
}
VAR.L.1 { @  Length of {gate AND VARDMY}	>= 0.5
  X = GATE_L INSIDE EDGE VARDMY  
  INT X  < VAR_L_1 ABUT < 90 REGION
}
VAR.S.1 { @ Space to Active >= 0.18
  EXT VARDMY DACT < VAR_S_1 ABUT < 90 SINGULAR REGION
}
VAR.EN.1 { @ Enclosure of OD	>= 0.30
  ENC OD VARDMY < VAR_EN_1 ABUT < 90 SINGULAR REGION
  OD CUT VARDMY
}
VAR.R.1 { @ VARDMY layer must be drawn to fully cover the varactor devices.
  VAR_GATE NOT VARDMY
}
VAR.R.2 { @ Overlap of VTL_N, VTL_P, VTH_N, VTH_P, NT_N,  PW, or RPO is not allowed.
  VARDMY AND VTLN
  VARDMY AND VTLP
  VARDMY AND VTHN
  VARDMY AND VTHP
  VARDMY AND NTN
  VARDMY NOT NWEL
  VARDMY AND RPO
}
VAR.R.3 { @ PP overlap of {gate AND VARDMY} is not allowed.
  VAR_GATE AND PP
}
VAR.R.4 { @ Overlap of {gate SIZING 0.30 um} is not allowed.
  VAR_E = SIZE VARDMY BY VAR_W_1 	// For filtering only
  VAR_EXG = (GATE INTERACT VAR_E) OUTSIDE VARDMY
  VAR_EXGS = SIZE VAR_EXG BY VAR_R_4
  VARDMY AND VAR_EXGS
}
VAR.R.5 { @ NP must fully cover {(((VARDMY AND GATE) sizing 0.22) AND OD) sizing 0.18}
  VAR_GATE_a = SIZE VAR_GATE BY VAR_R_5a  
  VAR_GATE_a_OD_b = SIZE (VAR_GATE_a AND OD) BY VAR_R_5b
  VAR_GATE_a_OD_b NOT NP
}



// M1 SIZE
//=========
M1Wide0.3 = (SIZE M1 BY 0.149 UNDEROVER TRUNCATE 0.149) AND M1
M1Wide1.4 = (SIZE M1Wide0.3 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M1Wide0.3
M1Wide7   = (SIZE M1Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M1Wide1.4

M2Wide0.4 = (SIZE M2 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M2
M2Wide1.4 = (SIZE M2Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M2Wide0.4
M2Wide7   = (SIZE M2Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M2Wide1.4

// M2 SIZE
//=========
M3Wide0.4 = (SIZE M3 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M3
M3Wide1.4 = (SIZE M3Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M3Wide0.4
M3Wide7   = (SIZE M3Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M3Wide1.4
// M3 SIZE
//=========
M4Wide0.4 = (SIZE M4 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M4
M4Wide1.4 = (SIZE M4Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M4Wide0.4
M4Wide7   = (SIZE M4Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M4Wide1.4
// M4 SIZE
//=========
M5Wide0.4 = (SIZE M5 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M5
M5Wide1.4 = (SIZE M5Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M5Wide0.4
M5Wide7   = (SIZE M5Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M5Wide1.4
// M5 SIZE
//=========
M6Wide0.4 = (SIZE M6 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M6
M6Wide1.4 = (SIZE M6Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M6Wide0.4
M6Wide7   = (SIZE M6Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M6Wide1.4
// M6 SIZE
//=========
M7Wide0.4 = (SIZE M7 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M7
M7Wide1.4 = (SIZE M7Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M7Wide0.4
M7Wide7   = (SIZE M7Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M7Wide1.4
// M7 SIZE
//=========
M8Wide0.4 = (SIZE M8 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M8
M8Wide1.4 = (SIZE M8Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M8Wide0.4
M8Wide7   = (SIZE M8Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M8Wide1.4
UBM_EXDD    = SIZE UBM BY 5 INSIDE OF MDx STEP 0.32 	// For RDL


//METAL1 SLOT CHECKS
//==================

M1EXD       = M1x NOT SLT_EXD

M1InnerHole = HOLES M1EXD INNER
M1BigHole   = SIZE M1InnerHole BY -5 	// Holes with width less than 10um will be filled back
M1Hole      = M1InnerHole OUTSIDE M1BigHole	
M1HoleSpace = M1Hole NOT M1EXD
FIM1c       = M1EXD OR M1HoleSpace
FIM1Y       = (SIZE (SIZE FIM1c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM1c  
LM1X        = ENCLOSE RECTANGLE FIM1Y MS_R_1_W MS_R_1_L
M1HoleD     = M1HoleSpace AND LM1X

MS.R.1.M1 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M1WideEXD = M1Wide7 NOT SLT_EXD
  X = (SIZE M1WideEXD BY MS_R_1_W_s UNDEROVER) AND M1WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M1HoleD LM1X

MS.DN.1.M1 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM1X M1HoleD < MS_DN_1
    [ AREA(M1HoleD) / AREA(LM1X) ] RDB M1Hole.density LM1X M1HoleD 
}

DISCONNECT

// MS.R.2.M1 is not able to check




//METAL2 SLOT CHECKS
//==================

M2EXD       = M2x NOT SLT_EXD

M2InnerHole = HOLES M2EXD INNER
M2BigHole   = SIZE M2InnerHole BY -5 	// Holes with width less than 10um will be filled back
M2Hole      = M2InnerHole OUTSIDE M2BigHole	
M2HoleSpace = M2Hole NOT M2EXD
FIM2c       = M2EXD OR M2HoleSpace
FIM2Y       = (SIZE (SIZE FIM2c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM2c  
LM2X        = ENCLOSE RECTANGLE FIM2Y MS_R_1_W MS_R_1_L
M2HoleD     = M2HoleSpace AND LM2X

MS.R.1.M2 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M2WideEXD = M2Wide7 NOT SLT_EXD
  X = (SIZE M2WideEXD BY MS_R_1_W_s UNDEROVER) AND M2WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M2HoleD LM2X

MS.DN.1.M2 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM2X M2HoleD < MS_DN_1
    [ AREA(M2HoleD) / AREA(LM2X) ] RDB M2Hole.density LM2X M2HoleD 
}

DISCONNECT

// MS.R.2.M2 is not able to check




//METAL3 SLOT CHECKS
//==================

M3EXD       = M3x NOT SLT_EXD

M3InnerHole = HOLES M3EXD INNER
M3BigHole   = SIZE M3InnerHole BY -5 	// Holes with width less than 10um will be filled back
M3Hole      = M3InnerHole OUTSIDE M3BigHole	
M3HoleSpace = M3Hole NOT M3EXD
FIM3c       = M3EXD OR M3HoleSpace
FIM3Y       = (SIZE (SIZE FIM3c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM3c  
LM3X        = ENCLOSE RECTANGLE FIM3Y MS_R_1_W MS_R_1_L
M3HoleD     = M3HoleSpace AND LM3X

MS.R.1.M3 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M3WideEXD = M3Wide7 NOT SLT_EXD
  X = (SIZE M3WideEXD BY MS_R_1_W_s UNDEROVER) AND M3WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M3HoleD LM3X

MS.DN.1.M3 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM3X M3HoleD < MS_DN_1
    [ AREA(M3HoleD) / AREA(LM3X) ] RDB M3Hole.density LM3X M3HoleD 
}

DISCONNECT

// MS.R.2.M3 is not able to check




//METAL4 SLOT CHECKS
//==================

M4EXD       = M4x NOT SLT_EXD

M4InnerHole = HOLES M4EXD INNER
M4BigHole   = SIZE M4InnerHole BY -5 	// Holes with width less than 10um will be filled back
M4Hole      = M4InnerHole OUTSIDE M4BigHole	
M4HoleSpace = M4Hole NOT M4EXD
FIM4c       = M4EXD OR M4HoleSpace
FIM4Y       = (SIZE (SIZE FIM4c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM4c  
LM4X        = ENCLOSE RECTANGLE FIM4Y MS_R_1_W MS_R_1_L
M4HoleD     = M4HoleSpace AND LM4X

MS.R.1.M4 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M4WideEXD = M4Wide7 NOT SLT_EXD
  X = (SIZE M4WideEXD BY MS_R_1_W_s UNDEROVER) AND M4WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M4HoleD LM4X

MS.DN.1.M4 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM4X M4HoleD < MS_DN_1
    [ AREA(M4HoleD) / AREA(LM4X) ] RDB M4Hole.density LM4X M4HoleD 
}

DISCONNECT

// MS.R.2.M4 is not able to check




//METAL5 SLOT CHECKS
//==================

M5EXD       = M5x NOT SLT_EXD

M5InnerHole = HOLES M5EXD INNER
M5BigHole   = SIZE M5InnerHole BY -5 	// Holes with width less than 10um will be filled back
M5Hole      = M5InnerHole OUTSIDE M5BigHole	
M5HoleSpace = M5Hole NOT M5EXD
FIM5c       = M5EXD OR M5HoleSpace
FIM5Y       = (SIZE (SIZE FIM5c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM5c  
LM5X        = ENCLOSE RECTANGLE FIM5Y MS_R_1_W MS_R_1_L
M5HoleD     = M5HoleSpace AND LM5X

MS.R.1.M5 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M5WideEXD = M5Wide7 NOT SLT_EXD
  X = (SIZE M5WideEXD BY MS_R_1_W_s UNDEROVER) AND M5WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M5HoleD LM5X

MS.DN.1.M5 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM5X M5HoleD < MS_DN_1
    [ AREA(M5HoleD) / AREA(LM5X) ] RDB M5Hole.density LM5X M5HoleD 
}

DISCONNECT

// MS.R.2.M5 is not able to check




//METAL6 SLOT CHECKS
//==================

M6EXD       = M6x NOT SLT_EXD

M6InnerHole = HOLES M6EXD INNER
M6BigHole   = SIZE M6InnerHole BY -5 	// Holes with width less than 10um will be filled back
M6Hole      = M6InnerHole OUTSIDE M6BigHole	
M6HoleSpace = M6Hole NOT M6EXD
FIM6c       = M6EXD OR M6HoleSpace
FIM6Y       = (SIZE (SIZE FIM6c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM6c  
LM6X        = ENCLOSE RECTANGLE FIM6Y MS_R_1_W MS_R_1_L
M6HoleD     = M6HoleSpace AND LM6X

MS.R.1.M6 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M6WideEXD = M6Wide7 NOT SLT_EXD
  X = (SIZE M6WideEXD BY MS_R_1_W_s UNDEROVER) AND M6WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M6HoleD LM6X

MS.DN.1.M6 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM6X M6HoleD < MS_DN_1
    [ AREA(M6HoleD) / AREA(LM6X) ] RDB M6Hole.density LM6X M6HoleD 
}

DISCONNECT

// MS.R.2.M6 is not able to check




//METAL7 SLOT CHECKS
//==================

M7EXD       = (M7x NOT SLT_EXD) NOT WBDMY

M7InnerHole = HOLES M7EXD INNER
M7BigHole   = SIZE M7InnerHole BY -5 	// Holes with width less than 10um will be filled back
M7Hole      = M7InnerHole OUTSIDE M7BigHole	
M7HoleSpace = M7Hole NOT M7EXD
FIM7c       = M7EXD OR M7HoleSpace
FIM7Y       = (SIZE (SIZE FIM7c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM7c  
LM7X        = ENCLOSE RECTANGLE FIM7Y MS_R_1_W MS_R_1_L
M7HoleD     = M7HoleSpace AND LM7X

MS.R.1.M7 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M7WideEXD = M7Wide7 NOT SLT_EXD
  X = (SIZE M7WideEXD BY MS_R_1_W_s UNDEROVER) AND M7WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M7HoleD LM7X

MS.DN.1.M7 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM7X M7HoleD < MS_DN_1
    [ AREA(M7HoleD) / AREA(LM7X) ] RDB M7Hole.density LM7X M7HoleD 
}

DISCONNECT

// MS.R.2.M7 is not able to check




//METAL8 SLOT CHECKS
//==================

// Bonding pad, chip corner dummy pad, and inductor need not put slot

PAD_EXD8    = SIZE PAD_EXD BY 5 INSIDE OF M8x STEP 0.32 
SLT_EXD8    = ((SLT_EXD OR PAD_EXD8) OR WBDMY ) OR INDDMY // For top metal only

M8EXD       = M8x NOT SLT_EXD8

M8InnerHole = HOLES M8EXD INNER
M8BigHole   = SIZE M8InnerHole BY -5 	// Holes with width less than 10um will be filled back
M8Hole      = M8InnerHole OUTSIDE M8BigHole	
M8HoleSpace = M8Hole NOT M8EXD
FIM8c       = M8EXD OR M8HoleSpace
FIM8Y       = (SIZE (SIZE FIM8c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM8c  
LM8X        = ENCLOSE RECTANGLE FIM8Y MS_R_1_W MS_R_1_L
M8HoleD     = M8HoleSpace AND LM8X

MS.R.1.M8 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M8WideEXD = M8Wide7 NOT SLT_EXD8
  X = (SIZE M8WideEXD BY MS_R_1_W_s UNDEROVER) AND M8WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M8HoleD LM8X

MS.DN.1.M8 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM8X M8HoleD < MS_DN_1
    [ AREA(M8HoleD) / AREA(LM8X) ] RDB M8Hole.density LM8X M8HoleD 
}

DISCONNECT

// MS.R.2.M8 is not able to check


//MD SLOT CHECKS
//==============

// Bonding pad, chip corner dummy pad, and inductor need not put slot

MDEXD       = MDx NOT ((LMARK OR CSRDMY) OR UBM_EXDD )
MDInnerHole = HOLES MDEXD INNER
MDBigHole   = SIZE MDInnerHole BY -5  	// Holes with width less than 10um will be filled back
MDHole      = MDInnerHole OUTSIDE MDBigHole	
MDHoleSpace = MDHole NOT MDEXD
FIMDc       = MDEXD OR MDHoleSpace
FIMDY       = (SIZE (SIZE FIMDc BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIMDc  
LMDX        = ENCLOSE RECTANGLE FIMDY MS_R_1_W MS_R_1_L
MDHoleD     = MDHoleSpace AND LMDX

MS.R.1.MD { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  X = (SIZE (SIZE MDEXD BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND MDEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT MDHoleD LMDX

MS.DN.1.MD { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LMDX MDHoleD < MS_DN_1
    [ AREA(MDHoleD) / AREA(LMDX) ] RDB MDHole.density LMDX MDHoleD 
}

DISCONNECT

// MS.R.2.MD is not able to check





//NW CHECKS
//=========


RWi = PWELi INSIDE DNWELLi

CONNECT NSTPi NWELLi    
CONNECT NSTPi PSDi
CONNECT PSTPi NSDi
CONNECT PSTPi RWi
CONNECT PSTPi PWELi 
CONNECT NWEL DNW
CONNECT M1x ILP1i NSTPi PSTPi PSDi NSDi BY CONTi
CONNECT M1x M2x BY VIA12i
CONNECT M2x M3x BY VIA23i
CONNECT M3x M4x BY VIA34i
CONNECT M4x M5x BY VIA45i
CONNECT M5x M6x BY VIA56i
CONNECT M6x M7x BY VIA67i
CONNECT M7x M8x BY VIA78i
CONNECT M8x MDx BY VIADi

#IFDEF SUGGESTED

NW1Vs = NWEL OUTSIDE OD2
NW2Vs = NWEL NOT OUTSIDE OD2

SUGGESTED.NW.S.3 { @ More conservative way to check NW.S.3 as DRC can not determine the
		   @ operating voltages of nwels.
  EXT NW1Vs NW2Vs < NW_S_3 ABUT < 90 > 0 SINGULAR
}
SUGGESTED.NW.S.4 { @ More conservative way to check NW.S.4 as DRC can not determine the
		   @ operating voltages of nwels.
  NW2V_NODALs = STAMP NW2Vs BY NWELLi
  EXT NW2V_NODALs < NW_S_4 ABUT < 90 SPACE NOT CONNECTED SINGULAR
}

#ENDIF

NW.W.1 { @ Width >= 0.620 
  (INT NWEL < NW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.S.1 { @ Space >= 0.620 
  (EXT NWEL < NW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.S.2 { @ Space of two NW1V with different potentials. [The maximum applied voltage = 1.2V.] >= 1.000 
  NW1V_NODAL = STAMP NW1V BY NWELLi
  (EXT NW1V_NODAL < NW_S_2 ABUT < 90 SPACE NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.S.3 { @ NW1V space to NW2V >= 1.200 
  (EXT NW1V NW2V < NW_S_3 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.S.4 { @ Space of two NW2V with different potentials. [1.2V < maximum applied voltage <= 2.5V (or 3.3V)] >= 1.200 
  NW2V_NODAL = STAMP NW2V BY NWELLi
  (EXT NW2V_NODAL < NW_S_4 ABUT < 90 SPACE NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.A.1 { @ Area >= 1.000 
  AREA NWEL < NW_A_1
}
NW.A.2 { @ Enclosed area >= 0.384 
  (HOLES NWEL < NW_A_2 INNER) NOT INSIDE EXCL_SRM
}  



//NW Resistor CHECKS
//==================

// For NW within OD (NWROD) resistor 

NWRES     = RNWEL   INTERACT RPO	// NW resistor (within OD)
NPWR      = NP      INTERACT NWRES	// N+ implant on NW resistor terminals
COWR      = COOD    INTERACT NWRES	// Contact on NW resistor terminals
RHWR      = ODWR    NOT RPO		// Silicided area of NW resistor    

NWROD.W.1 { @ Width >= 1.80 
  INT RNWEL < NWROD_W_1 ABUT < 90 SINGULAR REGION
}
NWROD.S.1 { @ Space to NWROD or to NW >= 1.20 
  EXT RNWEL < NWROD_S_1 ABUT < 90 NOTCH SINGULAR REGION
  EXT RNWEL NWEL < NWROD_S_1 ABUT < 90 SINGULAR
}
NWROD.S.2 { @ Space to RPO >= 0.30 
  EXT NWRES RPO < NWROD_S_2 ABUT < 90 SINGULAR
}
NWROD.EN.1 { @ Enclosure by OD >= 1.00 
  ENC NWRES ODWR < NWROD_EN_1 ABUT < 90 OVERLAP SINGULAR
}
NWROD.EN.2 { @ Enclosure of CO >= 0.30 
  ENC COWR NWRES < NWROD_EN_2 ABUT < 90 OVERLAP SINGULAR
}
NWROD.EX.1 { @ RPO extension on OD >= 0.22 
  ENC ODWR RPO < NWROD_EX_1 ABUT < 90 SINGULAR 
  (ODWR INTERACT RPO) OUTSIDE EDGE RPO
}
NWROD.O.1 { @ RPO overlap of NP >= 0.40 
  INT NPWR RPO < NWROD_O_1 ABUT < 90 SINGULAR REGION
  X = RPO INTERACT NWRES
  H = HOLES X INNER
  H NOT NPWR
}
NWROD.O.2 { @ {OD AND NWDMY} overlap of PP, NP, VTL_N, VTL_P, VTH_N or VTH_P is not allowed.   
  NWROD = NWDMY AND OD
  NWROD AND NP
  NWROD AND PP
  NWROD AND VTLN
  NWROD AND VTLP
  NWROD AND VTHN
  NWROD AND VTHP
}

NWROD.R.1 { @ {OD AND NWDMY} interact with DNW is not allowed   
   X = OD AND NWDMY
   X INTERACT DNW    
}
// For NW under STI (NWRSTI) resistor

NWRES_STI = RNWEL   NOT INTERACT RPO	// NW resistor (under STI)
ODWR_STI  = OD      INTERACT NWRES_STI
NPWR_STI  = NP      INTERACT NWRES_STI

// NWRSTI.W.1 is checked by NWROD.W.1
// NWRSTI.S.1 is checked by NWROD.S.1

NWRSTI.EN.3 { @ NP enclosure of OD >= 0.18 
  ENC ODWR_STI NPWR_STI < NWRSTI_EN_3 ABUT < 90 SINGULAR REGION
  ODWR_STI NOT NPWR_STI
}


//DNW CHECKS
//==========

DNW.W.1 { @ Width >= 3.00 
  (INT DNW < DNW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
DNW.S.1 { @ Space >= 5.00 
  (EXT DNW < DNW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
DNW.S.2 { @ Space to NW >= 3.50 
    (EXT DNW NWEL < DNW_S_2  ABUT <90 NOT CONNECTED SINGULAR REGION MEASURE ALL) NOT INSIDE EXCL_SRM
}

RW = PWEL INSIDE DNW
RW1V = RW NOT INTERACT OD2
RW2V = RW INTERACT OD2
RW1V_NODAL = STAMP RW1V BY RWi
RW2V_NODAL = STAMP RW2V BY RWi
PWEL_NODAL = STAMP PWEL BY PWELi


DNW.S.3 { @ RW space to {RW OR PW} with different potential >= 1.00 
  (EXT RW1V_NODAL < DNW_S_3 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
  (EXT RW1V_NODAL PWEL_NODAL < DNW_S_3 ABUT < 90 NOT CONNECTED SINGULAR REGION ) NOT INSIDE EXCL_SRM    
}

DNW.S.4 { @ {RW OR PW} space to {RW interact with OD2} with different potential >= 1.20 
  (EXT RW2V_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
  (EXT RW2V_NODAL RW1V_NODAL < DNW_S_4 ABUT <90 NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
  (EXT RW2V_NODAL PWEL_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
}

DNW.S.5 { @ Space to N+ATIVE (DNW cut N+ACTIVE is not allowed) >= 2.93 
  A = NACT OUTSIDE DNW
  ( EXT DNW A < DNW_S_5 ABUT < 90 SINGULAR REGION ) NOT INSIDE EXCL_SRM
  NACT CUT DNW
}

DNW.O.1 { @ Overlap of NW >= 2.00 
  (INT DNW NWEL < DNW_O_1  ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}

// DNW.R.2 is not able to check
// DNW.R.4 is not able to check


//CO CHECKS
//=========

PSTP_NACT_BTE  = PSTP COIN OUTSIDE EDGE NACT     
NACT_PSTP_BTE  = NACT COIN OUTSIDE EDGE PSTP
NSTP_PACT_BTE  = NSTP COIN OUTSIDE EDGE PACT
PACT_NSTP_BTE  = PACT COIN OUTSIDE EDGE NSTP     

CO.W.1 { @ Width (square) (maximum = minimum) = 0.16 
  A = NOT RECTANGLE CO == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
  (A NOT VIA_EXD) NOT SR_M1
}

#IFDEF LmarkSealringCorner
CO.W.2 { @ Width of CO bar. CO bar is only allowed in seal ring. 0.16  
   INT SR_CO < CO_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY
   A = SIZE SR_CO BY CO_W_2 /2 + 0.005 UNDEROVER TRUNCATE CO_W_2 /2 + 0.005
   ENCLOSE RECTANGLE A 1 0.005 
}
#ELSE
CO.W.2 { @ Width of CO bar. CO bar is only allowed in seal ring. 0.16  
   INT SR_CO < CO_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY
   SIZE SR_CO BY CO_W_2 /2 + 0.005 UNDEROVER TRUNCATE CO_W_2 /2 + 0.005
}
#ENDIF
CO.S.1 { @ Space >= 0.18 
  EXT CO < CO_S_1 ABUT < 90 SINGULAR REGION
}
CO.S.2 { @ Space in CO array [CO number >= 4 x 4 (row and column >= 4) with space <=0.21 um] >= 0.20 
  COMerge = SIZE CO BY CO_S_2_1 / 2 OVERUNDER  // space <= CO_S_2_1 um treated as array
  // ( ( 4 - 1 ) * CO_W_1 + ( 4 - 2 ) * CO_S_2_1 ) / 2 ) = MinArray
  MinArray = SIZE COMerge BY ( ( 4 - 1 ) * CO_W_1 + ( 4 - 2 ) * CO_S_2_1 ) / 2 UNDEROVER
  // get array larger than or equal to 4 x 4 
  COArray = MinArray INTERACT CO >= 4 * 4
  COInArray = CO INTERACT COArray
  EXT COInArray < CO_S_2 ABUT < 90 REGION
}
CO.S.3 { @ {CO inside OD} space to 1.0V, 1.2V, or 2.5V GATE >= 0.11 
  EXT COOD GATE < CO_S_3 ABUT < 90 INSIDE ALSO SINGULAR
}

#IFDEF 3.3V
CO.S.4 { @ {CO inside OD} space to 3.3V GATE >= 0.13 
  EXT COOD HV_GATE < CO_S_4 ABUT < 90 INSIDE ALSO SINGULAR
}
#ENDIF

CO.S.5 { @ {CO inside PO} space to OD >= 0.14 
  EXT COPO OD < CO_S_5 ABUT < 90 INSIDE ALSO SINGULAR
}
CO.EN.1 { @ Enclosure by ACTIVE >= 0.07 
  ENC COOD DACT < CO_EN_1 ABUT < 90 SINGULAR
}
CO.EN.2 { @ Enclosure by PO >= 0.07 
  ENC COPO POLY < CO_EN_2 ABUT < 90 SINGULAR
}
CO.EN.3 { @ Enclosure by butted PP on OD >= 0.09 
  EXT NACT_PSTP_BTE COOD < CO_EN_3 ABUT < 90
  EXT NSTP_PACT_BTE COOD < CO_EN_3 ABUT < 90
  COOD CUT PP
  ENC COOD PP < 0.001 ABUT < 90 SINGULAR
}
CO.EN.4 { @ Enclosure by butted NP on OD >= 0.09 
  EXT PACT_NSTP_BTE COOD < CO_EN_4 ABUT < 90
  EXT PSTP_NACT_BTE COOD < CO_EN_4 ABUT < 90
  COOD CUT NP
  ENC COOD NP < 0.001 ABUT < 90 SINGULAR
}
CO.EN.5 { @ Enclosure by STRAP >= 0.05 
  ENC COOD DSTP < CO_EN_5 ABUT < 90 SINGULAR
}

// CO.R.1 is checked by CO.S.3/CO.S.5
// CO.R.2 is checked by RPO.S.3
// CO.R.3 is checked by CO.W.1

CO.R.6 { @ {CO outside OD} or {CO outside Poly} is not allowed.   
  (CO NOT ODi) NOT POLYGi
}


//BACKEND RULES 
//=============

// for metal stack rules
// metal overlap area is formed by 3 adjacent metal levels

M1Stack   = (SIZE M1Wide7 BY 1.1) AND M1

M2Stack   = (SIZE M2Wide7 BY 1.1) AND M2

//M1 CHECKS
//=========

M1_EDGE_45  = M1 ANGLE == 45
M1_EDGE_45L = LENGTH M1_EDGE_45 >= M1_W_2_L

M1.W.1 { @ Width. >= 0.160 
  INT M1 < M1_W_1 ABUT < 90 SINGULAR REGION
}
M1.W.2 { @ Width of 45-degree bent M1 [length >= 0.5 um] >= 0.200 
  INT M1_EDGE_45L < M1_W_2 ABUT < 90 REGION
}
M1.S.1 { @ Space >= 0.180 
  EXT M1 < M1_S_1 ABUT < 90 SINGULAR REGION
}

M1.S.2 { @ Space to wide M1 (both metal line width and length > 10 um), or wide M1 branch (a small piece of metal connected to a wide metal) within the <= 1.0 um range from the wide M1 >= 0.600 
  M1_S5 = SHRINK (SHRINK (SHRINK (SHRINK M1Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_G5 = GROW (GROW (GROW (GROW M1_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_Wide = M1_G5 AND M1
  M1_Exp = SIZE M1_Wide BY M1_S_2_B INSIDE OF M1 STEP M1_S_1 * 0.7
  M1_Branch = M1_Exp NOT M1_Wide
  M1_Branch_edge = M1_Branch COIN INSIDE EDGE M1
  M1_Check = M1 AND (SIZE M1_Exp BY M1_S_2)
  M1_Branch_Check = M1 AND (EXPAND EDGE M1_Branch_edge OUTSIDE BY M1_S_2 CORNER FILL)
  M1_WideC = STAMP M1_Wide BY M1x
  M1_CheckC = STAMP M1_Check BY M1x
  M1_BranchC = STAMP M1_Branch BY M1x
  M1_Branch_CheckC = STAMP M1_Branch_Check BY M1x
  EXT M1_WideC M1_CheckC < M1_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M1_BranchC M1_Branch_CheckC < M1_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}

M1.S.3 { @ Space [for at least one metal line width >= 0.3 um and the parallel (projective) metal run length >= 1 um] >= 0.220 
  X = EXT M1Wide0.3 M1 < M1_S_3 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 M1_S_3_L
  WideEdge = Y COIN OUTSIDE EDGE M1Wide0.3
  PATH LENGTH WideEdge >= M1_S_3_L
}

M1.S.4 { @ Space to 45-degree bent M1 [for 45-degree bent M1 length >= 0.5 um] >= 0.220 
  X = EXPAND EDGE M1_EDGE_45L OUTSIDE BY M1_S_4
  X AND M1
}
M1.EN.1 { @ Enclosure of CO >= 0.000 
  CO NOT M1
}
M1.EN.2 { @ Enclosure of CO [at least two opposite sides] For CO located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line and another side can follow the M1.EN.1rule. >= 0.050 
  X = RECTANGLE ENCLOSURE CO M1 ABUT > 0 < 90 GOOD M1_EN_1 M1_EN_2 OPPOSITE M1_EN_1 M1_EN_2 OPPOSITE
  Y = ENC [X] M1 < M1_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
 INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M1.A.1 { @ Area >= 0.122 
  AREA M1 < M1_A_1
}
M1.A.2 { @ Enclosed area >= 0.200 
  HOLES M1 < M1_A_2 INNER
}  

//VIA1 CHECKS
//===========

VIA1.W.1 { @ Width (square) (maximum = minimum) = 0.190 
  A = NOT RECTANGLE VIA1 == VIA1_W_1 BY == VIA1_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}

#IFDEF LmarkSealringCorner
VIA1.W.2 { @ Width of VIA1 bar. VIA1 bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIA1 bar is used. 0.130  
  INT SR_V1 < VIA1_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_V1 BY VIA1_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA1_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE 
VIA1.W.2 { @ Width of VIA1 bar. VIA1 bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIA1 bar is used. 0.130  
  INT SR_V1 < VIA1_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_V1 BY VIA1_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA1_W_2 /2 + 0.005
}
#ENDIF
VIA1.S.1 { @ Space >= 0.220 
  EXT VIA1 < VIA1_S_1 ABUT < 90 SINGULAR REGION
}
VIA1.S.2 { @ Space in VIA1 array [VIA1 number >= 3 x 3 (row and column >= 3) with space <= 0.31 um] >= 0.290 
  VIA1Merge = SIZE VIA1 BY VIA1_S_2_S / 2 OVERUNDER  // space <= VIA1_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA1_W_1 + ( 3 - 2 ) * VIA1_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA1Merge BY ( ( 3 - 1 ) * VIA1_W_1 + ( 3 - 2 ) * VIA1_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA1Array = MinArray INTERACT VIA1 >= 3 * 3
  VIA1InArray = VIA1 INTERACT VIA1Array
  EXT VIA1InArray < VIA1_S_2 ABUT < 90 REGION
}
VIA1.EN.1 { @ Enclosure by M1 >= 0.010 
  ENC VIA1 M1 < VIA1_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA1.EN.2 { @ Enclosure by M1 [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA1 M1 ABUT > 0 < 90 GOOD 0.005 VIA1_EN_2 OPPOSITE 0.005 VIA1_EN_2 OPPOSITE
  Y = ENC [X] M1 < VIA1_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA1_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA1.R.1 is checked by VIA1.W.1
#IFNDEF LK
VIA1.R.2_FSG { @ When M1 or M2 width > 1.4um, more than 1 VIA1 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M2OvpM1W = (M2 AND M1Wide1.4) OR (M1 AND M2Wide1.4)
  m1_has_wm_ovp = METAL1i INTERACT M2OvpM1W
  m2_has_wm_ovp = METAL2i INTERACT M2OvpM1W
  MOvp = m1_has_wm_ovp AND m2_has_wm_ovp 
  VIA_EXC = VIA1 NOT VIA_EXD
  M12Wide = M1Wide1.4 OR M2Wide1.4
  OvpOnM12W = MOvp NOT OUTSIDE M12Wide
  VIA_Check1 = VIA_EXC INTERACT OvpOnM12W 
  
  Merge1OnM12W = SIZE VIA_Check1 BY 0.71/2 INSIDE OF OvpOnM12W STEP 0.18*0.7
  badRegion1  = Merge1OnM12W INTERACT VIA_Check1 < 2
  GoodRegion1 = Merge1OnM12W OUTSIDE badRegion1
  Merge2OnM12W = SIZE Merge1OnM12W BY (1 - 0.71)/2 INSIDE OF OvpOnM12W STEP 0.18*0.7
  badRegion2  = Merge2OnM12W INTERACT VIA_Check1 < 4
  GoodRegion2 = Merge2OnM12W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check1 INTERACT GoodRegion) NOT OUTSIDE M12Wide
  M12Check = (M12Wide AND OvpOnM12W) NOT INTERACT GoodVIA
  VIA_Check1 NOT OUTSIDE M12Check 
}  
#ENDIF  // LK


M3Stack   = (SIZE M3Wide7 BY 1.1) AND M3
M3OvpM2   = M3Stack AND M2Stack
M2Overlap = M3OvpM2 AND M1Stack


//M2 CHECKS
//=========

M2_EDGE_45 = M2 ANGLE == 45
M2_EDGE_45L = LENGTH M2_EDGE_45 >= M2_W_2_L

M2.W.1 { @ Width >= 0.200 
  INT M2 < M2_W_1 ABUT < 90 SINGULAR REGION
}
M2.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M2_EDGE_45L < M2_W_2 ABUT < 90 REGION
}
M2.S.1 { @ Space >= 0.210 
  EXT M2 < M2_S_1 ABUT < 90 SINGULAR REGION
}
M2.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M2_S5 = SHRINK (SHRINK (SHRINK (SHRINK M2Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_G5 = GROW (GROW (GROW (GROW M2_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_Wide = M2_G5 AND M2
  M2_Exp = SIZE M2_Wide BY M2_S_2_B INSIDE OF M2 STEP M2_S_1 * 0.7
  M2_Branch = M2_Exp NOT M2_Wide
  M2_Branch_edge = M2_Branch COIN INSIDE EDGE M2
  M2_Check = M2 AND (SIZE M2_Exp BY M2_S_2)
  M2_Branch_Check = M2 AND (EXPAND EDGE M2_Branch_edge OUTSIDE BY M2_S_2 CORNER FILL)
  M2_WideC = STAMP M2_Wide BY M2x
  M2_CheckC = STAMP M2_Check BY M2x
  M2_BranchC = STAMP M2_Branch BY M2x
  M2_Branch_CheckC = STAMP M2_Branch_Check BY M2x
  EXT M2_WideC M2_CheckC < M2_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M2_BranchC M2_Branch_CheckC < M2_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M2.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M2Wide0.4 M2 < M2_S_3 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 M2_S_3_L
  WideEdge = Y COIN OUTSIDE EDGE M2Wide0.4
  PATH LENGTH WideEdge >= M2_S_3_L
}
M2.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M2_EDGE_45L OUTSIDE BY M2_S_4
  X AND M2
}
M2.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA1 M2 < M2_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M2.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA1 M2 ABUT > 0 < 90 GOOD M2_EN_1 M2_EN_2 OPPOSITE M2_EN_1 M2_EN_2 OPPOSITE
  Y = ENC [X] M2 < M2_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA1_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M2.A.1 { @ Area >= 0.144 
  AREA M2 < M2_A_1
}
M2.A.2 { @ Enclosed area >= 0.265 
  HOLES M2 < M2_A_2 INNER
}  

M2.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M2OverlapBig = (SIZE M2Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M2Overlap
  W = EXT M2OverlapBig M2Overlap < M2_S_5 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M1
  Y = X NOT INSIDE M2
  Y1 = Y NOT INSIDE M3
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M4Stack   = (SIZE M4Wide7 BY 1.1) AND M4
M3Overlap = M3OvpM2 AND M4Stack



//M3 CHECKS
//=========

M3_EDGE_45 = M3 ANGLE == 45
M3_EDGE_45L = LENGTH M3_EDGE_45 >= M3_W_2_L

M3.W.1 { @ Width >= 0.200 
  INT M3 < M3_W_1 ABUT < 90 SINGULAR REGION
}
M3.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M3_EDGE_45L < M3_W_2 ABUT < 90 REGION
}
M3.S.1 { @ Space >= 0.210 
  EXT M3 < M3_S_1 ABUT < 90 SINGULAR REGION
}
M3.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M3_S5 = SHRINK (SHRINK (SHRINK (SHRINK M3Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_G5 = GROW (GROW (GROW (GROW M3_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_Wide = M3_G5 AND M3
  M3_Exp = SIZE M3_Wide BY M3_S_2_B INSIDE OF M3 STEP M3_S_1 * 0.7
  M3_Branch = M3_Exp NOT M3_Wide
  M3_Branch_edge = M3_Branch COIN INSIDE EDGE M3
  M3_Check = M3 AND (SIZE M3_Exp BY M3_S_2)
  M3_Branch_Check = M3 AND (EXPAND EDGE M3_Branch_edge OUTSIDE BY M3_S_2 CORNER FILL)
  M3_WideC = STAMP M3_Wide BY M3x
  M3_CheckC = STAMP M3_Check BY M3x
  M3_BranchC = STAMP M3_Branch BY M3x
  M3_Branch_CheckC = STAMP M3_Branch_Check BY M3x
  EXT M3_WideC M3_CheckC < M3_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M3_BranchC M3_Branch_CheckC < M3_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M3.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M3Wide0.4 M3 < M3_S_3 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 M3_S_3_L
  WideEdge = Y COIN OUTSIDE EDGE M3Wide0.4
  PATH LENGTH WideEdge >= M3_S_3_L
}
M3.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M3_EDGE_45L OUTSIDE BY M3_S_4
  X AND M3
}
M3.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA2 M3 < M3_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M3.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA2 M3 ABUT > 0 < 90 GOOD M3_EN_1 M3_EN_2 OPPOSITE M3_EN_1 M3_EN_2 OPPOSITE
  Y = ENC [X] M3 < M3_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA2_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M3.A.1 { @ Area >= 0.144 
  AREA M3 < M3_A_1
}
M3.A.2 { @ Enclosed area >= 0.265 
  HOLES M3 < M3_A_2 INNER
}  

M3.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M3OverlapBig = (SIZE M3Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M3Overlap
  W = EXT M3OverlapBig M3Overlap < M3_S_5 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M2
  Y = X NOT INSIDE M3
  Y1 = Y NOT INSIDE M4
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M5Wide1.8 = (SIZE M5Wide1.4 BY 0.9 UNDEROVER TRUNCATE 0.9) AND M5Wide1.4
M5Stack   = (SIZE M5Wide7 BY 1.1) AND M5
M5OvpM4   = M5Stack AND M4Stack
M4Overlap = M5OvpM4 AND M3Stack


//M4 CHECKS
//=========

M4_EDGE_45 = M4 ANGLE == 45
M4_EDGE_45L = LENGTH M4_EDGE_45 >= M4_W_2_L

M4.W.1 { @ Width >= 0.200 
  INT M4 < M4_W_1 ABUT < 90 SINGULAR REGION
}
M4.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M4_EDGE_45L < M4_W_2 ABUT < 90 REGION
}
M4.S.1 { @ Space >= 0.210 
  EXT M4 < M4_S_1 ABUT < 90 SINGULAR REGION
}
M4.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M4_S5 = SHRINK (SHRINK (SHRINK (SHRINK M4Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_G5 = GROW (GROW (GROW (GROW M4_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_Wide = M4_G5 AND M4
  M4_Exp = SIZE M4_Wide BY M4_S_2_B INSIDE OF M4 STEP M4_S_1 * 0.7
  M4_Branch = M4_Exp NOT M4_Wide
  M4_Branch_edge = M4_Branch COIN INSIDE EDGE M4
  M4_Check = M4 AND (SIZE M4_Exp BY M4_S_2)
  M4_Branch_Check = M4 AND (EXPAND EDGE M4_Branch_edge OUTSIDE BY M4_S_2 CORNER FILL)
  M4_WideC = STAMP M4_Wide BY M4x
  M4_CheckC = STAMP M4_Check BY M4x
  M4_BranchC = STAMP M4_Branch BY M4x
  M4_Branch_CheckC = STAMP M4_Branch_Check BY M4x
  EXT M4_WideC M4_CheckC < M4_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M4_BranchC M4_Branch_CheckC < M4_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M4.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M4Wide0.4 M4 < M4_S_3 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 M4_S_3_L
  WideEdge = Y COIN OUTSIDE EDGE M4Wide0.4
  PATH LENGTH WideEdge >= M4_S_3_L
}
M4.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M4_EDGE_45L OUTSIDE BY M4_S_4
  X AND M4
}
M4.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA3 M4 < M4_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M4.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA3 M4 ABUT > 0 < 90 GOOD M4_EN_1 M4_EN_2 OPPOSITE M4_EN_1 M4_EN_2 OPPOSITE
  Y = ENC [X] M4 < M4_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA3_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M4.A.1 { @ Area >= 0.144 
  AREA M4 < M4_A_1
}
M4.A.2 { @ Enclosed area >= 0.265 
  HOLES M4 < M4_A_2 INNER
}  

M4.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M4OverlapBig = (SIZE M4Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M4Overlap
  W = EXT M4OverlapBig M4Overlap < M4_S_5 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M3
  Y = X NOT INSIDE M4
  Y1 = Y NOT INSIDE M5
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M6Wide1.8 = (SIZE M6Wide1.4 BY 0.9 UNDEROVER TRUNCATE 0.9) AND M6Wide1.4
M6Stack   = (SIZE M6Wide7 BY 1.1) AND M6
M5Overlap = M5OvpM4 AND M6Stack



//M5 CHECKS
//=========

M5_EDGE_45 = M5 ANGLE == 45
M5_EDGE_45L = LENGTH M5_EDGE_45 >= M5_W_2_L

M5.W.1 { @ Width >= 0.200 
  INT M5 < M5_W_1 ABUT < 90 SINGULAR REGION
}
M5.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M5_EDGE_45L < M5_W_2 ABUT < 90 REGION
}
M5.S.1 { @ Space >= 0.210 
  EXT M5 < M5_S_1 ABUT < 90 SINGULAR REGION
}
M5.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M5_S5 = SHRINK (SHRINK (SHRINK (SHRINK M5Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_G5 = GROW (GROW (GROW (GROW M5_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_Wide = M5_G5 AND M5
  M5_Exp = SIZE M5_Wide BY M5_S_2_B INSIDE OF M5 STEP M5_S_1 * 0.7
  M5_Branch = M5_Exp NOT M5_Wide
  M5_Branch_edge = M5_Branch COIN INSIDE EDGE M5
  M5_Check = M5 AND (SIZE M5_Exp BY M5_S_2)
  M5_Branch_Check = M5 AND (EXPAND EDGE M5_Branch_edge OUTSIDE BY M5_S_2 CORNER FILL)
  M5_WideC = STAMP M5_Wide BY M5x
  M5_CheckC = STAMP M5_Check BY M5x
  M5_BranchC = STAMP M5_Branch BY M5x
  M5_Branch_CheckC = STAMP M5_Branch_Check BY M5x
  EXT M5_WideC M5_CheckC < M5_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M5_BranchC M5_Branch_CheckC < M5_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M5.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M5Wide0.4 M5 < M5_S_3 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 M5_S_3_L
  WideEdge = Y COIN OUTSIDE EDGE M5Wide0.4
  PATH LENGTH WideEdge >= M5_S_3_L
}
M5.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M5_EDGE_45L OUTSIDE BY M5_S_4
  X AND M5
}
M5.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA4 M5 < M5_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M5.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA4 M5 ABUT > 0 < 90 GOOD M5_EN_1 M5_EN_2 OPPOSITE M5_EN_1 M5_EN_2 OPPOSITE
  Y = ENC [X] M5 < M5_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA4_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M5.A.1 { @ Area >= 0.144 
  AREA M5 < M5_A_1
}
M5.A.2 { @ Enclosed area >= 0.265 
  HOLES M5 < M5_A_2 INNER
}  

M5.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M5OverlapBig = (SIZE M5Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M5Overlap
  W = EXT M5OverlapBig M5Overlap < M5_S_5 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M4
  Y = X NOT INSIDE M5
  Y1 = Y NOT INSIDE M6
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M7Wide1.8 = (SIZE M7Wide1.4 BY 0.9 UNDEROVER TRUNCATE 0.9) AND M7Wide1.4
M7Stack   = (SIZE M7Wide7 BY 1.1) AND M7
M7OvpM6   = M7Stack AND M6Stack
M6Overlap = M7OvpM6 AND M5Stack

#IFDEF THICK_TOP3_METAL

//THICK M6 CHECKS
//=============


M6.W.1.THICK { @ Width >= 0.400 
  INT M6 < M6_W_1 ABUT < 90 SINGULAR REGION
}
M6.S.1.THICK { @ Space >= 0.420 
  EXT M6 < M6_S_1 ABUT < 90 SINGULAR REGION
}
M6.S.2.THICK { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M6_S5 = SHRINK (SHRINK (SHRINK (SHRINK M6Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_G5 = GROW (GROW (GROW (GROW M6_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_Wide = M6_G5 AND M6
  M6_Exp = SIZE M6_Wide BY M6_S_2_B INSIDE OF M6 STEP M6_S_1 * 0.7
  M6_Branch = M6_Exp NOT M6_Wide
  M6_Branch_edge = M6_Branch COIN INSIDE EDGE M6
  M6_Check = M6 AND (SIZE M6_Exp BY M6_S_2)
  M6_Branch_Check = M6 AND (EXPAND EDGE M6_Branch_edge OUTSIDE BY M6_S_2 CORNER FILL)
  M6_WideC = STAMP M6_Wide BY M6x
  M6_CheckC = STAMP M6_Check BY M6x
  M6_BranchC = STAMP M6_Branch BY M6x
  M6_Branch_CheckC = STAMP M6_Branch_Check BY M6x
  EXT M6_WideC M6_CheckC < M6_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6_BranchC M6_Branch_CheckC < M6_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M6.EN.1.THICK { @ Enclosure of VIA5 >= 0.020 
  ENC VIA5 M6 < M6_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
M6.EN.2.THICK { @ Enclosure of VIA5 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA5 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA5 M6 ABUT > 0 < 90 GOOD M6_EN_1 M6_EN_2 OPPOSITE M6_EN_1 M6_EN_2 OPPOSITE
  ENC A M6 < M6_EN_2_A ABUT < 90 SINGULAR REGION
}
M6.A.1.THICK { @ Area >= 0.562 
  AREA M6 < M6_A_1
}
M6.A.2.THICK { @ Enclosed area >= 0.565 
  HOLES M6 < M6_A_2 INNER
}  

#ELSE


//M6 CHECKS
//=========

M6_EDGE_45 = M6 ANGLE == 45
M6_EDGE_45L = LENGTH M6_EDGE_45 >= M6_W_2_L

M6.W.1 { @ Width >= 0.200 
  INT M6 < M6_W_1 ABUT < 90 SINGULAR REGION
}
M6.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M6_EDGE_45L < M6_W_2 ABUT < 90 REGION
}
M6.S.1 { @ Space >= 0.210 
  EXT M6 < M6_S_1 ABUT < 90 SINGULAR REGION
}
M6.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M6_S5 = SHRINK (SHRINK (SHRINK (SHRINK M6Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_G5 = GROW (GROW (GROW (GROW M6_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_Wide = M6_G5 AND M6
  M6_Exp = SIZE M6_Wide BY M6_S_2_B INSIDE OF M6 STEP M6_S_1 * 0.7
  M6_Branch = M6_Exp NOT M6_Wide
  M6_Branch_edge = M6_Branch COIN INSIDE EDGE M6
  M6_Check = M6 AND (SIZE M6_Exp BY M6_S_2)
  M6_Branch_Check = M6 AND (EXPAND EDGE M6_Branch_edge OUTSIDE BY M6_S_2 CORNER FILL)
  M6_WideC = STAMP M6_Wide BY M6x
  M6_CheckC = STAMP M6_Check BY M6x
  M6_BranchC = STAMP M6_Branch BY M6x
  M6_Branch_CheckC = STAMP M6_Branch_Check BY M6x
  EXT M6_WideC M6_CheckC < M6_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6_BranchC M6_Branch_CheckC < M6_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M6.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M6Wide0.4 M6 < M6_S_3 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 M6_S_3_L
  WideEdge = Y COIN OUTSIDE EDGE M6Wide0.4
  PATH LENGTH WideEdge >= M6_S_3_L
}
M6.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M6_EDGE_45L OUTSIDE BY M6_S_4
  X AND M6
}
M6.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA5 M6 < M6_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M6.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA5 M6 ABUT > 0 < 90 GOOD M6_EN_1 M6_EN_2 OPPOSITE M6_EN_1 M6_EN_2 OPPOSITE
  Y = ENC [X] M6 < M6_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA5_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M6.A.1 { @ Area >= 0.144 
  AREA M6 < M6_A_1
}
M6.A.2 { @ Enclosed area >= 0.265 
  HOLES M6 < M6_A_2 INNER
}  
#ENDIF

M6.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M6OverlapBig = (SIZE M6Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M6Overlap
  W = EXT M6OverlapBig M6Overlap < M6_S_5 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M5
  Y = X NOT INSIDE M6
  Y1 = Y NOT INSIDE M7
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M8Wide1.8 = (SIZE M8Wide1.4 BY 0.9 UNDEROVER TRUNCATE 0.9) AND M8Wide1.4
M8Stack   = (SIZE M8Wide7 BY 1.1) AND M8
M7Overlap = M7OvpM6 AND M8Stack


#IFDEF THICK_TOP2_METAL

//THICK M7 CHECKS
//=============


M7.W.1.THICK { @ Width >= 0.400 
  INT M7 < M7_W_1 ABUT < 90 SINGULAR REGION
}
M7.S.1.THICK { @ Space >= 0.420 
  EXT M7 < M7_S_1 ABUT < 90 SINGULAR REGION
}
M7.S.2.THICK { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M7_S5 = SHRINK (SHRINK (SHRINK (SHRINK M7Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_G5 = GROW (GROW (GROW (GROW M7_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_Wide = M7_G5 AND M7
  M7_Exp = SIZE M7_Wide BY M7_S_2_B INSIDE OF M7 STEP M7_S_1 * 0.7
  M7_Branch = M7_Exp NOT M7_Wide
  M7_Branch_edge = M7_Branch COIN INSIDE EDGE M7
  M7_Check = M7 AND (SIZE M7_Exp BY M7_S_2)
  M7_Branch_Check = M7 AND (EXPAND EDGE M7_Branch_edge OUTSIDE BY M7_S_2 CORNER FILL)
  M7_WideC = STAMP M7_Wide BY M7x
  M7_CheckC = STAMP M7_Check BY M7x
  M7_BranchC = STAMP M7_Branch BY M7x
  M7_Branch_CheckC = STAMP M7_Branch_Check BY M7x
  EXT M7_WideC M7_CheckC < M7_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M7_BranchC M7_Branch_CheckC < M7_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M7.EN.1.THICK { @ Enclosure of VIA6 >= 0.020 
  ENC VIA6 M7 < M7_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
M7.EN.2.THICK { @ Enclosure of VIA6 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA6 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA6 M7 ABUT > 0 < 90 GOOD M7_EN_1 M7_EN_2 OPPOSITE M7_EN_1 M7_EN_2 OPPOSITE
  ENC A M7 < M7_EN_2_A ABUT < 90 SINGULAR REGION
}
M7.A.1.THICK { @ Area >= 0.562 
  AREA M7 < M7_A_1
}
M7.A.2.THICK { @ Enclosed area >= 0.565 
  HOLES M7 < M7_A_2 INNER
}  

#ELSE
#IFDEF THICK_TOP3_METAL

//THICK M7 CHECKS
//=============


M7.W.1.THICK { @ Width >= 0.400 
  INT M7 < M7_W_1 ABUT < 90 SINGULAR REGION
}
M7.S.1.THICK { @ Space >= 0.420 
  EXT M7 < M7_S_1 ABUT < 90 SINGULAR REGION
}
M7.S.2.THICK { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M7_S5 = SHRINK (SHRINK (SHRINK (SHRINK M7Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_G5 = GROW (GROW (GROW (GROW M7_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_Wide = M7_G5 AND M7
  M7_Exp = SIZE M7_Wide BY M7_S_2_B INSIDE OF M7 STEP M7_S_1 * 0.7
  M7_Branch = M7_Exp NOT M7_Wide
  M7_Branch_edge = M7_Branch COIN INSIDE EDGE M7
  M7_Check = M7 AND (SIZE M7_Exp BY M7_S_2)
  M7_Branch_Check = M7 AND (EXPAND EDGE M7_Branch_edge OUTSIDE BY M7_S_2 CORNER FILL)
  M7_WideC = STAMP M7_Wide BY M7x
  M7_CheckC = STAMP M7_Check BY M7x
  M7_BranchC = STAMP M7_Branch BY M7x
  M7_Branch_CheckC = STAMP M7_Branch_Check BY M7x
  EXT M7_WideC M7_CheckC < M7_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M7_BranchC M7_Branch_CheckC < M7_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M7.EN.1.THICK { @ Enclosure of VIA6 >= 0.020 
  ENC VIA6 M7 < M7_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
M7.EN.2.THICK { @ Enclosure of VIA6 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA6 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA6 M7 ABUT > 0 < 90 GOOD M7_EN_1 M7_EN_2 OPPOSITE M7_EN_1 M7_EN_2 OPPOSITE
  ENC A M7 < M7_EN_2_A ABUT < 90 SINGULAR REGION
}
M7.A.1.THICK { @ Area >= 0.562 
  AREA M7 < M7_A_1
}
M7.A.2.THICK { @ Enclosed area >= 0.565 
  HOLES M7 < M7_A_2 INNER
}  

#ELSE


//M7 CHECKS
//=========

M7_EDGE_45 = M7 ANGLE == 45
M7_EDGE_45L = LENGTH M7_EDGE_45 >= M7_W_2_L

M7.W.1 { @ Width >= 0.200 
  INT M7 < M7_W_1 ABUT < 90 SINGULAR REGION
}
M7.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M7_EDGE_45L < M7_W_2 ABUT < 90 REGION
}
M7.S.1 { @ Space >= 0.210 
  EXT M7 < M7_S_1 ABUT < 90 SINGULAR REGION
}
M7.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M7_S5 = SHRINK (SHRINK (SHRINK (SHRINK M7Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_G5 = GROW (GROW (GROW (GROW M7_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_Wide = M7_G5 AND M7
  M7_Exp = SIZE M7_Wide BY M7_S_2_B INSIDE OF M7 STEP M7_S_1 * 0.7
  M7_Branch = M7_Exp NOT M7_Wide
  M7_Branch_edge = M7_Branch COIN INSIDE EDGE M7
  M7_Check = M7 AND (SIZE M7_Exp BY M7_S_2)
  M7_Branch_Check = M7 AND (EXPAND EDGE M7_Branch_edge OUTSIDE BY M7_S_2 CORNER FILL)
  M7_WideC = STAMP M7_Wide BY M7x
  M7_CheckC = STAMP M7_Check BY M7x
  M7_BranchC = STAMP M7_Branch BY M7x
  M7_Branch_CheckC = STAMP M7_Branch_Check BY M7x
  EXT M7_WideC M7_CheckC < M7_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M7_BranchC M7_Branch_CheckC < M7_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M7.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M7Wide0.4 M7 < M7_S_3 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 M7_S_3_L
  WideEdge = Y COIN OUTSIDE EDGE M7Wide0.4
  PATH LENGTH WideEdge >= M7_S_3_L
}
M7.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M7_EDGE_45L OUTSIDE BY M7_S_4
  X AND M7
}
M7.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA6 M7 < M7_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M7.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA6 M7 ABUT > 0 < 90 GOOD M7_EN_1 M7_EN_2 OPPOSITE M7_EN_1 M7_EN_2 OPPOSITE
  Y = ENC [X] M7 < M7_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA6_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M7.A.1 { @ Area >= 0.144 
  AREA M7 < M7_A_1
}
M7.A.2 { @ Enclosed area >= 0.265 
  HOLES M7 < M7_A_2 INNER
}  
#ENDIF
#ENDIF

M7.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M7OverlapBig = (SIZE M7Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M7Overlap
  W = EXT M7OverlapBig M7Overlap < M7_S_5 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M6
  Y = X NOT INSIDE M7
  Y1 = Y NOT INSIDE M8
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}



//VIA2 CHECKS
//===========

VIA2.W.1 { @ Width (square) (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA2 == VIA2_W_1 BY == VIA2_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA2.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V2 < VIA2_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_V2 BY VIA2_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA2_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA2.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V2 < VIA2_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_V2 BY VIA2_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA2_W_2 /2 + 0.005
}
#ENDIF  // LmarkSealringCorner
VIA2.S.1 { @ Space >= 0.220 
  EXT VIA2 < VIA2_S_1 ABUT < 90 SINGULAR REGION
}
VIA2.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA2Merge = SIZE VIA2 BY VIA2_S_2_S / 2 OVERUNDER  // space <= VIA2_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA2_W_1 + ( 3 - 2 ) * VIA2_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA2Merge BY ( ( 3 - 1 ) * VIA2_W_1 + ( 3 - 2 ) * VIA2_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA2Array = MinArray INTERACT VIA2 >= 3 * 3
  VIA2InArray = VIA2 INTERACT VIA2Array
  EXT VIA2InArray < VIA2_S_2 ABUT < 90 REGION
}
VIA2.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA2 M2 < VIA2_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA2.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA2 M2 ABUT > 0 < 90 GOOD VIA2_EN_1 VIA2_EN_2 OPPOSITE VIA2_EN_1 VIA2_EN_2 OPPOSITE
  Y = ENC [X] M2 < VIA2_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA2_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA2.R.1 is checked by VIA2.W.1
#IFNDEF LK
VIA2.R.2_FSG { @ When M2 or M3 width > 1.4um, more than 1 VIA2 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M3OvpM2W = (M3 AND M2Wide1.4) OR (M2 AND M3Wide1.4)
  m2_has_wm_ovp = METAL2i INTERACT M3OvpM2W
  m3_has_wm_ovp = METAL3i INTERACT M3OvpM2W
  MOvp = m2_has_wm_ovp AND m3_has_wm_ovp 
  VIA_EXC = VIA2 NOT VIA_EXD
  M23Wide = M2Wide1.4 OR M3Wide1.4
  OvpOnM23W = MOvp NOT OUTSIDE M23Wide
  VIA_Check2 = VIA_EXC INTERACT OvpOnM23W 
  
  Merge1OnM23W = SIZE VIA_Check2 BY 0.71/2 INSIDE OF OvpOnM23W STEP 0.21*0.7
  badRegion1  = Merge1OnM23W INTERACT VIA_Check2 < 2
  GoodRegion1 = Merge1OnM23W OUTSIDE badRegion1
  Merge2OnM23W = SIZE Merge1OnM23W BY (1 - 0.71)/2 INSIDE OF OvpOnM23W STEP 0.21*0.7
  badRegion2  = Merge2OnM23W INTERACT VIA_Check2 < 4
  GoodRegion2 = Merge2OnM23W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check2 INTERACT GoodRegion) NOT OUTSIDE M23Wide
  M23Check = (M23Wide AND OvpOnM23W) NOT INTERACT GoodVIA
  VIA_Check2 NOT OUTSIDE M23Check 
}
#ENDIF  // LK



//VIA3 CHECKS
//===========

VIA3.W.1 { @ Width (square) (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA3 == VIA3_W_1 BY == VIA3_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA3.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V3 < VIA3_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_V3 BY VIA3_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA3_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA3.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V3 < VIA3_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_V3 BY VIA3_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA3_W_2 /2 + 0.005
}
#ENDIF  // LmarkSealringCorner
VIA3.S.1 { @ Space >= 0.220 
  EXT VIA3 < VIA3_S_1 ABUT < 90 SINGULAR REGION
}
VIA3.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA3Merge = SIZE VIA3 BY VIA3_S_2_S / 2 OVERUNDER  // space <= VIA3_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA3_W_1 + ( 3 - 2 ) * VIA3_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA3Merge BY ( ( 3 - 1 ) * VIA3_W_1 + ( 3 - 2 ) * VIA3_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA3Array = MinArray INTERACT VIA3 >= 3 * 3
  VIA3InArray = VIA3 INTERACT VIA3Array
  EXT VIA3InArray < VIA3_S_2 ABUT < 90 REGION
}
VIA3.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA3 M3 < VIA3_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA3.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA3 M3 ABUT > 0 < 90 GOOD VIA3_EN_1 VIA3_EN_2 OPPOSITE VIA3_EN_1 VIA3_EN_2 OPPOSITE
  Y = ENC [X] M3 < VIA3_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA3_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA3.R.1 is checked by VIA3.W.1
#IFNDEF LK
VIA3.R.2_FSG { @ When M3 or M4 width > 1.4um, more than 1 VIA3 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M4OvpM3W = (M4 AND M3Wide1.4) OR (M3 AND M4Wide1.4)
  m3_has_wm_ovp = METAL3i INTERACT M4OvpM3W
  m4_has_wm_ovp = METAL4i INTERACT M4OvpM3W
  MOvp = m3_has_wm_ovp AND m4_has_wm_ovp 
  VIA_EXC = VIA3 NOT VIA_EXD
  M34Wide = M3Wide1.4 OR M4Wide1.4
  OvpOnM34W = MOvp NOT OUTSIDE M34Wide
  VIA_Check3 = VIA_EXC INTERACT OvpOnM34W 
  
  Merge1OnM34W = SIZE VIA_Check3 BY 0.71/2 INSIDE OF OvpOnM34W STEP 0.21*0.7
  badRegion1  = Merge1OnM34W INTERACT VIA_Check3 < 2
  GoodRegion1 = Merge1OnM34W OUTSIDE badRegion1
  Merge2OnM34W = SIZE Merge1OnM34W BY (1 - 0.71)/2 INSIDE OF OvpOnM34W STEP 0.21*0.7
  badRegion2  = Merge2OnM34W INTERACT VIA_Check3 < 4
  GoodRegion2 = Merge2OnM34W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check3 INTERACT GoodRegion) NOT OUTSIDE M34Wide
  M34Check = (M34Wide AND OvpOnM34W) NOT INTERACT GoodVIA
  VIA_Check3 NOT OUTSIDE M34Check 
}
#ENDIF  // LK



//VIA4 CHECKS
//===========

VIA4.W.1 { @ Width (square) (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA4 == VIA4_W_1 BY == VIA4_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA4.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V4 < VIA4_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_V4 BY VIA4_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA4_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA4.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V4 < VIA4_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_V4 BY VIA4_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA4_W_2 /2 + 0.005
}
#ENDIF  // LmarkSealringCorner
VIA4.S.1 { @ Space >= 0.220 
  EXT VIA4 < VIA4_S_1 ABUT < 90 SINGULAR REGION
}
VIA4.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA4Merge = SIZE VIA4 BY VIA4_S_2_S / 2 OVERUNDER  // space <= VIA4_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA4_W_1 + ( 3 - 2 ) * VIA4_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA4Merge BY ( ( 3 - 1 ) * VIA4_W_1 + ( 3 - 2 ) * VIA4_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA4Array = MinArray INTERACT VIA4 >= 3 * 3
  VIA4InArray = VIA4 INTERACT VIA4Array
  EXT VIA4InArray < VIA4_S_2 ABUT < 90 REGION
}
VIA4.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA4 M4 < VIA4_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA4.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA4 M4 ABUT > 0 < 90 GOOD VIA4_EN_1 VIA4_EN_2 OPPOSITE VIA4_EN_1 VIA4_EN_2 OPPOSITE
  Y = ENC [X] M4 < VIA4_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA4_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA4.R.1 is checked by VIA4.W.1
#IFNDEF LK
VIA4.R.2_FSG { @ When M4 or M5 width > 1.4um, more than 1 VIA4 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M5OvpM4W = (M5 AND M4Wide1.4) OR (M4 AND M5Wide1.4)
  m4_has_wm_ovp = METAL4i INTERACT M5OvpM4W
  m5_has_wm_ovp = METAL5i INTERACT M5OvpM4W
  MOvp = m4_has_wm_ovp AND m5_has_wm_ovp 
  VIA_EXC = VIA4 NOT VIA_EXD
  M45Wide = M4Wide1.4 OR M5Wide1.4
  OvpOnM45W = MOvp NOT OUTSIDE M45Wide
  VIA_Check4 = VIA_EXC INTERACT OvpOnM45W 
  
  Merge1OnM45W = SIZE VIA_Check4 BY 0.71/2 INSIDE OF OvpOnM45W STEP 0.21*0.7
  badRegion1  = Merge1OnM45W INTERACT VIA_Check4 < 2
  GoodRegion1 = Merge1OnM45W OUTSIDE badRegion1
  Merge2OnM45W = SIZE Merge1OnM45W BY (1 - 0.71)/2 INSIDE OF OvpOnM45W STEP 0.21*0.7
  badRegion2  = Merge2OnM45W INTERACT VIA_Check4 < 4
  GoodRegion2 = Merge2OnM45W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check4 INTERACT GoodRegion) NOT OUTSIDE M45Wide
  M45Check = (M45Wide AND OvpOnM45W) NOT INTERACT GoodVIA
  VIA_Check4 NOT OUTSIDE M45Check 
}
#ENDIF  // LK


#IFDEF THICK_TOP3_METAL

//TOP VIA5 CHECKS
//================

VIA5.W.1.THICK { @ Width (square) (maximum = minimum) = 0.36 
  A = NOT RECTANGLE VIA5 == VIA5_W_1 BY == VIA5_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA5.W.2.THICK { @ Width of VIA7 bar. VIA7 bar is only allowed in seal ring and fuse protection ring. 0.28  
  INT SR_V5 < VIA5_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  A = SIZE SR_V5 BY VIA5_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA5_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 2 0.005
}

VIA5.S.1.THICK { @ Space >= 0.35 
  EXT ( VIA5 NOT SR_V5 ) < VIA5_S_1 ABUT < 90 SINGULAR REGION
}
#ELSE
VIA5.W.2.THICK { @ Width of VIA7 bar. VIA7 bar is only allowed in seal ring and fuse protection ring. 0.28  
  INT SR_V5 < VIA5_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  SIZE SR_V5 BY VIA5_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA5_W_2 /2 + 0.005
}

VIA5.S.1.THICK { @ Space >= 0.35 
  EXT VIA5 < VIA5_S_1 ABUT < 90 SINGULAR REGION
}
#ENDIF // LmarkSealringCorner

VIA5.S.2.THICK { @ Space in VIA7 array [VIA7 number >= 3 X 3 (row and column >= 3) with space <= 0.56 um] >= 0.54 
  VIA5Merge = SIZE VIA5 BY VIA5_S_2_S / 2 OVERUNDER  // space <= VIA5_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA5_W_1 + ( 3 - 2 ) * VIA5_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA5Merge BY ( ( 3 - 1 ) * VIA5_W_1 + ( 3 - 2 ) * VIA5_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA5Array = MinArray INTERACT VIA5 >= 3 * 3
  VIA5InArray = VIA5 INTERACT VIA5Array
  EXT VIA5InArray < VIA5_S_2 ABUT < 90 REGION
}
VIA5.EN.1.THICK { @ Enclosure by M5 >= 0.01
  ENC VIA5 M5 < VIA5_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA5.EN.2.THICK { @ Enclosure by M5 (at least two opposite sides) >= 0.05
  X = RECTANGLE ENCLOSURE VIA5 M5 ABUT > 0 < 90 GOOD VIA5_EN_1 VIA5_EN_2 OPPOSITE VIA5_EN_1 VIA5_EN_2 OPPOSITE
  Y = ENC [X] M5 < VIA5_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA5_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA5.R.1 is checked by VIA5.W.1

VIA5.R.2.THICK { @ At least 2 VIA5, with space <=1.7um, are required to connect M5 and M6, 
	@ if either M5 or M6 has both width and length >1.8um. 
  M6OvpM5W = (M6 AND M5Wide1.8) OR (M5 AND M6Wide1.8)
  m5_has_wm_ovp = METAL5i INTERACT M6OvpM5W
  m6_has_wm_ovp = METAL6i INTERACT M6OvpM5W
  MOvp = m5_has_wm_ovp AND m6_has_wm_ovp 
  VIA_EXC = VIA5 NOT VIA_EXD
  M56Wide = M5Wide1.8 OR M6Wide1.8
  OvpOnM56W = MOvp NOT OUTSIDE M56Wide
  VIA_Check5 = VIA_EXC INTERACT OvpOnM56W 
  
  Merge1OnM56W = SIZE VIA_Check5 BY 1.7/2 INSIDE OF OvpOnM56W STEP 0.42*0.7
  badRegion1  = Merge1OnM56W INTERACT VIA_Check5 < 2
  GoodRegion1 = Merge1OnM56W OUTSIDE badRegion1
  GoodVIA5 = (VIA_Check5 INTERACT GoodRegion1) NOT OUTSIDE M56Wide
  M56Check = (M56Wide AND OvpOnM56W) NOT INTERACT GoodVIA5
  VIA_Check5 NOT OUTSIDE M56Check 
}    

#ELSE


//VIA5 CHECKS
//===========

VIA5.W.1 { @ Width (square) (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA5 == VIA5_W_1 BY == VIA5_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA5.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V5 < VIA5_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_V5 BY VIA5_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA5_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA5.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V5 < VIA5_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_V5 BY VIA5_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA5_W_2 /2 + 0.005
}
#ENDIF  // LmarkSealringCorner
VIA5.S.1 { @ Space >= 0.220 
  EXT VIA5 < VIA5_S_1 ABUT < 90 SINGULAR REGION
}
VIA5.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA5Merge = SIZE VIA5 BY VIA5_S_2_S / 2 OVERUNDER  // space <= VIA5_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA5_W_1 + ( 3 - 2 ) * VIA5_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA5Merge BY ( ( 3 - 1 ) * VIA5_W_1 + ( 3 - 2 ) * VIA5_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA5Array = MinArray INTERACT VIA5 >= 3 * 3
  VIA5InArray = VIA5 INTERACT VIA5Array
  EXT VIA5InArray < VIA5_S_2 ABUT < 90 REGION
}
VIA5.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA5 M5 < VIA5_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA5.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA5 M5 ABUT > 0 < 90 GOOD VIA5_EN_1 VIA5_EN_2 OPPOSITE VIA5_EN_1 VIA5_EN_2 OPPOSITE
  Y = ENC [X] M5 < VIA5_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA5_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA5.R.1 is checked by VIA5.W.1
#IFNDEF LK
VIA5.R.2_FSG { @ When M5 or M6 width > 1.4um, more than 1 VIA5 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M6OvpM5W = (M6 AND M5Wide1.4) OR (M5 AND M6Wide1.4)
  m5_has_wm_ovp = METAL5i INTERACT M6OvpM5W
  m6_has_wm_ovp = METAL6i INTERACT M6OvpM5W
  MOvp = m5_has_wm_ovp AND m6_has_wm_ovp 
  VIA_EXC = VIA5 NOT VIA_EXD
  M56Wide = M5Wide1.4 OR M6Wide1.4
  OvpOnM56W = MOvp NOT OUTSIDE M56Wide
  VIA_Check5 = VIA_EXC INTERACT OvpOnM56W 
  
  Merge1OnM56W = SIZE VIA_Check5 BY 0.71/2 INSIDE OF OvpOnM56W STEP 0.21*0.7
  badRegion1  = Merge1OnM56W INTERACT VIA_Check5 < 2
  GoodRegion1 = Merge1OnM56W OUTSIDE badRegion1
  Merge2OnM56W = SIZE Merge1OnM56W BY (1 - 0.71)/2 INSIDE OF OvpOnM56W STEP 0.21*0.7
  badRegion2  = Merge2OnM56W INTERACT VIA_Check5 < 4
  GoodRegion2 = Merge2OnM56W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check5 INTERACT GoodRegion) NOT OUTSIDE M56Wide
  M56Check = (M56Wide AND OvpOnM56W) NOT INTERACT GoodVIA
  VIA_Check5 NOT OUTSIDE M56Check 
}
#ENDIF  // LK

#ENDIF

#IFDEF THICK_TOP2_METAL

//TOP VIA6 CHECKS
//================

VIA6.W.1.THICK { @ Width (square) (maximum = minimum) = 0.36 
  A = NOT RECTANGLE VIA6 == VIA6_W_1 BY == VIA6_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA6.W.2.THICK { @ Width of VIA7 bar. VIA7 bar is only allowed in seal ring and fuse protection ring. 0.28  
  INT SR_V6 < VIA6_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  A = SIZE SR_V6 BY VIA6_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA6_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 2 0.005
}

VIA6.S.1.THICK { @ Space >= 0.35 
  EXT ( VIA6 NOT SR_V6 ) < VIA6_S_1 ABUT < 90 SINGULAR REGION
}
#ELSE
VIA6.W.2.THICK { @ Width of VIA7 bar. VIA7 bar is only allowed in seal ring and fuse protection ring. 0.28  
  INT SR_V6 < VIA6_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  SIZE SR_V6 BY VIA6_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA6_W_2 /2 + 0.005
}

VIA6.S.1.THICK { @ Space >= 0.35 
  EXT VIA6 < VIA6_S_1 ABUT < 90 SINGULAR REGION
}
#ENDIF // LmarkSealringCorner

VIA6.S.2.THICK { @ Space in VIA7 array [VIA7 number >= 3 X 3 (row and column >= 3) with space <= 0.56 um] >= 0.54 
  VIA6Merge = SIZE VIA6 BY VIA6_S_2_S / 2 OVERUNDER  // space <= VIA6_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA6_W_1 + ( 3 - 2 ) * VIA6_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA6Merge BY ( ( 3 - 1 ) * VIA6_W_1 + ( 3 - 2 ) * VIA6_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA6Array = MinArray INTERACT VIA6 >= 3 * 3
  VIA6InArray = VIA6 INTERACT VIA6Array
  EXT VIA6InArray < VIA6_S_2 ABUT < 90 REGION
}

#IFDEF THICK_TOP3_METAL

VIA6.EN.1.THICK { @ Enclosure of M6 >= 0.020 
  ENC VIA6 M6 < VIA6_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2.THICK { @ Enclosure of M6 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA6 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD VIA6_EN_1 VIA6_EN_2 OPPOSITE VIA6_EN_1 VIA6_EN_2 OPPOSITE
  ENC A M6 < VIA6_EN_2_A ABUT < 90 SINGULAR REGION
}

#ELSE

VIA6.EN.1.THICK { @ Enclosure by M6 >= 0.01
  ENC VIA6 M6 < VIA6_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2.THICK { @ Enclosure by M6 (at least two opposite sides) >= 0.05
  X = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD VIA6_EN_1 VIA6_EN_2 OPPOSITE VIA6_EN_1 VIA6_EN_2 OPPOSITE
  Y = ENC [X] M6 < VIA6_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA6_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF

// VIA6.R.1 is checked by VIA6.W.1

VIA6.R.2.THICK { @ At least 2 VIA6, with space <=1.7um, are required to connect M6 and M7, 
	@ if either M6 or M7 has both width and length >1.8um. 
  M7OvpM6W = (M7 AND M6Wide1.8) OR (M6 AND M7Wide1.8)
  m6_has_wm_ovp = METAL6i INTERACT M7OvpM6W
  m7_has_wm_ovp = METAL7i INTERACT M7OvpM6W
  MOvp = m6_has_wm_ovp AND m7_has_wm_ovp 
  VIA_EXC = VIA6 NOT VIA_EXD
  M67Wide = M6Wide1.8 OR M7Wide1.8
  OvpOnM67W = MOvp NOT OUTSIDE M67Wide
  VIA_Check6 = VIA_EXC INTERACT OvpOnM67W 
  
  Merge1OnM67W = SIZE VIA_Check6 BY 1.7/2 INSIDE OF OvpOnM67W STEP 0.42*0.7
  badRegion1  = Merge1OnM67W INTERACT VIA_Check6 < 2
  GoodRegion1 = Merge1OnM67W OUTSIDE badRegion1
  GoodVIA6 = (VIA_Check6 INTERACT GoodRegion1) NOT OUTSIDE M67Wide
  M67Check = (M67Wide AND OvpOnM67W) NOT INTERACT GoodVIA6
  VIA_Check6 NOT OUTSIDE M67Check 
}    

#ELSE
#IFDEF THICK_TOP3_METAL

//TOP VIA6 CHECKS
//================

VIA6.W.1.THICK { @ Width (square) (maximum = minimum) = 0.36 
  A = NOT RECTANGLE VIA6 == VIA6_W_1 BY == VIA6_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA6.W.2.THICK { @ Width of VIA7 bar. VIA7 bar is only allowed in seal ring and fuse protection ring. 0.28  
  INT SR_V6 < VIA6_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  A = SIZE SR_V6 BY VIA6_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA6_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 2 0.005
}

VIA6.S.1.THICK { @ Space >= 0.35 
  EXT ( VIA6 NOT SR_V6 ) < VIA6_S_1 ABUT < 90 SINGULAR REGION
}
#ELSE
VIA6.W.2.THICK { @ Width of VIA7 bar. VIA7 bar is only allowed in seal ring and fuse protection ring. 0.28  
  INT SR_V6 < VIA6_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  SIZE SR_V6 BY VIA6_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA6_W_2 /2 + 0.005
}

VIA6.S.1.THICK { @ Space >= 0.35 
  EXT VIA6 < VIA6_S_1 ABUT < 90 SINGULAR REGION
}
#ENDIF // LmarkSealringCorner

VIA6.S.2.THICK { @ Space in VIA7 array [VIA7 number >= 3 X 3 (row and column >= 3) with space <= 0.56 um] >= 0.54 
  VIA6Merge = SIZE VIA6 BY VIA6_S_2_S / 2 OVERUNDER  // space <= VIA6_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA6_W_1 + ( 3 - 2 ) * VIA6_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA6Merge BY ( ( 3 - 1 ) * VIA6_W_1 + ( 3 - 2 ) * VIA6_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA6Array = MinArray INTERACT VIA6 >= 3 * 3
  VIA6InArray = VIA6 INTERACT VIA6Array
  EXT VIA6InArray < VIA6_S_2 ABUT < 90 REGION
}

#IFDEF THICK_TOP3_METAL

VIA6.EN.1.THICK { @ Enclosure of M6 >= 0.020 
  ENC VIA6 M6 < VIA6_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2.THICK { @ Enclosure of M6 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA6 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD VIA6_EN_1 VIA6_EN_2 OPPOSITE VIA6_EN_1 VIA6_EN_2 OPPOSITE
  ENC A M6 < VIA6_EN_2_A ABUT < 90 SINGULAR REGION
}

#ELSE

VIA6.EN.1.THICK { @ Enclosure by M6 >= 0.01
  ENC VIA6 M6 < VIA6_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2.THICK { @ Enclosure by M6 (at least two opposite sides) >= 0.05
  X = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD VIA6_EN_1 VIA6_EN_2 OPPOSITE VIA6_EN_1 VIA6_EN_2 OPPOSITE
  Y = ENC [X] M6 < VIA6_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA6_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF

// VIA6.R.1 is checked by VIA6.W.1

VIA6.R.2.THICK { @ At least 2 VIA6, with space <=1.7um, are required to connect M6 and M7, 
	@ if either M6 or M7 has both width and length >1.8um. 
  M7OvpM6W = (M7 AND M6Wide1.8) OR (M6 AND M7Wide1.8)
  m6_has_wm_ovp = METAL6i INTERACT M7OvpM6W
  m7_has_wm_ovp = METAL7i INTERACT M7OvpM6W
  MOvp = m6_has_wm_ovp AND m7_has_wm_ovp 
  VIA_EXC = VIA6 NOT VIA_EXD
  M67Wide = M6Wide1.8 OR M7Wide1.8
  OvpOnM67W = MOvp NOT OUTSIDE M67Wide
  VIA_Check6 = VIA_EXC INTERACT OvpOnM67W 
  
  Merge1OnM67W = SIZE VIA_Check6 BY 1.7/2 INSIDE OF OvpOnM67W STEP 0.42*0.7
  badRegion1  = Merge1OnM67W INTERACT VIA_Check6 < 2
  GoodRegion1 = Merge1OnM67W OUTSIDE badRegion1
  GoodVIA6 = (VIA_Check6 INTERACT GoodRegion1) NOT OUTSIDE M67Wide
  M67Check = (M67Wide AND OvpOnM67W) NOT INTERACT GoodVIA6
  VIA_Check6 NOT OUTSIDE M67Check 
}    

#ELSE


//VIA6 CHECKS
//===========

VIA6.W.1 { @ Width (square) (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA6 == VIA6_W_1 BY == VIA6_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA6.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V6 < VIA6_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_V6 BY VIA6_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA6_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA6.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal ring and fuse protection ring. VIAx bar is only allowed in seal ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must if VIAx bar is used. 0.13  
  INT SR_V6 < VIA6_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_V6 BY VIA6_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA6_W_2 /2 + 0.005
}
#ENDIF  // LmarkSealringCorner
VIA6.S.1 { @ Space >= 0.220 
  EXT VIA6 < VIA6_S_1 ABUT < 90 SINGULAR REGION
}
VIA6.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA6Merge = SIZE VIA6 BY VIA6_S_2_S / 2 OVERUNDER  // space <= VIA6_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA6_W_1 + ( 3 - 2 ) * VIA6_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA6Merge BY ( ( 3 - 1 ) * VIA6_W_1 + ( 3 - 2 ) * VIA6_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA6Array = MinArray INTERACT VIA6 >= 3 * 3
  VIA6InArray = VIA6 INTERACT VIA6Array
  EXT VIA6InArray < VIA6_S_2 ABUT < 90 REGION
}
VIA6.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA6 M6 < VIA6_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD VIA6_EN_1 VIA6_EN_2 OPPOSITE VIA6_EN_1 VIA6_EN_2 OPPOSITE
  Y = ENC [X] M6 < VIA6_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA6_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA6.R.1 is checked by VIA6.W.1
#IFNDEF LK
VIA6.R.2_FSG { @ When M6 or M7 width > 1.4um, more than 1 VIA6 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M7OvpM6W = (M7 AND M6Wide1.4) OR (M6 AND M7Wide1.4)
  m6_has_wm_ovp = METAL6i INTERACT M7OvpM6W
  m7_has_wm_ovp = METAL7i INTERACT M7OvpM6W
  MOvp = m6_has_wm_ovp AND m7_has_wm_ovp 
  VIA_EXC = VIA6 NOT VIA_EXD
  M67Wide = M6Wide1.4 OR M7Wide1.4
  OvpOnM67W = MOvp NOT OUTSIDE M67Wide
  VIA_Check6 = VIA_EXC INTERACT OvpOnM67W 
  
  Merge1OnM67W = SIZE VIA_Check6 BY 0.71/2 INSIDE OF OvpOnM67W STEP 0.21*0.7
  badRegion1  = Merge1OnM67W INTERACT VIA_Check6 < 2
  GoodRegion1 = Merge1OnM67W OUTSIDE badRegion1
  Merge2OnM67W = SIZE Merge1OnM67W BY (1 - 0.71)/2 INSIDE OF OvpOnM67W STEP 0.21*0.7
  badRegion2  = Merge2OnM67W INTERACT VIA_Check6 < 4
  GoodRegion2 = Merge2OnM67W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check6 INTERACT GoodRegion) NOT OUTSIDE M67Wide
  M67Check = (M67Wide AND OvpOnM67W) NOT INTERACT GoodVIA
  VIA_Check6 NOT OUTSIDE M67Check 
}
#ENDIF  // LK

#ENDIF
#ENDIF



//TOP VIA7 CHECKS
//================

VIA7.W.1.THICK { @ Width (square) (maximum = minimum) = 0.36 
  A = NOT RECTANGLE VIA7 == VIA7_W_1 BY == VIA7_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA7.W.2.THICK { @ Width of VIA7 bar. VIA7 bar is only allowed in seal ring and fuse protection ring. 0.28  
  INT SR_V7 < VIA7_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  A = SIZE SR_V7 BY VIA7_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA7_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 2 0.005
}

VIA7.S.1.THICK { @ Space >= 0.35 
  EXT ( VIA7 NOT SR_V7 ) < VIA7_S_1 ABUT < 90 SINGULAR REGION
}
#ELSE
VIA7.W.2.THICK { @ Width of VIA7 bar. VIA7 bar is only allowed in seal ring and fuse protection ring. 0.28  
  INT SR_V7 < VIA7_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  SIZE SR_V7 BY VIA7_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIA7_W_2 /2 + 0.005
}

VIA7.S.1.THICK { @ Space >= 0.35 
  EXT VIA7 < VIA7_S_1 ABUT < 90 SINGULAR REGION
}
#ENDIF // LmarkSealringCorner

VIA7.S.2.THICK { @ Space in VIA7 array [VIA7 number >= 3 X 3 (row and column >= 3) with space <= 0.56 um] >= 0.54 
  VIA7Merge = SIZE VIA7 BY VIA7_S_2_S / 2 OVERUNDER  // space <= VIA7_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIA7_W_1 + ( 3 - 2 ) * VIA7_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIA7Merge BY ( ( 3 - 1 ) * VIA7_W_1 + ( 3 - 2 ) * VIA7_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA7Array = MinArray INTERACT VIA7 >= 3 * 3
  VIA7InArray = VIA7 INTERACT VIA7Array
  EXT VIA7InArray < VIA7_S_2 ABUT < 90 REGION
}

#IFDEF THICK_TOP2_METAL

VIA7.EN.1.THICK { @ Enclosure of M7 >= 0.020
  ENC VIA7 M7 < VIA7_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA7.EN.2.THICK { @ Enclosure of M7 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA7 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA7 M7 ABUT > 0 < 90 GOOD VIA7_EN_1 VIA7_EN_2 OPPOSITE VIA7_EN_1 VIA7_EN_2 OPPOSITE
  ENC A M7 < VIA7_EN_2_A ABUT < 90 SINGULAR REGION
}

#ELSE

#IFDEF THICK_TOP3_METAL

VIA7.EN.1.THICK { @ Enclosure of M7 >= 0.020 
  ENC VIA7 M7 < VIA7_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA7.EN.2.THICK { @ Enclosure of M7 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA7 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA7 M7 ABUT > 0 < 90 GOOD VIA7_EN_1 VIA7_EN_2 OPPOSITE VIA7_EN_1 VIA7_EN_2 OPPOSITE
  ENC A M7 < VIA7_EN_2_A ABUT < 90 SINGULAR REGION
}

#ELSE

VIA7.EN.1.THICK { @ Enclosure by M7 >= 0.01
  ENC VIA7 M7 < VIA7_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA7.EN.2.THICK { @ Enclosure by M7 (at least two opposite sides) >= 0.05
  X = RECTANGLE ENCLOSURE VIA7 M7 ABUT > 0 < 90 GOOD VIA7_EN_1 VIA7_EN_2 OPPOSITE VIA7_EN_1 VIA7_EN_2 OPPOSITE
  Y = ENC [X] M7 < VIA7_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA7_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF
#ENDIF

// VIA7.R.1 is checked by VIA7.W.1

VIA7.R.2.THICK { @ At least 2 VIA7, with space <=1.7um, are required to connect M7 and M8, 
	@ if either M7 or M8 has both width and length >1.8um. 
  M8OvpM7W = (M8 AND M7Wide1.8) OR (M7 AND M8Wide1.8)
  m7_has_wm_ovp = METAL7i INTERACT M8OvpM7W
  m8_has_wm_ovp = METAL8i INTERACT M8OvpM7W
  MOvp = m7_has_wm_ovp AND m8_has_wm_ovp 
  VIA_EXC = VIA7 NOT VIA_EXD
  M78Wide = M7Wide1.8 OR M8Wide1.8
  OvpOnM78W = MOvp NOT OUTSIDE M78Wide
  VIA_Check7 = VIA_EXC INTERACT OvpOnM78W 
  
  Merge1OnM78W = SIZE VIA_Check7 BY 1.7/2 INSIDE OF OvpOnM78W STEP 0.42*0.7
  badRegion1  = Merge1OnM78W INTERACT VIA_Check7 < 2
  GoodRegion1 = Merge1OnM78W OUTSIDE badRegion1
  GoodVIA7 = (VIA_Check7 INTERACT GoodRegion1) NOT OUTSIDE M78Wide
  M78Check = (M78Wide AND OvpOnM78W) NOT INTERACT GoodVIA7
  VIA_Check7 NOT OUTSIDE M78Check 
}    


//THICK M8 CHECKS
//=============


M8.W.1.THICK { @ Width >= 0.400 
  INT M8 < M8_W_1 ABUT < 90 SINGULAR REGION
}
M8.S.1.THICK { @ Space >= 0.420 
  EXT M8 < M8_S_1 ABUT < 90 SINGULAR REGION
}
M8.S.2.THICK { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M8_S5 = SHRINK (SHRINK (SHRINK (SHRINK M8Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M8_G5 = GROW (GROW (GROW (GROW M8_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M8_Wide = M8_G5 AND M8
  M8_Exp = SIZE M8_Wide BY M8_S_2_B INSIDE OF M8 STEP M8_S_1 * 0.7
  M8_Branch = M8_Exp NOT M8_Wide
  M8_Branch_edge = M8_Branch COIN INSIDE EDGE M8
  M8_Check = M8 AND (SIZE M8_Exp BY M8_S_2)
  M8_Branch_Check = M8 AND (EXPAND EDGE M8_Branch_edge OUTSIDE BY M8_S_2 CORNER FILL)
  M8_WideC = STAMP M8_Wide BY M8x
  M8_CheckC = STAMP M8_Check BY M8x
  M8_BranchC = STAMP M8_Branch BY M8x
  M8_Branch_CheckC = STAMP M8_Branch_Check BY M8x
  EXT M8_WideC M8_CheckC < M8_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M8_BranchC M8_Branch_CheckC < M8_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M8.EN.1.THICK { @ Enclosure of VIA7 >= 0.020 
  ENC VIA7 M8 < M8_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
M8.EN.2.THICK { @ Enclosure of VIA7 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA7 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA7 M8 ABUT > 0 < 90 GOOD M8_EN_1 M8_EN_2 OPPOSITE M8_EN_1 M8_EN_2 OPPOSITE
  ENC A M8 < M8_EN_2_A ABUT < 90 SINGULAR REGION
}
M8.A.1.THICK { @ Area >= 0.562 
  AREA M8 < M8_A_1
}
M8.A.2.THICK { @ Enclosed area >= 0.565 
  HOLES M8 < M8_A_2 INNER
}  



#IFDEF LK
M1Wide0.85 = (SIZE M1 BY 0.85/2 UNDEROVER TRUNCATE 0.85/2) AND M1
M1Trunk2_2 = (SIZE M1Wide0.85 BY 2/2 UNDEROVER TRUNCATE 2/2) AND M1
M1Tree2_2 = M1 INTERACT M1Trunk2_2
M1Wide2.5 = (SIZE M1Trunk2_2 BY 2.5/2 UNDEROVER TRUNCATE 2.5/2) AND M1
M1Trunk2.5_20 = ENCLOSE RECTANGLE M1Wide2.5 2.5 20.005
M1Tree2.5_20 = M1 INTERACT M1Trunk2.5_20


// VIA1 CHECKS
//=============

M2Wide0.85 = (SIZE M2 BY 0.85/2 UNDEROVER TRUNCATE 0.85/2) AND M2
M2Trunk2_2 = (SIZE M2Wide0.85 BY 2/2 UNDEROVER TRUNCATE 2/2) AND M2
M2Tree2_2 = M2 INTERACT M2Trunk2_2
M2Wide2.5 = (SIZE M2Trunk2_2 BY 2.5/2 UNDEROVER TRUNCATE 2.5/2) AND M2
M2Trunk2.5_20 = ENCLOSE RECTANGLE M2Wide2.5 2.5 20.005
M2Tree2.5_20 = M2 INTERACT M2Trunk2.5_20

VIA1.R.2_LK { @ When M1 or M2 width > 0.85um, more than 1 VIA1 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M2OvpM1W = (M2 AND M1Wide0.85) OR (M1 AND M2Wide0.85)
  m1_has_wm_ovp = METAL1i INTERACT M2OvpM1W
  m2_has_wm_ovp = METAL2i INTERACT M2OvpM1W
  MOvp = m1_has_wm_ovp AND m2_has_wm_ovp 
  VIA_EXC = VIA1 NOT VIA_EXD
  M12Wide = M1Wide0.85 OR M2Wide0.85
  OvpOnM12W = MOvp NOT OUTSIDE M12Wide
  VIA_Check1 = VIA_EXC INTERACT OvpOnM12W 
  
  Merge1OnM12W = SIZE VIA_Check1 BY 0.71/2 INSIDE OF OvpOnM12W STEP 0.21*0.7
  badRegion1  = Merge1OnM12W INTERACT VIA_Check1 < 2
  GoodRegion1 = Merge1OnM12W OUTSIDE badRegion1
  Merge2OnM12W = SIZE Merge1OnM12W BY (1 - 0.71)/2 INSIDE OF OvpOnM12W STEP 0.21*0.7
  badRegion2  = Merge2OnM12W INTERACT VIA_Check1 < 4
  GoodRegion2 = Merge2OnM12W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check1 INTERACT GoodRegion) NOT OUTSIDE M12Wide
  M12Check = (M12Wide AND OvpOnM12W) NOT INTERACT GoodVIA
  VIA_Check1 NOT OUTSIDE M12Check 
}    

VIA1.R.2.1_LK.M1 { @ More than one VIA1 are required on the M1 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M1Tree2.5_20 NOT M1Trunk2.5_20) INTERACT VIA1
  Check_Edge = M_Branch COIN OUTSIDE EDGE M1Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M2
  Bad_Branch = Check_Branch INTERACT VIA1 == 1
  M_Ovlp = ((M1Tree2.5_20 AND M2) INTERACT Bad_Branch) INTERACT VIA1 == 1
  (VIA1 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA1.R.2.1_LK.M2 { @ More than one VIA1 are required on the M2 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M2Tree2.5_20 NOT M2Trunk2.5_20) INTERACT VIA1
  Check_Edge = M_Branch COIN OUTSIDE EDGE M2Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M1
  Bad_Branch = Check_Branch INTERACT VIA1 == 1
  M_Ovlp = ((M2Tree2.5_20 AND M1) INTERACT Bad_Branch) INTERACT VIA1 == 1
  (VIA1 INTERACT M_Ovlp) NOT VIA_EXD
}  

VIA1.R.2.2_LK.M1 { @ More than one VIA1 are required on the M1 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M1Tree2_2 NOT M1Trunk2_2) INTERACT VIA1
  Check_Edge = M_Branch COIN OUTSIDE EDGE M1Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M2
  Bad_Branch = Check_Branch INTERACT VIA1 == 1
  M_Ovlp = ((M1Tree2_2 AND M2) INTERACT Bad_Branch) INTERACT VIA1 == 1
  (VIA1 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA1.R.2.2_LK.M2 { @ More than one VIA1 are required on the M2 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M2Tree2_2 NOT M2Trunk2_2) INTERACT VIA1
  Check_Edge = M_Branch COIN OUTSIDE EDGE M2Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M1
  Bad_Branch = Check_Branch INTERACT VIA1 == 1
  M_Ovlp = ((M2Tree2_2 AND M1) INTERACT Bad_Branch) INTERACT VIA1 == 1
  (VIA1 INTERACT M_Ovlp) NOT VIA_EXD
}  


// VIA2 CHECKS
//=============

M3Wide0.85 = (SIZE M3 BY 0.85/2 UNDEROVER TRUNCATE 0.85/2) AND M3
M3Trunk2_2 = (SIZE M3Wide0.85 BY 2/2 UNDEROVER TRUNCATE 2/2) AND M3
M3Tree2_2 = M3 INTERACT M3Trunk2_2
M3Wide2.5 = (SIZE M3Trunk2_2 BY 2.5/2 UNDEROVER TRUNCATE 2.5/2) AND M3
M3Trunk2.5_20 = ENCLOSE RECTANGLE M3Wide2.5 2.5 20.005
M3Tree2.5_20 = M3 INTERACT M3Trunk2.5_20

VIA2.R.2_LK { @ When M2 or M3 width > 0.85um, more than 1 VIA2 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M3OvpM2W = (M3 AND M2Wide0.85) OR (M2 AND M3Wide0.85)
  m2_has_wm_ovp = METAL2i INTERACT M3OvpM2W
  m3_has_wm_ovp = METAL3i INTERACT M3OvpM2W
  MOvp = m2_has_wm_ovp AND m3_has_wm_ovp 
  VIA_EXC = VIA2 NOT VIA_EXD
  M23Wide = M2Wide0.85 OR M3Wide0.85
  OvpOnM23W = MOvp NOT OUTSIDE M23Wide
  VIA_Check2 = VIA_EXC INTERACT OvpOnM23W 
  
  Merge1OnM23W = SIZE VIA_Check2 BY 0.71/2 INSIDE OF OvpOnM23W STEP 0.21*0.7
  badRegion1  = Merge1OnM23W INTERACT VIA_Check2 < 2
  GoodRegion1 = Merge1OnM23W OUTSIDE badRegion1
  Merge2OnM23W = SIZE Merge1OnM23W BY (1 - 0.71)/2 INSIDE OF OvpOnM23W STEP 0.21*0.7
  badRegion2  = Merge2OnM23W INTERACT VIA_Check2 < 4
  GoodRegion2 = Merge2OnM23W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check2 INTERACT GoodRegion) NOT OUTSIDE M23Wide
  M23Check = (M23Wide AND OvpOnM23W) NOT INTERACT GoodVIA
  VIA_Check2 NOT OUTSIDE M23Check 
}    

VIA2.R.2.1_LK.M2 { @ More than one VIA2 are required on the M2 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M2Tree2.5_20 NOT M2Trunk2.5_20) INTERACT VIA2
  Check_Edge = M_Branch COIN OUTSIDE EDGE M2Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M3
  Bad_Branch = Check_Branch INTERACT VIA2 == 1
  M_Ovlp = ((M2Tree2.5_20 AND M3) INTERACT Bad_Branch) INTERACT VIA2 == 1
  (VIA2 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA2.R.2.1_LK.M3 { @ More than one VIA2 are required on the M3 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M3Tree2.5_20 NOT M3Trunk2.5_20) INTERACT VIA2
  Check_Edge = M_Branch COIN OUTSIDE EDGE M3Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M2
  Bad_Branch = Check_Branch INTERACT VIA2 == 1
  M_Ovlp = ((M3Tree2.5_20 AND M2) INTERACT Bad_Branch) INTERACT VIA2 == 1
  (VIA2 INTERACT M_Ovlp) NOT VIA_EXD
}  

VIA2.R.2.2_LK.M2 { @ More than one VIA2 are required on the M2 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M2Tree2_2 NOT M2Trunk2_2) INTERACT VIA2
  Check_Edge = M_Branch COIN OUTSIDE EDGE M2Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M3
  Bad_Branch = Check_Branch INTERACT VIA2 == 1
  M_Ovlp = ((M2Tree2_2 AND M3) INTERACT Bad_Branch) INTERACT VIA2 == 1
  (VIA2 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA2.R.2.2_LK.M3 { @ More than one VIA2 are required on the M3 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M3Tree2_2 NOT M3Trunk2_2) INTERACT VIA2
  Check_Edge = M_Branch COIN OUTSIDE EDGE M3Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M2
  Bad_Branch = Check_Branch INTERACT VIA2 == 1
  M_Ovlp = ((M3Tree2_2 AND M2) INTERACT Bad_Branch) INTERACT VIA2 == 1
  (VIA2 INTERACT M_Ovlp) NOT VIA_EXD
}  


// VIA3 CHECKS
//=============

M4Wide0.85 = (SIZE M4 BY 0.85/2 UNDEROVER TRUNCATE 0.85/2) AND M4
M4Trunk2_2 = (SIZE M4Wide0.85 BY 2/2 UNDEROVER TRUNCATE 2/2) AND M4
M4Tree2_2 = M4 INTERACT M4Trunk2_2
M4Wide2.5 = (SIZE M4Trunk2_2 BY 2.5/2 UNDEROVER TRUNCATE 2.5/2) AND M4
M4Trunk2.5_20 = ENCLOSE RECTANGLE M4Wide2.5 2.5 20.005
M4Tree2.5_20 = M4 INTERACT M4Trunk2.5_20

VIA3.R.2_LK { @ When M3 or M4 width > 0.85um, more than 1 VIA3 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M4OvpM3W = (M4 AND M3Wide0.85) OR (M3 AND M4Wide0.85)
  m3_has_wm_ovp = METAL3i INTERACT M4OvpM3W
  m4_has_wm_ovp = METAL4i INTERACT M4OvpM3W
  MOvp = m3_has_wm_ovp AND m4_has_wm_ovp 
  VIA_EXC = VIA3 NOT VIA_EXD
  M34Wide = M3Wide0.85 OR M4Wide0.85
  OvpOnM34W = MOvp NOT OUTSIDE M34Wide
  VIA_Check3 = VIA_EXC INTERACT OvpOnM34W 
  
  Merge1OnM34W = SIZE VIA_Check3 BY 0.71/2 INSIDE OF OvpOnM34W STEP 0.21*0.7
  badRegion1  = Merge1OnM34W INTERACT VIA_Check3 < 2
  GoodRegion1 = Merge1OnM34W OUTSIDE badRegion1
  Merge2OnM34W = SIZE Merge1OnM34W BY (1 - 0.71)/2 INSIDE OF OvpOnM34W STEP 0.21*0.7
  badRegion2  = Merge2OnM34W INTERACT VIA_Check3 < 4
  GoodRegion2 = Merge2OnM34W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check3 INTERACT GoodRegion) NOT OUTSIDE M34Wide
  M34Check = (M34Wide AND OvpOnM34W) NOT INTERACT GoodVIA
  VIA_Check3 NOT OUTSIDE M34Check 
}    

VIA3.R.2.1_LK.M3 { @ More than one VIA3 are required on the M3 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M3Tree2.5_20 NOT M3Trunk2.5_20) INTERACT VIA3
  Check_Edge = M_Branch COIN OUTSIDE EDGE M3Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M4
  Bad_Branch = Check_Branch INTERACT VIA3 == 1
  M_Ovlp = ((M3Tree2.5_20 AND M4) INTERACT Bad_Branch) INTERACT VIA3 == 1
  (VIA3 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA3.R.2.1_LK.M4 { @ More than one VIA3 are required on the M4 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M4Tree2.5_20 NOT M4Trunk2.5_20) INTERACT VIA3
  Check_Edge = M_Branch COIN OUTSIDE EDGE M4Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M3
  Bad_Branch = Check_Branch INTERACT VIA3 == 1
  M_Ovlp = ((M4Tree2.5_20 AND M3) INTERACT Bad_Branch) INTERACT VIA3 == 1
  (VIA3 INTERACT M_Ovlp) NOT VIA_EXD
}  

VIA3.R.2.2_LK.M3 { @ More than one VIA3 are required on the M3 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M3Tree2_2 NOT M3Trunk2_2) INTERACT VIA3
  Check_Edge = M_Branch COIN OUTSIDE EDGE M3Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M4
  Bad_Branch = Check_Branch INTERACT VIA3 == 1
  M_Ovlp = ((M3Tree2_2 AND M4) INTERACT Bad_Branch) INTERACT VIA3 == 1
  (VIA3 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA3.R.2.2_LK.M4 { @ More than one VIA3 are required on the M4 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M4Tree2_2 NOT M4Trunk2_2) INTERACT VIA3
  Check_Edge = M_Branch COIN OUTSIDE EDGE M4Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M3
  Bad_Branch = Check_Branch INTERACT VIA3 == 1
  M_Ovlp = ((M4Tree2_2 AND M3) INTERACT Bad_Branch) INTERACT VIA3 == 1
  (VIA3 INTERACT M_Ovlp) NOT VIA_EXD
}  


// VIA4 CHECKS
//=============

M5Wide0.85 = (SIZE M5 BY 0.85/2 UNDEROVER TRUNCATE 0.85/2) AND M5
M5Trunk2_2 = (SIZE M5Wide0.85 BY 2/2 UNDEROVER TRUNCATE 2/2) AND M5
M5Tree2_2 = M5 INTERACT M5Trunk2_2
M5Wide2.5 = (SIZE M5Trunk2_2 BY 2.5/2 UNDEROVER TRUNCATE 2.5/2) AND M5
M5Trunk2.5_20 = ENCLOSE RECTANGLE M5Wide2.5 2.5 20.005
M5Tree2.5_20 = M5 INTERACT M5Trunk2.5_20

VIA4.R.2_LK { @ When M4 or M5 width > 0.85um, more than 1 VIA4 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M5OvpM4W = (M5 AND M4Wide0.85) OR (M4 AND M5Wide0.85)
  m4_has_wm_ovp = METAL4i INTERACT M5OvpM4W
  m5_has_wm_ovp = METAL5i INTERACT M5OvpM4W
  MOvp = m4_has_wm_ovp AND m5_has_wm_ovp 
  VIA_EXC = VIA4 NOT VIA_EXD
  M45Wide = M4Wide0.85 OR M5Wide0.85
  OvpOnM45W = MOvp NOT OUTSIDE M45Wide
  VIA_Check4 = VIA_EXC INTERACT OvpOnM45W 
  
  Merge1OnM45W = SIZE VIA_Check4 BY 0.71/2 INSIDE OF OvpOnM45W STEP 0.21*0.7
  badRegion1  = Merge1OnM45W INTERACT VIA_Check4 < 2
  GoodRegion1 = Merge1OnM45W OUTSIDE badRegion1
  Merge2OnM45W = SIZE Merge1OnM45W BY (1 - 0.71)/2 INSIDE OF OvpOnM45W STEP 0.21*0.7
  badRegion2  = Merge2OnM45W INTERACT VIA_Check4 < 4
  GoodRegion2 = Merge2OnM45W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check4 INTERACT GoodRegion) NOT OUTSIDE M45Wide
  M45Check = (M45Wide AND OvpOnM45W) NOT INTERACT GoodVIA
  VIA_Check4 NOT OUTSIDE M45Check 
}    

VIA4.R.2.1_LK.M4 { @ More than one VIA4 are required on the M4 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M4Tree2.5_20 NOT M4Trunk2.5_20) INTERACT VIA4
  Check_Edge = M_Branch COIN OUTSIDE EDGE M4Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M5
  Bad_Branch = Check_Branch INTERACT VIA4 == 1
  M_Ovlp = ((M4Tree2.5_20 AND M5) INTERACT Bad_Branch) INTERACT VIA4 == 1
  (VIA4 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA4.R.2.1_LK.M5 { @ More than one VIA4 are required on the M5 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M5Tree2.5_20 NOT M5Trunk2.5_20) INTERACT VIA4
  Check_Edge = M_Branch COIN OUTSIDE EDGE M5Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M4
  Bad_Branch = Check_Branch INTERACT VIA4 == 1
  M_Ovlp = ((M5Tree2.5_20 AND M4) INTERACT Bad_Branch) INTERACT VIA4 == 1
  (VIA4 INTERACT M_Ovlp) NOT VIA_EXD
}  

VIA4.R.2.2_LK.M4 { @ More than one VIA4 are required on the M4 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M4Tree2_2 NOT M4Trunk2_2) INTERACT VIA4
  Check_Edge = M_Branch COIN OUTSIDE EDGE M4Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M5
  Bad_Branch = Check_Branch INTERACT VIA4 == 1
  M_Ovlp = ((M4Tree2_2 AND M5) INTERACT Bad_Branch) INTERACT VIA4 == 1
  (VIA4 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA4.R.2.2_LK.M5 { @ More than one VIA4 are required on the M5 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M5Tree2_2 NOT M5Trunk2_2) INTERACT VIA4
  Check_Edge = M_Branch COIN OUTSIDE EDGE M5Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M4
  Bad_Branch = Check_Branch INTERACT VIA4 == 1
  M_Ovlp = ((M5Tree2_2 AND M4) INTERACT Bad_Branch) INTERACT VIA4 == 1
  (VIA4 INTERACT M_Ovlp) NOT VIA_EXD
}  

#IFNDEF THICK_TOP3_METAL

// VIA5 CHECKS
//=============

M6Wide0.85 = (SIZE M6 BY 0.85/2 UNDEROVER TRUNCATE 0.85/2) AND M6
M6Trunk2_2 = (SIZE M6Wide0.85 BY 2/2 UNDEROVER TRUNCATE 2/2) AND M6
M6Tree2_2 = M6 INTERACT M6Trunk2_2
M6Wide2.5 = (SIZE M6Trunk2_2 BY 2.5/2 UNDEROVER TRUNCATE 2.5/2) AND M6
M6Trunk2.5_20 = ENCLOSE RECTANGLE M6Wide2.5 2.5 20.005
M6Tree2.5_20 = M6 INTERACT M6Trunk2.5_20

VIA5.R.2_LK { @ When M5 or M6 width > 0.85um, more than 1 VIA5 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M6OvpM5W = (M6 AND M5Wide0.85) OR (M5 AND M6Wide0.85)
  m5_has_wm_ovp = METAL5i INTERACT M6OvpM5W
  m6_has_wm_ovp = METAL6i INTERACT M6OvpM5W
  MOvp = m5_has_wm_ovp AND m6_has_wm_ovp 
  VIA_EXC = VIA5 NOT VIA_EXD
  M56Wide = M5Wide0.85 OR M6Wide0.85
  OvpOnM56W = MOvp NOT OUTSIDE M56Wide
  VIA_Check5 = VIA_EXC INTERACT OvpOnM56W 
  
  Merge1OnM56W = SIZE VIA_Check5 BY 0.71/2 INSIDE OF OvpOnM56W STEP 0.21*0.7
  badRegion1  = Merge1OnM56W INTERACT VIA_Check5 < 2
  GoodRegion1 = Merge1OnM56W OUTSIDE badRegion1
  Merge2OnM56W = SIZE Merge1OnM56W BY (1 - 0.71)/2 INSIDE OF OvpOnM56W STEP 0.21*0.7
  badRegion2  = Merge2OnM56W INTERACT VIA_Check5 < 4
  GoodRegion2 = Merge2OnM56W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check5 INTERACT GoodRegion) NOT OUTSIDE M56Wide
  M56Check = (M56Wide AND OvpOnM56W) NOT INTERACT GoodVIA
  VIA_Check5 NOT OUTSIDE M56Check 
}    

VIA5.R.2.1_LK.M5 { @ More than one VIA5 are required on the M5 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M5Tree2.5_20 NOT M5Trunk2.5_20) INTERACT VIA5
  Check_Edge = M_Branch COIN OUTSIDE EDGE M5Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M6
  Bad_Branch = Check_Branch INTERACT VIA5 == 1
  M_Ovlp = ((M5Tree2.5_20 AND M6) INTERACT Bad_Branch) INTERACT VIA5 == 1
  (VIA5 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA5.R.2.1_LK.M6 { @ More than one VIA5 are required on the M6 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M6Tree2.5_20 NOT M6Trunk2.5_20) INTERACT VIA5
  Check_Edge = M_Branch COIN OUTSIDE EDGE M6Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M5
  Bad_Branch = Check_Branch INTERACT VIA5 == 1
  M_Ovlp = ((M6Tree2.5_20 AND M5) INTERACT Bad_Branch) INTERACT VIA5 == 1
  (VIA5 INTERACT M_Ovlp) NOT VIA_EXD
}  

VIA5.R.2.2_LK.M5 { @ More than one VIA5 are required on the M5 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M5Tree2_2 NOT M5Trunk2_2) INTERACT VIA5
  Check_Edge = M_Branch COIN OUTSIDE EDGE M5Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M6
  Bad_Branch = Check_Branch INTERACT VIA5 == 1
  M_Ovlp = ((M5Tree2_2 AND M6) INTERACT Bad_Branch) INTERACT VIA5 == 1
  (VIA5 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA5.R.2.2_LK.M6 { @ More than one VIA5 are required on the M6 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M6Tree2_2 NOT M6Trunk2_2) INTERACT VIA5
  Check_Edge = M_Branch COIN OUTSIDE EDGE M6Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M5
  Bad_Branch = Check_Branch INTERACT VIA5 == 1
  M_Ovlp = ((M6Tree2_2 AND M5) INTERACT Bad_Branch) INTERACT VIA5 == 1
  (VIA5 INTERACT M_Ovlp) NOT VIA_EXD
}  
#ENDIF

#IFNDEF THICK_TOP3_METAL
#IFNDEF THICK_TOP2_METAL

// VIA6 CHECKS
//=============

M7Wide0.85 = (SIZE M7 BY 0.85/2 UNDEROVER TRUNCATE 0.85/2) AND M7
M7Trunk2_2 = (SIZE M7Wide0.85 BY 2/2 UNDEROVER TRUNCATE 2/2) AND M7
M7Tree2_2 = M7 INTERACT M7Trunk2_2
M7Wide2.5 = (SIZE M7Trunk2_2 BY 2.5/2 UNDEROVER TRUNCATE 2.5/2) AND M7
M7Trunk2.5_20 = ENCLOSE RECTANGLE M7Wide2.5 2.5 20.005
M7Tree2.5_20 = M7 INTERACT M7Trunk2.5_20

VIA6.R.2_LK { @ When M6 or M7 width > 0.85um, more than 1 VIA6 is required.
           @ if the metal has < 4 vias, vias spacing should be <= 0.71um, 
  	   @ or if the metal has >=4 vias, at least 4 vias spacing should be <= 1um
  M7OvpM6W = (M7 AND M6Wide0.85) OR (M6 AND M7Wide0.85)
  m6_has_wm_ovp = METAL6i INTERACT M7OvpM6W
  m7_has_wm_ovp = METAL7i INTERACT M7OvpM6W
  MOvp = m6_has_wm_ovp AND m7_has_wm_ovp 
  VIA_EXC = VIA6 NOT VIA_EXD
  M67Wide = M6Wide0.85 OR M7Wide0.85
  OvpOnM67W = MOvp NOT OUTSIDE M67Wide
  VIA_Check6 = VIA_EXC INTERACT OvpOnM67W 
  
  Merge1OnM67W = SIZE VIA_Check6 BY 0.71/2 INSIDE OF OvpOnM67W STEP 0.21*0.7
  badRegion1  = Merge1OnM67W INTERACT VIA_Check6 < 2
  GoodRegion1 = Merge1OnM67W OUTSIDE badRegion1
  Merge2OnM67W = SIZE Merge1OnM67W BY (1 - 0.71)/2 INSIDE OF OvpOnM67W STEP 0.21*0.7
  badRegion2  = Merge2OnM67W INTERACT VIA_Check6 < 4
  GoodRegion2 = Merge2OnM67W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check6 INTERACT GoodRegion) NOT OUTSIDE M67Wide
  M67Check = (M67Wide AND OvpOnM67W) NOT INTERACT GoodVIA
  VIA_Check6 NOT OUTSIDE M67Check 
}    

VIA6.R.2.1_LK.M6 { @ More than one VIA6 are required on the M6 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M6Tree2.5_20 NOT M6Trunk2.5_20) INTERACT VIA6
  Check_Edge = M_Branch COIN OUTSIDE EDGE M6Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M7
  Bad_Branch = Check_Branch INTERACT VIA6 == 1
  M_Ovlp = ((M6Tree2.5_20 AND M7) INTERACT Bad_Branch) INTERACT VIA6 == 1
  (VIA6 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA6.R.2.1_LK.M7 { @ More than one VIA6 are required on the M7 (D1 < 5um) 
		@connected to wide metal(W1 > 2.5um, L1 > 20um)
  M_Branch = (M7Tree2.5_20 NOT M7Trunk2.5_20) INTERACT VIA6
  Check_Edge = M_Branch COIN OUTSIDE EDGE M7Trunk2.5_20
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 4.995 INSIDE OF M_Branch STEP 0.1) AND M6
  Bad_Branch = Check_Branch INTERACT VIA6 == 1
  M_Ovlp = ((M7Tree2.5_20 AND M6) INTERACT Bad_Branch) INTERACT VIA6 == 1
  (VIA6 INTERACT M_Ovlp) NOT VIA_EXD
}  

VIA6.R.2.2_LK.M6 { @ More than one VIA6 are required on the M6 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M6Tree2_2 NOT M6Trunk2_2) INTERACT VIA6
  Check_Edge = M_Branch COIN OUTSIDE EDGE M6Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M7
  Bad_Branch = Check_Branch INTERACT VIA6 == 1
  M_Ovlp = ((M6Tree2_2 AND M7) INTERACT Bad_Branch) INTERACT VIA6 == 1
  (VIA6 INTERACT M_Ovlp) NOT VIA_EXD
}  
VIA6.R.2.2_LK.M7 { @ More than one VIA6 are required on the M7 (D2 < 1um) 
		@connected to wide metal(W2 > 2um, L2 > 2um)
  M_Branch = (M7Tree2_2 NOT M7Trunk2_2) INTERACT VIA6
  Check_Edge = M_Branch COIN OUTSIDE EDGE M7Trunk2_2
  X = EXPAND EDGE Check_Edge OUTSIDE BY 0.005
  Check_Branch = (SIZE X BY 0.995 INSIDE OF M_Branch STEP 0.1) AND M6
  Bad_Branch = Check_Branch INTERACT VIA6 == 1
  M_Ovlp = ((M7Tree2_2 AND M6) INTERACT Bad_Branch) INTERACT VIA6 == 1
  (VIA6 INTERACT M_Ovlp) NOT VIA_EXD
}  
#ENDIF
#ENDIF

#ENDIF // LK


// VIAD CHECKS
//=============

VIAD.W.1 { @ VIAD.W.1 must be 0.36 x 0.36 
  A = NOT RECTANGLE VIAD == VIAD_W_1 BY == VIAD_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIAD.W.2 { @ Width of VIAn bar = ^VIAD_W_2 um. VIAn bar is only allowed in seal ring and fuse protection ring. 
  INT SR_VD < VIAD_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  A = SIZE SR_VD BY VIAD_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIAD_W_2 /2 + 0.005
  ENCLOSE RECTANGLE A 2 0.005
}
VIAD.S.1 { @ Space >= ^VIAD_S_1 um 
  EXT (VIAD NOT SR_VD) < VIAD_S_1 ABUT < 90 SINGULAR REGION
}
#ELSE
VIAD.W.2 { @ Width of VIAn bar = ^VIAD_W_2 um. VIAn bar is only allowed in seal ring and fuse protection ring.
  INT SR_VD < VIAD_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  SIZE SR_VD BY VIAD_W_2 /2 + 0.005 UNDEROVER TRUNCATE VIAD_W_2 /2 + 0.005
}
VIAD.S.1 { @ Space >= ^VIAD_S_1 um
  EXT VIAD < VIAD_S_1 ABUT < 90 SINGULAR REGION
}
#ENDIF
VIAD.S.2 { @ Space in VIAD array [VIAD number >=3X3(raw and column >=3) with space <=0.56um] >= 0.54
  VIADMerge = SIZE VIAD BY VIAD_S_2_S / 2 OVERUNDER  // space <= VIAD_S_2_S um treated as array
  // ( ( 3 - 1 ) * VIAD_W_1 + ( 3 - 2 ) * VIAD_S_2_S ) / 2 ) = MinArray
  MinArray = SIZE VIADMerge BY ( ( 3 - 1 ) * VIAD_W_1 + ( 3 - 2 ) * VIAD_S_2_S ) / 2 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIADArray = MinArray INTERACT VIAD >= 3 * 3
  VIADInArray = VIAD INTERACT VIADArray
  EXT VIADInArray < VIAD_S_2 ABUT < 90 REGION
}

VIAD.EN.1 { @ Enclosure of VIAD >= 0.020
  ENC VIAD M8 < VIAD_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIAD.EN.2 { @ Enclosure of VIAD [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIAD for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIAD M8 ABUT > 0 < 90 GOOD VIAD_EN_1 VIAD_EN_2 OPPOSITE VIAD_EN_1 VIAD_EN_2 OPPOSITE
  ENC A M8 < VIAD_EN_2_A ABUT < 90 SINGULAR REGION
}
MDWide1.8 = (SIZE MD BY 0.9 UNDEROVER TRUNCATE 0.9) AND MD

VIAD.R.2 { @ At least 2 VIAD, with space <=1.7um, are required to connect M8 and MD, 
	 @if either M8 or MD has both width and length >1.8um. 
  M9OvpM8W = (MD AND M8Wide1.8) OR (M8 AND MDWide1.8)
  m8_has_wm_ovp = METAL8i INTERACT M9OvpM8W
  m9_has_wm_ovp = MDi INTERACT M9OvpM8W
  MOvp = m8_has_wm_ovp AND m9_has_wm_ovp 
  VIA_EXC = VIAD NOT VIA_EXD
  M89Wide = M8Wide1.8 OR MDWide1.8
  OvpOnM89W = MOvp NOT OUTSIDE M89Wide
  VIAD_Check = VIA_EXC INTERACT OvpOnM89W 
  
  Merge1OnM89W = SIZE VIAD_Check BY 1.7/2 INSIDE OF OvpOnM89W STEP 0.42*0.7
  BadRegion1  = Merge1OnM89W INTERACT VIAD_Check < 2
  GoodRegion1 = Merge1OnM89W OUTSIDE BadRegion1
  GoodVIAD = (VIAD_Check INTERACT GoodRegion1) NOT OUTSIDE M89Wide
  M89Check = (M89Wide AND OvpOnM89W) NOT INTERACT GoodVIAD
  VIAD_Check NOT OUTSIDE M89Check
}

// MD CHECKS
//===========

MD.W.1 { @ Min. MD width 0.44 => 0.4 um 
  INT MD < MD_W_1 ABUT < 90 SINGULAR REGION
}
MD.S.1 { @ Min. MD spacing 0.46 => 0.42 um 
  EXT MD < MD_S_1 ABUT < 90 SINGULAR REGION
}
MD.S.2 { @ Min. MD wide metal rule 0.6um 
  MD_S5 = SHRINK (SHRINK (SHRINK (SHRINK MDWide1.8 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_G5 = GROW (GROW (GROW (GROW MD_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_Wide = MD_G5 AND MD
  MD_Exp = SIZE MD_Wide BY MD_S_2_B INSIDE OF MD STEP MD_S_1 * 0.7
  MD_Branch = MD_Exp NOT MD_Wide
  MD_Branch_edge = MD_Branch COIN INSIDE EDGE MD
  MD_Check = MD AND (SIZE MD_Exp BY MD_S_2)
  MD_Branch_Check = MD AND (EXPAND EDGE MD_Branch_edge OUTSIDE BY MD_S_2 CORNER FILL)
  MD_WideC = STAMP MD_Wide BY MDx
  MD_CheckC = STAMP MD_Check BY MDx
  MD_BranchC = STAMP MD_Branch BY MDx
  MD_Branch_CheckC = STAMP MD_Branch_Check BY MDx
  EXT MD_WideC MD_CheckC < MD_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT MD_BranchC MD_Branch_CheckC < MD_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
MD.EN.1 { @ Enclosure of VIAD >= 0.020 
  ENC VIAD MD < MD_EN_1 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
MD.EN.2 { @ Enclosure of VIAD [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA#- for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIAD MD ABUT > 0 < 90 GOOD MD_EN_1 MD_EN_2 OPPOSITE MD_EN_1 MD_EN_2 OPPOSITE
  ENC A MD < MD_EN_2_A ABUT < 90 SINGULAR REGION
}
MD.A.1 { @ Min. MD area region 0.562 
  AREA MD < MD_A_1
}
MD.A.2 { @ Min. MD enclosed area 0.565
  HOLES MD < MD_A_2 INNER
}

//METAL DENSITY RULES 
//===================


CHIPU10   = SIZE CHIP BY 10
CHIPU20   = SIZE CHIP BY 20
CHIPU30   = SIZE CHIP BY 30
CHIPU40   = SIZE CHIP BY 40
CHIPU50   = SIZE CHIP BY 50
CHIPU60   = SIZE CHIP BY 60
CHIPU70   = SIZE CHIP BY 70
CHIPU80   = SIZE CHIP BY 80
CHIPU90   = SIZE CHIP BY 90

CHIP_NOT_M_EXC = CHIP NOT METAL_DEN_EXC

M1_NOT_EXC      = ALL_M1 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM1EXCL= DM1EXCL NOT METAL_DEN_EXC
M1_AND_DM1EXCL  = ALL_M1 AND CHIP_AND_DM1EXCL

DM1.DN.2L { @ M1 local density range within DM1EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= ^DM1_DN_2L 
  ERR_WIN = DENSITY M1_AND_DM1EXCL CHIP_AND_DM1EXCL < DM1_DN_2L WINDOW 200 STEP 100 BACKUP PRINT DM1_DN_2L.density 
                         [ AREA(M1_AND_DM1EXCL)/AREA(CHIP_AND_DM1EXCL) ]
  AREA (ERR_WIN AND DM1EXCL) >= 10000			 
}
DM1.DN.2H { @ M1 local density range within DM1EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= ^DM1_DN_2H
  ERR_WIN = DENSITY M1_AND_DM1EXCL CHIP_AND_DM1EXCL > DM1_DN_2H WINDOW 200 STEP 100 BACKUP PRINT DM1_DN_2H.density 
                         [ AREA(M1_AND_DM1EXCL)/AREA(CHIP_AND_DM1EXCL) ]
  AREA (ERR_WIN AND DM1EXCL) >= 10000			 
}
#ELSE

M1.DN.1L { @ {M1 OR DM1} local density range over 200um x 200um area stepping 100um >= ^M1_DN_1L 
  D0 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP PRINT M1_DN_1L.density 
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
  AREA ERR1 >= 10000
  D1 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < M1_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}

M1.DN.1H { @ {M1 OR DM1} local density range over 200um x 200um area stepping 100um <= ^M1_DN_1H
    D0 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP PRINT M1_DN_1H.density 
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000 
    D1 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > M1_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}
#ENDIF


M2_NOT_EXC      = ALL_M2 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM2EXCL= DM2EXCL NOT METAL_DEN_EXC
M2_AND_DM2EXCL  = ALL_M2 AND CHIP_AND_DM2EXCL

DM2.DN.2L { @ M2 local density range within DM2EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= ^DM2_DN_2L 
  ERR_WIN = DENSITY M2_AND_DM2EXCL CHIP_AND_DM2EXCL < DM2_DN_2L WINDOW 200 STEP 100 BACKUP PRINT DM2_DN_2L.density 
                         [ AREA(M2_AND_DM2EXCL)/AREA(CHIP_AND_DM2EXCL) ]
  AREA (ERR_WIN AND DM2EXCL) >= 10000			 
}
DM2.DN.2H { @ M2 local density range within DM2EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= ^DM2_DN_2H
  ERR_WIN = DENSITY M2_AND_DM2EXCL CHIP_AND_DM2EXCL > DM2_DN_2H WINDOW 200 STEP 100 BACKUP PRINT DM2_DN_2H.density 
                         [ AREA(M2_AND_DM2EXCL)/AREA(CHIP_AND_DM2EXCL) ]
  AREA (ERR_WIN AND DM2EXCL) >= 10000			 
}
#ELSE

M2.DN.1L { @ {M2 OR DM2} local density range over 200um x 200um area stepping 100um >= ^M2_DN_1L 
  D0 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP PRINT M2_DN_1L.density 
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
  AREA ERR1 >= 10000
  D1 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < M2_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}

M2.DN.1H { @ {M2 OR DM2} local density range over 200um x 200um area stepping 100um <= ^M2_DN_1H
    D0 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP PRINT M2_DN_1H.density 
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000 
    D1 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > M2_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}
#ENDIF


M3_NOT_EXC      = ALL_M3 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM3EXCL= DM3EXCL NOT METAL_DEN_EXC
M3_AND_DM3EXCL  = ALL_M3 AND CHIP_AND_DM3EXCL

DM3.DN.2L { @ M3 local density range within DM3EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= ^DM3_DN_2L 
  ERR_WIN = DENSITY M3_AND_DM3EXCL CHIP_AND_DM3EXCL < DM3_DN_2L WINDOW 200 STEP 100 BACKUP PRINT DM3_DN_2L.density 
                         [ AREA(M3_AND_DM3EXCL)/AREA(CHIP_AND_DM3EXCL) ]
  AREA (ERR_WIN AND DM3EXCL) >= 10000			 
}
DM3.DN.2H { @ M3 local density range within DM3EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= ^DM3_DN_2H
  ERR_WIN = DENSITY M3_AND_DM3EXCL CHIP_AND_DM3EXCL > DM3_DN_2H WINDOW 200 STEP 100 BACKUP PRINT DM3_DN_2H.density 
                         [ AREA(M3_AND_DM3EXCL)/AREA(CHIP_AND_DM3EXCL) ]
  AREA (ERR_WIN AND DM3EXCL) >= 10000			 
}
#ELSE

M3.DN.1L { @ {M3 OR DM3} local density range over 200um x 200um area stepping 100um >= ^M3_DN_1L 
  D0 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP PRINT M3_DN_1L.density 
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
  AREA ERR1 >= 10000
  D1 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < M3_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}

M3.DN.1H { @ {M3 OR DM3} local density range over 200um x 200um area stepping 100um <= ^M3_DN_1H
    D0 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP PRINT M3_DN_1H.density 
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000 
    D1 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > M3_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}
#ENDIF


M4_NOT_EXC      = ALL_M4 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM4EXCL= DM4EXCL NOT METAL_DEN_EXC
M4_AND_DM4EXCL  = ALL_M4 AND CHIP_AND_DM4EXCL

DM4.DN.2L { @ M4 local density range within DM4EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= ^DM4_DN_2L 
  ERR_WIN = DENSITY M4_AND_DM4EXCL CHIP_AND_DM4EXCL < DM4_DN_2L WINDOW 200 STEP 100 BACKUP PRINT DM4_DN_2L.density 
                         [ AREA(M4_AND_DM4EXCL)/AREA(CHIP_AND_DM4EXCL) ]
  AREA (ERR_WIN AND DM4EXCL) >= 10000			 
}
DM4.DN.2H { @ M4 local density range within DM4EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= ^DM4_DN_2H
  ERR_WIN = DENSITY M4_AND_DM4EXCL CHIP_AND_DM4EXCL > DM4_DN_2H WINDOW 200 STEP 100 BACKUP PRINT DM4_DN_2H.density 
                         [ AREA(M4_AND_DM4EXCL)/AREA(CHIP_AND_DM4EXCL) ]
  AREA (ERR_WIN AND DM4EXCL) >= 10000			 
}
#ELSE

M4.DN.1L { @ {M4 OR DM4} local density range over 200um x 200um area stepping 100um >= ^M4_DN_1L 
  D0 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP PRINT M4_DN_1L.density 
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
  AREA ERR1 >= 10000
  D1 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < M4_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}

M4.DN.1H { @ {M4 OR DM4} local density range over 200um x 200um area stepping 100um <= ^M4_DN_1H
    D0 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP PRINT M4_DN_1H.density 
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000 
    D1 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > M4_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}
#ENDIF


M5_NOT_EXC      = ALL_M5 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM5EXCL= DM5EXCL NOT METAL_DEN_EXC
M5_AND_DM5EXCL  = ALL_M5 AND CHIP_AND_DM5EXCL

DM5.DN.2L { @ M5 local density range within DM5EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= ^DM5_DN_2L 
  ERR_WIN = DENSITY M5_AND_DM5EXCL CHIP_AND_DM5EXCL < DM5_DN_2L WINDOW 200 STEP 100 BACKUP PRINT DM5_DN_2L.density 
                         [ AREA(M5_AND_DM5EXCL)/AREA(CHIP_AND_DM5EXCL) ]
  AREA (ERR_WIN AND DM5EXCL) >= 10000			 
}
DM5.DN.2H { @ M5 local density range within DM5EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= ^DM5_DN_2H
  ERR_WIN = DENSITY M5_AND_DM5EXCL CHIP_AND_DM5EXCL > DM5_DN_2H WINDOW 200 STEP 100 BACKUP PRINT DM5_DN_2H.density 
                         [ AREA(M5_AND_DM5EXCL)/AREA(CHIP_AND_DM5EXCL) ]
  AREA (ERR_WIN AND DM5EXCL) >= 10000			 
}
#ELSE

M5.DN.1L { @ {M5 OR DM5} local density range over 200um x 200um area stepping 100um >= ^M5_DN_1L 
  D0 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP PRINT M5_DN_1L.density 
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
  AREA ERR1 >= 10000
  D1 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < M5_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}

M5.DN.1H { @ {M5 OR DM5} local density range over 200um x 200um area stepping 100um <= ^M5_DN_1H
    D0 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP PRINT M5_DN_1H.density 
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000 
    D1 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > M5_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}
#ENDIF


M6_NOT_EXC      = ALL_M6 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM6EXCL= DM6EXCL NOT METAL_DEN_EXC
M6_AND_DM6EXCL  = ALL_M6 AND CHIP_AND_DM6EXCL

DM6.DN.2L { @ M6 local density range within DM6EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= ^DM6_DN_2L 
  ERR_WIN = DENSITY M6_AND_DM6EXCL CHIP_AND_DM6EXCL < DM6_DN_2L WINDOW 200 STEP 100 BACKUP PRINT DM6_DN_2L.density 
                         [ AREA(M6_AND_DM6EXCL)/AREA(CHIP_AND_DM6EXCL) ]
  AREA (ERR_WIN AND DM6EXCL) >= 10000			 
}
DM6.DN.2H { @ M6 local density range within DM6EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= ^DM6_DN_2H
  ERR_WIN = DENSITY M6_AND_DM6EXCL CHIP_AND_DM6EXCL > DM6_DN_2H WINDOW 200 STEP 100 BACKUP PRINT DM6_DN_2H.density 
                         [ AREA(M6_AND_DM6EXCL)/AREA(CHIP_AND_DM6EXCL) ]
  AREA (ERR_WIN AND DM6EXCL) >= 10000			 
}
#ELSE

M6.DN.1L { @ {M6 OR DM6} local density range over 200um x 200um area stepping 100um >= ^M6_DN_1L 
  D0 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP PRINT M6_DN_1L.density 
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
  AREA ERR1 >= 10000
  D1 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < M6_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}

M6.DN.1H { @ {M6 OR DM6} local density range over 200um x 200um area stepping 100um <= ^M6_DN_1H
    D0 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP PRINT M6_DN_1H.density 
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000 
    D1 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > M6_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}
#ENDIF


M7_NOT_EXC      = ALL_M7 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM7EXCL= DM7EXCL NOT METAL_DEN_EXC
M7_AND_DM7EXCL  = ALL_M7 AND CHIP_AND_DM7EXCL

DM7.DN.2L { @ M7 local density range within DM7EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= ^DM7_DN_2L 
  ERR_WIN = DENSITY M7_AND_DM7EXCL CHIP_AND_DM7EXCL < DM7_DN_2L WINDOW 200 STEP 100 BACKUP PRINT DM7_DN_2L.density 
                         [ AREA(M7_AND_DM7EXCL)/AREA(CHIP_AND_DM7EXCL) ]
  AREA (ERR_WIN AND DM7EXCL) >= 10000			 
}
DM7.DN.2H { @ M7 local density range within DM7EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= ^DM7_DN_2H
  ERR_WIN = DENSITY M7_AND_DM7EXCL CHIP_AND_DM7EXCL > DM7_DN_2H WINDOW 200 STEP 100 BACKUP PRINT DM7_DN_2H.density 
                         [ AREA(M7_AND_DM7EXCL)/AREA(CHIP_AND_DM7EXCL) ]
  AREA (ERR_WIN AND DM7EXCL) >= 10000			 
}
#ELSE

M7.DN.1L { @ {M7 OR DM7} local density range over 200um x 200um area stepping 100um >= ^M7_DN_1L 
  D0 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP PRINT M7_DN_1L.density 
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
  AREA ERR1 >= 10000
  D1 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < M7_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}

M7.DN.1H { @ {M7 OR DM7} local density range over 200um x 200um area stepping 100um <= ^M7_DN_1H
    D0 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP PRINT M7_DN_1H.density 
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000 
    D1 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > M7_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}
#ENDIF


METAL_DEN_EXC_TOP = (METAL_DEN_EXC OR PADi) OR PAD_EXD
M8_NOT_EXC        = ALL_M8 NOT METAL_DEN_EXC_TOP
M8_NOT_EXC_lo     = ALL_M8 NOT METAL_DEN_EXC
CHIP_NOT_M8_EXC   = CHIP NOT METAL_DEN_EXC_TOP
CHIP_NOT_M8_EXC_lo  = CHIP NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM8EXCL = DM8EXCL NOT METAL_DEN_EXC_TOP
CHIP_AND_DM8EXCL_lo = DM8EXCL NOT METAL_DEN_EXC
M8_AND_DM8EXCL = ALL_M8 AND CHIP_AND_DM8EXCL
M8_AND_DM8EXCL_lo = ALL_M8 AND CHIP_AND_DM8EXCL_lo

DM8.DN.2L { @ M8 local density range within DM8EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= ^DM8_DN_2L
  ERR_WIN = DENSITY M8_AND_DM8EXCL_lo CHIP_AND_DM8EXCL_lo < DM8_DN_2L WINDOW 200 STEP 100 BACKUP PRINT DM8_DN_2L.density 
                         [ AREA(M8_AND_DM8EXCL_lo)/AREA(CHIP_AND_DM8EXCL_lo) ]
  AREA (ERR_WIN AND DM8EXCL) >= 10000			 
}
DM8.DN.2H { @ M8 local density range within DM8EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= ^DM8_DN_2H
  ERR_WIN = DENSITY M8_AND_DM8EXCL CHIP_AND_DM8EXCL > DM8_DN_2H WINDOW 200 STEP 100 BACKUP PRINT DM8_DN_2H.density 
                         [ AREA(M8_AND_DM8EXCL)/AREA(CHIP_AND_DM8EXCL) ]
  AREA (ERR_WIN AND DM8EXCL) >= 10000			 
}
#ELSE

M8.DN.1L { @ {M8 OR DM8} local density range over 200um x 200um area stepping 100um >= ^M8_DN_1L
    D0 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP PRINT M8_DN_1L.density 
          [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000
    D1 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D2 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D3 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D4 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D5 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D6 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D7 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D8 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    D9 = DENSITY M8_NOT_EXC_lo CHIP_NOT_M8_EXC_lo < M8_DN_1L WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M8_NOT_EXC_lo)/AREA(CHIP_NOT_M8_EXC_lo) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000
}
M8.DN.1H { @ {M8 OR DM8} local density range over 200um x 200um area stepping 100um <= ^M8_DN_1H
    D0 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP PRINT M8_DN_1H.density 
          [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC_TOP
    AREA ERR1 >= 10000
    D1 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D2 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D3 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D4 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D5 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D6 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D7 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D8 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D9 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > M8_DN_1H WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9) 
    AREA ( ERR2 NOT METAL_DEN_EXC_TOP ) >= 10000
}
#ENDIF

//=========== MD Density Check ==================

METAL_DEN_EXC_MD = METAL_DEN_EXC OR UBM_EXDD
MD_NOT_EXC        = ALL_MD NOT METAL_DEN_EXC_MD
MD_NOT_EXC_lo     = ALL_MD NOT METAL_DEN_EXC
CHIP_RDL  = CHIP INTERACT MDi
CHIP_NOT_MD_EXC   = CHIP_RDL NOT METAL_DEN_EXC_MD
CHIP_NOT_MD_EXC_lo   = CHIP_RDL NOT METAL_DEN_EXC
#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DMDEXCL = DMDEXCL NOT METAL_DEN_EXC_TOP
CHIP_AND_DMDEXCL_lo = DMDEXCL NOT METAL_DEN_EXC
MD_AND_DMDEXCL = ALL_MD AND CHIP_AND_DMDEXCL
MD_AND_DMDEXCL_lo = ALL_MD AND CHIP_AND_DMDEXCL_lo

DMD.DN.2L { @ MD local density range within DMDEXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 20%
  ERR_WIN = DENSITY MD_AND_DMDEXCL_lo CHIP_AND_DMDEXCL_lo < 0.2 WINDOW 200 STEP 100 BACKUP PRINT DMD_DN_2L.density 
                         [ AREA(MD_AND_DMDEXCL_lo)/AREA(CHIP_AND_DMDEXCL_lo) ]
  AREA (ERR_WIN AND DMDEXCL) >= 10000			 
}
DMD.DN.2H { @ MD local density range within DMDEXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY MD_AND_DMDEXCL CHIP_AND_DMDEXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DMD_DN_2H.density 
                         [ AREA(MD_AND_DMDEXCL)/AREA(CHIP_AND_DMDEXCL) ]
  AREA (ERR_WIN AND DMDEXCL) >= 10000			 
}
#ELSE

MD.DN.1L { @ {MD OR DMD} local density range over 200um x 200um area stepping 100um >= 20%
    D0 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP PRINT MD_DN_1L.density 
          [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC
    AREA ERR1 >= 10000
    D1 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D2 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D3 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D4 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D5 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D6 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D7 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D8 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    D9 = DENSITY MD_NOT_EXC_lo CHIP_NOT_MD_EXC_lo < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(MD_NOT_EXC_lo)/AREA(CHIP_NOT_MD_EXC_lo) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC ) >= 10000 
}
MD.DN.1H { @ {MD OR DMD} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT MD_DN_1H.density 
          [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D = RECTANGLE D0 == 200
    ERR1 = ( D0 NOT D ) NOT METAL_DEN_EXC_MD
    AREA ERR1 >= 10000
    D1 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D2 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D3 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D4 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D5 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D6 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D7 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D8 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D9 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
    AREA ( ERR2 NOT METAL_DEN_EXC_MD ) >= 10000
}
#ENDIF



// Antenna effect prevention rules are in the separated runset.


//LOGO CHECKS
//============

LOGO.S.1 { @ Space to OD, poly, or metals (non-dummy patterns) >= 10 
  LOGO_OUTSIDE = (SIZE LOGO BY LOGO_S_1) NOT LOGO
  LOGO_OUTSIDE AND ODi
  LOGO_OUTSIDE AND POLYGi
  LOGO_OUTSIDE AND M1x
  LOGO_OUTSIDE AND M2x
  LOGO_OUTSIDE AND M3x
  LOGO_OUTSIDE AND M4x
  LOGO_OUTSIDE AND M5x
  LOGO_OUTSIDE AND M6x
  LOGO_OUTSIDE AND M7x
  LOGO_OUTSIDE AND M8x
  LOGO_OUTSIDE AND MDx
}
LOGO.R.1 { @ Overlap of EXCL, CB, CBD, AP, FW, PM, UBM, DOD, DPO, or DMx is not allowed.   
  EXCLi   AND LOGO
  PADi    AND LOGO	// CB
  CBDi    AND LOGO
  APi     AND LOGO
  FWi     AND LOGO
  PLMIDEi AND LOGO	// PM
  UBMi    AND LOGO
  DOD     AND LOGO
  DPO     AND LOGO
  DUM1    AND LOGO
  DUM2    AND LOGO
  DUM3    AND LOGO
  DUM4    AND LOGO
  DUM5    AND LOGO
  DUM6    AND LOGO
  DUM7    AND LOGO
  DUM8    AND LOGO
  DUMD    AND LOGO
}

// LOGO.R.2 is checked by LOGO.S.1




//CSR CHECKS
//==========


CSR_OD = ODi AND CSRDMY
CC_M1  = M1x AND CSRDMY
CC_V1  = VIA12i AND CSRDMY
CC_M2  = M2x AND CSRDMY
CC_V2  = VIA23i AND CSRDMY
CC_M3  = M3x AND CSRDMY
CC_V3  = VIA34i AND CSRDMY
CC_M4  = M4x AND CSRDMY
CC_V4  = VIA45i AND CSRDMY
CC_M5  = M5x AND CSRDMY
CC_V5  = VIA56i AND CSRDMY
CC_M6  = M6x AND CSRDMY
CC_V6  = VIA67i AND CSRDMY
CC_M7  = M7x AND CSRDMY
CC_V7  = VIA78i AND CSRDMY
CC_M8  = M8x AND CSRDMY
CC_V8  = VIA89i AND CSRDMY
CC_M9  = M9x AND CSRDMY
CC_VD  = VIADi AND CSRDMY
CC_MD  = MDx AND CSRDMY

CSR_USER_GUIDE.1.M1 { @ METAL1 must be stacked and coincident the edge .
  XOR CC_M1 CC_M2 
}
CSR_USER_GUIDE.1.M2 { @ METAL2 must be stacked and coincident the edge .
  XOR CC_M2 CC_M3 
}
CSR_USER_GUIDE.1.M3 { @ METAL3 must be stacked and coincident the edge .
  XOR CC_M3 CC_M4 
}
CSR_USER_GUIDE.1.M4 { @ METAL4 must be stacked and coincident the edge .
  XOR CC_M4 CC_M5 
}
CSR_USER_GUIDE.1.M5 { @ METAL5 must be stacked and coincident the edge .
  XOR CC_M5 CC_M6 
}
CSR_USER_GUIDE.1.M6 { @ METAL6 must be stacked and coincident the edge .
  XOR CC_M6 CC_M7 
}
#IFDEF LmarkSealringCorner
CSR_USER_GUIDE.1.M7 { @ METAL7 must be stacked and coincident the edge .
  NOT CC_M7 CC_M8 
}
#ELSE
CSR_USER_GUIDE.1.M7 { @ METAL7 must be stacked and coincident the edge .
  XOR CC_M7 CC_M8 
}
#ENDIF

#IFDEF LmarkSealringCorner
CSR_USER_GUIDE.2.M1 { @ M1 at same level have a exactive spacing value 1.5
   CC_MH1pre = HOLES (SIZE CC_M1 BY 0.6 UNDEROVER)      // filter non-check metal
   CC_MH1 = CC_MH1pre NOT INTERACT (HOLES (METAL8i AND LMARK) EMPTY) // filter LMARK 
   INT CC_MH1 < 1.5 ABUT < 90 PARALLEL ONLY REGION
   SIZE CC_MH1 BY 1.5 /2 UNDEROVER TRUNCATE 1.5 /2
}
CSR_USER_GUIDE.2.M2 { @ M2 at same level have a exactive spacing value 1.5
   CC_MH2pre = HOLES (SIZE CC_M2 BY 0.6 UNDEROVER)      // filter non-check metal
   CC_MH2 = CC_MH2pre NOT INTERACT (HOLES (METAL8i AND LMARK) EMPTY) // filter LMARK 
   INT CC_MH2 < 1.5 ABUT < 90 PARALLEL ONLY REGION
   SIZE CC_MH2 BY 1.5 /2 UNDEROVER TRUNCATE 1.5 /2
}
CSR_USER_GUIDE.2.M3 { @ M3 at same level have a exactive spacing value 1.5
   CC_MH3pre = HOLES (SIZE CC_M3 BY 0.6 UNDEROVER)      // filter non-check metal
   CC_MH3 = CC_MH3pre NOT INTERACT (HOLES (METAL8i AND LMARK) EMPTY) // filter LMARK 
   INT CC_MH3 < 1.5 ABUT < 90 PARALLEL ONLY REGION
   SIZE CC_MH3 BY 1.5 /2 UNDEROVER TRUNCATE 1.5 /2
}
CSR_USER_GUIDE.2.M4 { @ M4 at same level have a exactive spacing value 1.5
   CC_MH4pre = HOLES (SIZE CC_M4 BY 0.6 UNDEROVER)      // filter non-check metal
   CC_MH4 = CC_MH4pre NOT INTERACT (HOLES (METAL8i AND LMARK) EMPTY) // filter LMARK 
   INT CC_MH4 < 1.5 ABUT < 90 PARALLEL ONLY REGION
   SIZE CC_MH4 BY 1.5 /2 UNDEROVER TRUNCATE 1.5 /2
}
CSR_USER_GUIDE.2.M5 { @ M5 at same level have a exactive spacing value 1.5
   CC_MH5pre = HOLES (SIZE CC_M5 BY 0.6 UNDEROVER)      // filter non-check metal
   CC_MH5 = CC_MH5pre NOT INTERACT (HOLES (METAL8i AND LMARK) EMPTY) // filter LMARK 
   INT CC_MH5 < 1.5 ABUT < 90 PARALLEL ONLY REGION
   SIZE CC_MH5 BY 1.5 /2 UNDEROVER TRUNCATE 1.5 /2
}
CSR_USER_GUIDE.2.M6 { @ M6 at same level have a exactive spacing value 1.5
   CC_MH6pre = HOLES (SIZE CC_M6 BY 0.6 UNDEROVER)      // filter non-check metal
   CC_MH6 = CC_MH6pre NOT INTERACT (HOLES (METAL8i AND LMARK) EMPTY) // filter LMARK 
   INT CC_MH6 < 1.5 ABUT < 90 PARALLEL ONLY REGION
   SIZE CC_MH6 BY 1.5 /2 UNDEROVER TRUNCATE 1.5 /2
}
CSR_USER_GUIDE.2.M7 { @ M7 at same level have a exactive spacing value 1.5
   CC_MH7pre = HOLES (SIZE CC_M7 BY 0.6 UNDEROVER)      // filter non-check metal
   CC_MH7 = CC_MH7pre NOT INTERACT (HOLES (METAL8i AND LMARK) EMPTY) // filter LMARK 
   INT CC_MH7 < 1.5 ABUT < 90 PARALLEL ONLY REGION
   SIZE CC_MH7 BY 1.5 /2 UNDEROVER TRUNCATE 1.5 /2
}
#ELSE
CSR_USER_GUIDE.2.M1 { @ METAL1 at same level have a exact spacing value 1.5.
  CC_MH1 = HOLES CC_M1
  INT CC_MH1 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH1 BY 0.75 UNDEROVER TRUNCATE 0.75
}
CSR_USER_GUIDE.2.M2 { @ METAL2 at same level have a exact spacing value 1.5.
  CC_MH2 = HOLES CC_M2
  INT CC_MH2 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH2 BY 0.75 UNDEROVER TRUNCATE 0.75
}
CSR_USER_GUIDE.2.M3 { @ METAL3 at same level have a exact spacing value 1.5.
  CC_MH3 = HOLES CC_M3
  INT CC_MH3 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH3 BY 0.75 UNDEROVER TRUNCATE 0.75
}
CSR_USER_GUIDE.2.M4 { @ METAL4 at same level have a exact spacing value 1.5.
  CC_MH4 = HOLES CC_M4
  INT CC_MH4 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH4 BY 0.75 UNDEROVER TRUNCATE 0.75
}
CSR_USER_GUIDE.2.M5 { @ METAL5 at same level have a exact spacing value 1.5.
  CC_MH5 = HOLES CC_M5
  INT CC_MH5 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH5 BY 0.75 UNDEROVER TRUNCATE 0.75
}
CSR_USER_GUIDE.2.M6 { @ METAL6 at same level have a exact spacing value 1.5.
  CC_MH6 = HOLES CC_M6
  INT CC_MH6 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH6 BY 0.75 UNDEROVER TRUNCATE 0.75
}
CSR_USER_GUIDE.2.M7 { @ METAL7 at same level have a exact spacing value 1.5.
  CC_MH7 = HOLES CC_M7
  INT CC_MH7 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH7 BY 0.75 UNDEROVER TRUNCATE 0.75
}
CSR_USER_GUIDE.2.M8 { @ METAL8 at same level have a exact spacing value 1.5.
  CC_MH8 = HOLES CC_M8
  INT CC_MH8 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH8 BY 0.75 UNDEROVER TRUNCATE 0.75
}
CSR_USER_GUIDE.2.MD { @ MD at same level have a exact spacing value 1.5.
  CC_MHD = HOLES CC_MD
  INT CC_MHD < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MHD BY 0.75 UNDEROVER
}

#ENDIF
#IFDEF FULL_CHIP

CSR.R.1.DNWELLi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DNWELLi
}  
CSR.R.1.NWELLi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NWELLi
}  
CSR.R.1.NWi_OTHERS { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NWi_OTHERS
}  
CSR.R.1.ODi_RFDRAIN { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND ODi_RFDRAIN
}  
CSR.R.1.DOD { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DOD
}  
CSR.R.1.OD2i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND OD2i
}  
CSR.R.1.POLYGi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND POLYGi
}  
CSR.R.1.DPO { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DPO
}  
CSR.R.1.POi_OTHERS { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND POi_OTHERS
}  
CSR.R.1.PIMPi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PIMPi
}  
CSR.R.1.NIMPi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NIMPi
}  
CSR.R.1.CONTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CONTi
}  
CSR.R.1.METAL1i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL1i
}  
CSR.R.1.M1SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M1SLOTi
}  
CSR.R.1.DUM1 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM1
}  
CSR.R.1.METAL2i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL2i
}  
CSR.R.1.M2SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M2SLOTi
}  
CSR.R.1.DUM2 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM2
}  
CSR.R.1.METAL3i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL3i
}  
CSR.R.1.M3SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M3SLOTi
}  
CSR.R.1.DUM3 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM3
}  
CSR.R.1.METAL4i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL4i
}  
CSR.R.1.M4SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M4SLOTi
}  
CSR.R.1.DUM4 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM4
}  
CSR.R.1.METAL5i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL5i
}  
CSR.R.1.M5SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M5SLOTi
}  
CSR.R.1.DUM5 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM5
}  
CSR.R.1.METAL6i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL6i
}  
CSR.R.1.M6SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M6SLOTi
}  
CSR.R.1.DUM6 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM6
}  
CSR.R.1.METAL7i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL7i
}  
CSR.R.1.M7SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M7SLOTi
}  
CSR.R.1.DUM7 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM7
}  
CSR.R.1.METAL8i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL8i
}  
CSR.R.1.M8SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M8SLOTi
}  
CSR.R.1.DUM8 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM8
}  
CSR.R.1.METAL9i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL9i
}  
CSR.R.1.M9SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M9SLOTi
}  
CSR.R.1.DUM9 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM9
}  
CSR.R.1.MDi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND MDi
}  
CSR.R.1.MDSLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND MDSLOTi
}  
CSR.R.1.DUMD { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUMD
}  
CSR.R.1.VIA12i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA12i
}  
CSR.R.1.VIA23i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA23i
}  
CSR.R.1.VIA34i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA34i
}  
CSR.R.1.VIA45i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA45i
}  
CSR.R.1.VIA56i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA56i
}  
CSR.R.1.VIA67i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA67i
}  
CSR.R.1.VIA78i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA78i
}  
CSR.R.1.VIA89i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA89i
}  
CSR.R.1.VIADi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIADi
}  
CSR.R.1.RVi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RVi
}  
CSR.R.1.APi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND APi
}  
CSR.R.1.PADi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PADi
}  
CSR.R.1.CB2i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CB2i
}  
CSR.R.1.CBDi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CBDi
}  
CSR.R.1.UBMi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND UBMi
}  
CSR.R.1.WBDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND WBDMY
}  
CSR.R.1.RPOi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RPOi
}  
CSR.R.1.NT_Ni { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NT_Ni
}  
CSR.R.1.VTL_Ni { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VTL_Ni
}  
CSR.R.1.VTL_Pi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VTL_Pi
}  
CSR.R.1.VTH_Ni { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VTH_Ni
}  
CSR.R.1.VTH_Pi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VTH_Pi
}  
CSR.R.1.LVIDi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND LVIDi
}  
CSR.R.1.CTMi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CTMi
}  
CSR.R.1.HRIi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND HRIi
}  
CSR.R.1.FWi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND FWi
}  
CSR.R.1.PLMIDEi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PLMIDEi
}  
CSR.R.1.SEALRING { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND SEALRING
}  
CSR.R.1.CSRDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CSRDMY
}  
CSR.R.1.NWDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NWDMY
}  
CSR.R.1.HOTWL { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND HOTWL
}  
CSR.R.1.RHDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RHDMY
}  
CSR.R.1.RPDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RPDMY
}  
CSR.R.1.PMDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PMDMY
}  
CSR.R.1.SDI { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND SDI
}  
CSR.R.1.ESD1DMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND ESD1DMY
}  
CSR.R.1.ESD2DMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND ESD2DMY
}  
CSR.R.1.ESD3DMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND ESD3DMY
}  
CSR.R.1.LMARK { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND LMARK
}  
CSR.R.1.RHRIDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RHRIDMY
}  
CSR.R.1.VARDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VARDMY
}  
CSR.R.1.LOGO { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND LOGO
}  
CSR.R.1.INDDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND INDDMY
}  
CSR.R.1.CBMi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CBMi
}  
CSR.R.1.CDUDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CDUDMY
}  
CSR.R.1.EXCLi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND EXCLi
}  
CSR.R.1.IO_buffer { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND IO_buffer
}  
CSR.R.1.DMSRMi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DMSRMi
}  
CSR.R.1.HVTSRM { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND HVTSRM
}  
CSR.R.1.SRAMDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND SRAMDMY
}  
CSR.R.1.RRuleRequired { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RRuleRequired
}  
CSR.R.1.RRuleRecommended { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RRuleRecommended
}  
CSR.R.1.RRuleAnalog { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RRuleAnalog
}  
CSR.R.1.RFDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RFDMY
}  
CSR.R.1.BJTDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND BJTDMY
}  
CSR.R.1.DIODMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DIODMY
}  
CSR.R.1.CTMDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CTMDMY
}  

#ENDIF

CSR.R.2 { @ User must add CSR in 4 chip corners.
  SR_EDGE NOT INTERACT CSRDMY	// Only dummy layer checked
}
CSR.R.3 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD. 
  CSRDMY NOT INTERACT ODi 
  CSRDMY NOT INTERACT PIMPi 
  CSRDMY NOT INTERACT M1x 
  CSRDMY NOT INTERACT M2x 
  CSRDMY NOT INTERACT M3x 
  CSRDMY NOT INTERACT M4x 
  CSRDMY NOT INTERACT M5x 
  CSRDMY NOT INTERACT M6x 
  CSRDMY NOT INTERACT M7x 
  CSRDMY NOT INTERACT M8x 
  CSRDMY NOT ENCLOSE CONTi 
  CSRDMY NOT ENCLOSE VIA12i 
  CSRDMY NOT ENCLOSE VIA23i 
  CSRDMY NOT ENCLOSE VIA34i 
  CSRDMY NOT ENCLOSE VIA45i 
  CSRDMY NOT ENCLOSE VIA56i 
  CSRDMY NOT ENCLOSE VIA67i 
  CSRDMY NOT ENCLOSE VIA78i 
}
CSR.S.1 { @ CO space >= 0.320 
  CC_CO = CONTi AND CSRDMY
  EXT CC_CO < CSR_S_1 ABUT < 90 SINGULAR  
}

// CSR.EN.1 is not able to check

CSR.S.2.VIA1 { @ VIAx (x=1~6) space at the same level >= 0.290 
  EXT CC_V1 < CSR_S_2 ABUT < 90 SINGULAR 
}

CSR.S.2.VIA2 { @ VIAx (x=1~6) space at the same level >= 0.290 
  EXT CC_V2 < CSR_S_2 ABUT < 90 SINGULAR 
}

CSR.S.2.VIA3 { @ VIAx (x=1~6) space at the same level >= 0.290 
  EXT CC_V3 < CSR_S_2 ABUT < 90 SINGULAR 
}

CSR.S.2.VIA4 { @ VIAx (x=1~6) space at the same level >= 0.290 
  EXT CC_V4 < CSR_S_2 ABUT < 90 SINGULAR 
}


#IFDEF THICK_TOP3_METAL

CSR.S.3.VIA5 { @ VIA7 space >= 0.360 
  EXT CC_V5 < CSR_S_3 ABUT < 90 SINGULAR 
}

#ELSE


CSR.S.2.VIA5 { @ VIAx (x=1~6) space at the same level >= 0.290 
  EXT CC_V5 < CSR_S_2 ABUT < 90 SINGULAR 
}
#ENDIF 



#IFDEF THICK_TOP2_METAL

CSR.S.3.VIA6 { @ VIA7 space >= 0.360 
  EXT CC_V6 < CSR_S_3 ABUT < 90 SINGULAR 
}

#ELSE

#IFDEF THICK_TOP3_METAL

CSR.S.3.VIA6 { @ VIA7 space >= 0.360 
  EXT CC_V6 < CSR_S_3 ABUT < 90 SINGULAR 
}

#ELSE


CSR.S.2.VIA6 { @ VIAx (x=1~6) space at the same level >= 0.290 
  EXT CC_V6 < CSR_S_2 ABUT < 90 SINGULAR 
}
#ENDIF
#ENDIF 



CSR.S.3.VIA7 { @ VIA7 space >= 0.360 
  EXT CC_V7 < CSR_S_3 ABUT < 90 SINGULAR 
}
CSR.S.3.VIAD { @ VIA7 space >= 0.360 
  EXT CC_VD < CSR_S_3 ABUT < 90 SINGULAR 
}

// CSR.EN.2 is not able to check
// CSR.EN.3 is not able to check
// CSR.R.4 is not able to check

#IFDEF LmarkSealringCorner
LMARK_METAL_CSR = LMARK_METAL AND CSRDMY // L-mark in CSR
LMARK_SLOT_CSR = LSLOT AND CSRDMY  // L shaped oxide in L-mark metal

CSR.W.1 {@ Width of L-slot (minimum=maximum)  = 10 
   SIZE LMARK_SLOT_CSR BY CSR_W_1/2 UNDEROVER
   INT LMARK_SLOT_CSR < CSR_W_1 ABUT < 90 ANGLED == 0 REGION
}
CSR.L.1 {@ Length of L-slot (minimum) >= 20 
   NOT ENCLOSE RECTANGLE LMARK_SLOT_CSR 10 CSR_L_1_1
   ENCLOSE RECTANGLE LMARK_SLOT_CSR 10 CSR_L_1_2+0.005
}  
CSR.EN.4 { @ L-mark metal in CSR enclosure of L-slot [in the direction of the L-slot length] >= 4 
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 90
   ENC X LMARK_METAL_CSR < CSR_EN_4_1 ABUT < 90 OPPOSITE REGION
   ENC X LMARK_METAL_CSR > CSR_EN_4_2 < 100 ABUT < 90 OPPOSITE REGION
}
CSR.EN.5 {@ L-mark metal in CSR enclosure of L-slot [perpendicular to the direction of the L-slot length] >= 28 
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 225
   ENC X LMARK_METAL_CSR < CSR_EN_5_1 ABUT < 90 OPPOSITE REGION
   ENC X LMARK_METAL_CSR > CSR_EN_5_2 < 100 ABUT < 90 OPPOSITE REGION 
}
CSR.W.2 { @ Width of 45 degree corner of L-slot >= 6 
   X = ANGLE LMARK_SLOT_CSR == 45
   Y = EXPAND EDGE X INSIDE BY CSR_W_2_2+0.005    
   Y OUTSIDE LMARK_METAL_CSR
   INT LMARK_SLOT_CSR < CSR_W_2_1 ABUT < 90 ANGLED == 2 REGION
}
// CSR.W.3 s checked by CO.W.2/VIAx.W.2
CSR.EN.6.CO { @ Metal enclosure of CO around L-slot >= ^CSR_EN_6 um
   EXT LMARK_SLOT_CSR SR_CO < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_CO    
}
CSR.EN.6.VIA1 { @ Metal enclosure of VIAx around L-slot >= ^CSR_EN_6 um
   EXT LMARK_SLOT_CSR SR_V1 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V1
}

CSR.EN.6.VIA2 { @ Metal enclosure of VIAx around L-slot >= ^CSR_EN_6 um
   EXT LMARK_SLOT_CSR SR_V2 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V2
}

CSR.EN.6.VIA3 { @ Metal enclosure of VIAx around L-slot >= ^CSR_EN_6 um
   EXT LMARK_SLOT_CSR SR_V3 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V3
}

CSR.EN.6.VIA4 { @ Metal enclosure of VIAx around L-slot >= ^CSR_EN_6 um
   EXT LMARK_SLOT_CSR SR_V4 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V4
}


#IFDEF THICK_TOP3_METAL

CSR.EN.6.VIA5 { @ Metal enclosure of VIAn around L-slot >= ^CSR_EN_6_1 um
   EXT LMARK_SLOT_CSR SR_V5 < CSR_EN_6_1 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V5
}
#ELSE

CSR.EN.6.VIA5 { @ Metal enclosure of VIAx around L-slot >= ^CSR_EN_6 um
   EXT LMARK_SLOT_CSR SR_V5 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V5
}
#ENDIF 



#IFDEF THICK_TOP2_METAL

CSR.EN.6.VIA6 { @ Metal enclosure of VIAn around L-slot >= ^CSR_EN_6_1 um
   EXT LMARK_SLOT_CSR SR_V6 < CSR_EN_6_1 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V6
}
#ELSE

#IFDEF THICK_TOP3_METAL

CSR.EN.6.VIA6 { @ Metal enclosure of VIAn around L-slot >= ^CSR_EN_6_1 um
   EXT LMARK_SLOT_CSR SR_V6 < CSR_EN_6_1 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V6
}
#ELSE

CSR.EN.6.VIA6 { @ Metal enclosure of VIAx around L-slot >= ^CSR_EN_6 um
   EXT LMARK_SLOT_CSR SR_V6 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V6
}
#ENDIF
#ENDIF 



CSR.EN.6.VIA7 { @ Metal enclosure of VIA7 around L-slot >= ^CSR_EN_6_1 um
   EXT LMARK_SLOT_CSR SR_V7 < CSR_EN_6_1 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_V7
}

CSR.EN.6.VIAD { @ Metal enclosure of VIAD around L-slot >= ^CSR_EN_6_1 um
   EXT LMARK_SLOT_CSR SR_VD < CSR_EN_6_1 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_VD
}

CSR.EN.7 {@ Metal enclosure by L-mark metal in CSR around the L-slot >= 0.25 
   EXT LMARK_SLOT_CSR METAL1i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND METAL1i
   EXT LMARK_SLOT_CSR METAL2i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND METAL2i
   EXT LMARK_SLOT_CSR METAL3i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND METAL3i
   EXT LMARK_SLOT_CSR METAL4i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND METAL4i
   EXT LMARK_SLOT_CSR METAL5i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND METAL5i
   EXT LMARK_SLOT_CSR METAL6i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND METAL6i
   EXT LMARK_SLOT_CSR METAL7i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND METAL7i
}
#ENDIF

//SEAL-RING CHECKS
//================

SR_NOT_PMDMY = SEALRING NOT INTERACT PMDMY

SR_USER_GUIDE.0 { @ Seal-ring structure must be Mtop~M1/VIAtop~VIA1/CO/PP/OD
  SR_NOT_PMDMY NOT ODi 
  SR_NOT_PMDMY NOT PIMPi
  SR_NOT_PMDMY NOT M1x 
  SR_NOT_PMDMY NOT M2x 
  SR_NOT_PMDMY NOT M3x 
  SR_NOT_PMDMY NOT M4x 
  SR_NOT_PMDMY NOT M5x 
  SR_NOT_PMDMY NOT M6x 
  SR_NOT_PMDMY NOT M7x 
  SR_NOT_PMDMY NOT M8x 
  SR_M1 NOT ENCLOSE CONTi 
  SR_M1 NOT ENCLOSE VIA12i 
  SR_M2 NOT ENCLOSE VIA23i 
  SR_M3 NOT ENCLOSE VIA34i 
  SR_M4 NOT ENCLOSE VIA45i 
  SR_M5 NOT ENCLOSE VIA56i 
  SR_M6 NOT ENCLOSE VIA67i 
  SR_M7 NOT ENCLOSE VIA78i 
}

#IFDEF LmarkSealringCorner
SR_MS1 = (INT SR_M1 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW1 = (SR_M1 NOT SR_MS1) NOT CSRDMY
SR_MS2 = (INT SR_M2 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW2 = (SR_M2 NOT SR_MS2) NOT CSRDMY
SR_MS3 = (INT SR_M3 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW3 = (SR_M3 NOT SR_MS3) NOT CSRDMY
SR_MS4 = (INT SR_M4 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW4 = (SR_M4 NOT SR_MS4) NOT CSRDMY
SR_MS5 = (INT SR_M5 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW5 = (SR_M5 NOT SR_MS5) NOT CSRDMY
SR_MS6 = (INT SR_M6 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW6 = (SR_M6 NOT SR_MS6) NOT CSRDMY
SR_MS7 = (INT SR_M7 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW7 = (SR_M7 NOT SR_MS7) NOT CSRDMY
SR_MS8 = (INT SR_M8 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW8 = (SR_M8 NOT SR_MS8) NOT CSRDMY
SR_MSD = (INT SR_MD <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MWD = (SR_MD NOT SR_MSD) NOT CSRDMY
#ELSE
SR_MS1 = INT SR_M1 <= 5 ABUT < 90 REGION 
SR_MW1 = SR_M1 NOT SR_MS1
SR_MS2 = INT SR_M2 <= 5 ABUT < 90 REGION 
SR_MW2 = SR_M2 NOT SR_MS2
SR_MS3 = INT SR_M3 <= 5 ABUT < 90 REGION 
SR_MW3 = SR_M3 NOT SR_MS3
SR_MS4 = INT SR_M4 <= 5 ABUT < 90 REGION 
SR_MW4 = SR_M4 NOT SR_MS4
SR_MS5 = INT SR_M5 <= 5 ABUT < 90 REGION 
SR_MW5 = SR_M5 NOT SR_MS5
SR_MS6 = INT SR_M6 <= 5 ABUT < 90 REGION 
SR_MW6 = SR_M6 NOT SR_MS6
SR_MS7 = INT SR_M7 <= 5 ABUT < 90 REGION 
SR_MW7 = SR_M7 NOT SR_MS7
SR_MS8 = INT SR_M8 <= 5 ABUT < 90 REGION 
SR_MW8 = SR_M8 NOT SR_MS8
SR_MSD = INT SR_MD <= 5 ABUT < 90 REGION 
SR_MWD = SR_MD NOT SR_MSD
#ENDIF

SR_USER_GUIDE.1.M1 { @ Seal-ring exact space between M1 2.3um.
   EXT SR_MW1 SR_MS1 < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MW1 SR_MS1 < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   K1 = EXPAND EDGE SR_MW1 OUTSIDE BY 2.3
   B1 = EXPAND EDGE SR_MS1 OUTSIDE BY 2.3 
   C1 = K1 OR B1
   Z1 = C1 NOT SR_M1
   SIZE Z1 BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}
SR_USER_GUIDE.1.M2 { @ Seal-ring exact space between M2 2.3um.
   EXT SR_MW2 SR_MS2 < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MW2 SR_MS2 < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   K2 = EXPAND EDGE SR_MW2 OUTSIDE BY 2.3
   B2 = EXPAND EDGE SR_MS2 OUTSIDE BY 2.3 
   C2 = K2 OR B2
   Z2 = C2 NOT SR_M2
   SIZE Z2 BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}
SR_USER_GUIDE.1.M3 { @ Seal-ring exact space between M3 2.3um.
   EXT SR_MW3 SR_MS3 < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MW3 SR_MS3 < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   K3 = EXPAND EDGE SR_MW3 OUTSIDE BY 2.3
   B3 = EXPAND EDGE SR_MS3 OUTSIDE BY 2.3 
   C3 = K3 OR B3
   Z3 = C3 NOT SR_M3
   SIZE Z3 BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}
SR_USER_GUIDE.1.M4 { @ Seal-ring exact space between M4 2.3um.
   EXT SR_MW4 SR_MS4 < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MW4 SR_MS4 < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   K4 = EXPAND EDGE SR_MW4 OUTSIDE BY 2.3
   B4 = EXPAND EDGE SR_MS4 OUTSIDE BY 2.3 
   C4 = K4 OR B4
   Z4 = C4 NOT SR_M4
   SIZE Z4 BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}
SR_USER_GUIDE.1.M5 { @ Seal-ring exact space between M5 2.3um.
   EXT SR_MW5 SR_MS5 < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MW5 SR_MS5 < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   K5 = EXPAND EDGE SR_MW5 OUTSIDE BY 2.3
   B5 = EXPAND EDGE SR_MS5 OUTSIDE BY 2.3 
   C5 = K5 OR B5
   Z5 = C5 NOT SR_M5
   SIZE Z5 BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}
SR_USER_GUIDE.1.M6 { @ Seal-ring exact space between M6 2.3um.
   EXT SR_MW6 SR_MS6 < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MW6 SR_MS6 < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   K6 = EXPAND EDGE SR_MW6 OUTSIDE BY 2.3
   B6 = EXPAND EDGE SR_MS6 OUTSIDE BY 2.3 
   C6 = K6 OR B6
   Z6 = C6 NOT SR_M6
   SIZE Z6 BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}
SR_USER_GUIDE.1.M7 { @ Seal-ring exact space between M7 2.3um.
   EXT SR_MW7 SR_MS7 < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MW7 SR_MS7 < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   K7 = EXPAND EDGE SR_MW7 OUTSIDE BY 2.3
   B7 = EXPAND EDGE SR_MS7 OUTSIDE BY 2.3 
   C7 = K7 OR B7
   Z7 = C7 NOT SR_M7
   SIZE Z7 BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}
SR_USER_GUIDE.1.M8 { @ Seal-ring exact space between M8 2.3um.
   EXT SR_MW8 SR_MS8 < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MW8 SR_MS8 < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   K8 = EXPAND EDGE SR_MW8 OUTSIDE BY 2.3
   B8 = EXPAND EDGE SR_MS8 OUTSIDE BY 2.3 
   C8 = K8 OR B8
   Z8 = C8 NOT SR_M8
   SIZE Z8 BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}
SR_USER_GUIDE.1.MD { @ Seal-ring exact space between MD 2.3um.
   EXT SR_MWD SR_MSD < 2.3 ABUT < 90 PARALLEL ONLY ANGLED == 0 REGION
   EXT SR_MWD SR_MSD < ( 2.3 -0.004) ABUT < 90 OPPOSITE PARALLEL ONLY ANGLED == 2 REGION
   KD = EXPAND EDGE SR_MWD OUTSIDE BY 2.3
   BD = EXPAND EDGE SR_MSD OUTSIDE BY 2.3 
   CD = KD OR BD
   ZD = CD NOT SR_MD
   SIZE ZD BY (2.3 +0.004) /2 UNDEROVER TRUNCATE (2.3 +0.004) /2
}

ASSH = HOLES ((METAL1i INTERACT SR_EDGE) INTERACT SEALRING) INNER
ASS  = SIZE ASSH BY 10 UNDEROVER // remove un-wanted hole in corner
CORR = SIZE ASS BY -10           // core region 
ISOR = ASS NOT CORR              // assembly isolation region

#IFDEF FULL_CHIP
SR.S.1 { @ Assembly isolation.  10  
  ISOR AND DNWELLi
  ISOR AND NWELLi
  (ISOR AND POLYGi) NOT INSIDE CDUDMY
  ISOR AND DPO
  (ISOR AND ODi) NOT INSIDE CDUDMY
  ISOR AND DOD
  ISOR AND CBMi
  ISOR AND CTMi
  (ISOR AND CONTi) NOT INSIDE CDUDMY
  ISOR AND VIA12i
  ISOR AND VIA23i
  ISOR AND VIA34i
  ISOR AND VIA45i
  ISOR AND VIA56i
  ISOR AND VIA67i
  ISOR AND VIA78i
  ISOR AND VIADi // For CuRDL
  (ISOR AND METAL1i) NOT INSIDE CDUDMY
  ISOR AND M2x
  ISOR AND M3x
  ISOR AND M4x
  ISOR AND M5x
  ISOR AND M6x
  ISOR AND M7x
  ISOR AND M8x
  ISOR AND MDx	// CuRDL
  ISOR AND APi	// AlRDL
  ISOR AND UBMi
  ISOR AND CBDi
  ISOR AND PADi
  ISOR AND CB2i
}

SR.R.1 { @  check existence of layer 162(SEALRING)
  CHIP_WISR NOT INTERACT SEALRING
  (CHIP_NOSR INTERACT PMDMY) NOT INTERACT SEALRING
}
#ENDIF
SR.CO_VIA.WARN { @ line-co and line-viax must be continuous
   LINE_CO = NOT RECTANGLE SR_CO == CO_W_1 BY == CO_W_1
   CONVEX EDGE LINE_CO ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*CO_W_2
   LINE_VIA1 = NOT RECTANGLE SR_V1 == VIA1_W_1 BY == VIA1_W_1
   CONVEX EDGE LINE_VIA1 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA1_W_2
   LINE_VIA2 = NOT RECTANGLE SR_V2 == VIA2_W_1 BY == VIA2_W_1
   CONVEX EDGE LINE_VIA2 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA2_W_2
   LINE_VIA3 = NOT RECTANGLE SR_V3 == VIA3_W_1 BY == VIA3_W_1
   CONVEX EDGE LINE_VIA3 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA3_W_2
   LINE_VIA4 = NOT RECTANGLE SR_V4 == VIA4_W_1 BY == VIA4_W_1
   CONVEX EDGE LINE_VIA4 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA4_W_2
   LINE_VIA5 = NOT RECTANGLE SR_V5 == VIA5_W_1 BY == VIA5_W_1
   CONVEX EDGE LINE_VIA5 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA5_W_2
   LINE_VIA6 = NOT RECTANGLE SR_V6 == VIA6_W_1 BY == VIA6_W_1
   CONVEX EDGE LINE_VIA6 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA6_W_2
   LINE_VIA7 = NOT RECTANGLE SR_V7 == VIA7_W_1 BY == VIA7_W_1
   CONVEX EDGE LINE_VIA7 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA7_W_2
}
#IFDEF FULL_CHIP
SR.AP.WARN { @ AP is must in seal-ring if AlRDL or AlPad is used ; 
             @ AP enclosure of CB/CBD/CB2 in seal-ring >= 1
  SRCSRx = SRCSR INTERACT (CHIP INTERACT APi) // AlRDL or AlRad is used
  SRx_CB  = PADi  INSIDE SRCSRx 
  SRx_CBD = CBDi INSIDE SRCSRx 
  SRx_CB2 = CB2i INSIDE SRCSRx		 
  SRx_CB  NOT APi
  SRx_CBD NOT APi
  SRx_CB2 NOT APi
  ENC SRx_CB  APi < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_CBD APi < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_CB2 APi < 1 ABUT < 90 SINGULAR REGION
}
#ENDIF



//CDU CHECKS
//==========

CDU.R.1 { @ CDUDMY must be inside the assembly isolation, beside the seal ring.   
#IFDEF FULL_CHIP
  CDUDMY AND SCORE
  SR_EDGE NOT INTERACT CDUDMY		// Out most sealring structure
#ELSE
  COPY CDUDMY
#ENDIF
}

#IFDEF FULL_CHIP

CDU.R.2 { @ OD/Poly/CO/M1 must be inside the CDUDMY.   
  CDUDMY NOT INTERACT ODi
  CDUDMY NOT INTERACT POLYGi
  CDUDMY NOT INTERACT CONTi
  CDUDMY NOT INTERACT METAL1i
}

#ENDIF



//DUMMY OD RULE
//================

DOD.W.1 { @ Width  >= 2.0 
  INT DOD < DOD_W_1 ABUT < 90 SINGULAR REGION
}
DOD.S.1 { @ Space  >= 1.2 
  EXT DOD < DOD_S_1 ABUT < 90 SINGULAR REGION
}
DOD.S.2 { @ Space to OD [overlap is not allowed] >= 1.2 
  EXT ODi DOD < DOD_S_2 ABUT < 90 SINGULAR REGION
  ODi AND DOD
}
DOD.S.3 { @ Space to PO [overlap is not allowed] >= 1.2 
  EXT POLYGi DOD < DOD_S_3 ABUT < 90 SINGULAR REGION 
   POLYGi AND DOD 
}
DOD.S.5 { @ Space to NW [overlap is not allowed] >= 0.6 
  EXT NWELLi DOD < DOD_S_5 ABUT < 90 SINGULAR REGION
}
DOD.S.6 { @ Space to FW [overlap is not allowed] >= 1.2 
  EXT FWi DOD < DOD_S_6 ABUT < 90 SINGULAR REGION
  FWi AND DOD
}
DOD.S.7 { @ Space to LMARK [overlap is not allowed] >= 1.2 
  EXT LMARK DOD < DOD_S_7 ABUT < 90 SINGULAR REGION 
  LMARK AND DOD 
}
DOD.S.8 { @ Space to NWDMY [overlap is not allowed] >= 1.2 
  EXT NWDMY DOD < DOD_S_8 ABUT < 90 SINGULAR REGION 
  NWDMY AND DOD 
}
DOD.S.9 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DOD
}
DOD.S.10 { @ Space to INDDMY [overlap is not allowed] >= 1.2 
  EXT INDDMY DOD < DOD_S_10 ABUT < 90 SINGULAR REGION 
  INDDMY AND DOD 
}
DOD.EN.1 { @ Enclosure by NW >= 0.6 
  ENC DOD NWELLi < DOD_EN_1 ABUT < 90 OVERLAP SINGULAR REGION
}

#IFDEF FULL_CHIP
DOD.EN.2 { @ Enclosure by chip edge  >= 2.5 
  DOD NOT (SIZE CHIP_CHAMFERED BY -DOD_EN_2)
}
#ENDIF

// OD density rules are implemented in OD section


#IFDEF FULL_CHIP
DOD.R.1 { @ DOD is required. The DOD CAD layer (TSMC default, 6;1) must be different from the OD CAD layer.   
  CHIP_CHAMFERED NOT INTERACT DOD
}
#ENDIF

// DOD.R.2 is checked by CSR.R.1

DOD.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DOD
  NOT RECTANGLE DOD ORTHOGONAL ONLY
}


//DUMMY POLY RULE
//================

DPO.W.1 { @ Width >= 0.6 
  INT DPO < DPO_W_1 ABUT < 90 SINGULAR REGION
}
DPO.S.1 { @ Space >= 0.3 
  EXT DPO < DPO_S_1 ABUT < 90 SINGULAR REGION
}
DPO.S.2 { @ Space to OD [overlap is not allowed] >= 1.2 
  EXT ODi DPO < DPO_S_2 ABUT < 90 SINGULAR REGION 
  ODi AND DPO
}
DPO.S.3 { @ Space to PO [overlap is not allowed] >= 1.2 
  EXT POLYGi DPO < DPO_S_3 ABUT < 90 SINGULAR REGION 
  POLYGi AND DPO
}
DPO.S.5 { @ Space to FW [overlap is not allowed] >= 1.2 
  EXT FWi DPO < DPO_S_5 ABUT < 90 SINGULAR REGION 
  FWi AND DPO
}
DPO.S.6 { @ Space to LMARK [overlap is not allowed] >= 1.2 
  EXT LMARK DPO < DPO_S_6 ABUT < 90 SINGULAR REGION 
  LMARK AND DPO
}
DPO.S.7 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DPO
}
DPO.S.8 { @ Space to INDDMY [overlap is not allowed] >= 1.2 
  EXT INDDMY DPO < DPO_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DPO 
}
DPO.S.9 { @ Space to DOD [overlap is not allowed] >= 0.3 
  EXT DPO DOD < DPO_S_9 ABUT < 90 SINGULAR REGION
  DPO AND DOD
}  

#IFDEF FULL_CHIP
DPO.EN.1 { @ Enclosure by chip edge >= 2.5 
  DPO NOT (SIZE CHIP_CHAMFERED BY -DPO_EN_1)
}
#ENDIF

DPO.A.1 { @ Area >= 1.2 
  AREA DPO < 1.2
}  
// PO.DN.1 density rule is implemented in PO section

#IFDEF FULL_CHIP
DPO.R.1 { @ DPO is required [PO density of the whole chip <14%]. The DPO CAD layer (TSMC default, 17;1) must be a different layer from the PO CAD layer.   
  PO_DENSITY NOT INTERACT DPO
}
#ENDIF

// DPO.R.2 is checked by CSR.R.1

DPO.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DPO
  NOT RECTANGLE DPO ORTHOGONAL ONLY
}


//DUMMY METAL RULE
//=================

DM1.W.1 { @ Width (minimum) >= 0.4
  INT DUM1 < 0.4 ABUT < 90 SINGULAR REGION
}
DM1.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM1 BY 1.5 UNDEROVER
}
DM1.S.1 { @ Space >= 0.4
  EXT DUM1 < 0.4 ABUT < 90 SINGULAR REGION
}
DM1.S.2 { @ Space to M1 [overlap is not allowed] >= 0.6
  EXT M1x DUM1 < 0.6 ABUT < 90 SINGULAR REGION
  M1x AND DUM1
}
DM1.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM1 < 0.36 
}
DM1.A.2 { @ Area (maximum) <= 80
  AREA DUM1 > 80 
}

DM1.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM1 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM1
}
DM1.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM1 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM1
}
DM1.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM1
}
DM1.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM1 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM1
}

#IFDEF FULL_CHIP
DM1.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUM1 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M1 section

#IFDEF FULL_CHIP
DM1.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM1
}
#ENDIF

// DM1.R.2 is checked by CSR.R.1

DM1.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUM1
  NOT RECTANGLE DUM1 ORTHOGONAL ONLY
}

DM2.W.1 { @ Width (minimum) >= 0.4
  INT DUM2 < 0.4 ABUT < 90 SINGULAR REGION
}
DM2.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM2 BY 1.5 UNDEROVER
}
DM2.S.1 { @ Space >= 0.4
  EXT DUM2 < 0.4 ABUT < 90 SINGULAR REGION
}
DM2.S.2 { @ Space to M2 [overlap is not allowed] >= 0.6
  EXT M2x DUM2 < 0.6 ABUT < 90 SINGULAR REGION
  M2x AND DUM2
}
DM2.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM2 < 0.36 
}
DM2.A.2 { @ Area (maximum) <= 80
  AREA DUM2 > 80 
}

DM2.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM2 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM2
}
DM2.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM2 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM2
}
DM2.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM2
}
DM2.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM2 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM2
}

#IFDEF FULL_CHIP
DM2.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUM2 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M2 section

#IFDEF FULL_CHIP
DM2.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM2
}
#ENDIF

// DM2.R.2 is checked by CSR.R.1

DM2.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUM2
  NOT RECTANGLE DUM2 ORTHOGONAL ONLY
}

DM3.W.1 { @ Width (minimum) >= 0.4
  INT DUM3 < 0.4 ABUT < 90 SINGULAR REGION
}
DM3.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM3 BY 1.5 UNDEROVER
}
DM3.S.1 { @ Space >= 0.4
  EXT DUM3 < 0.4 ABUT < 90 SINGULAR REGION
}
DM3.S.2 { @ Space to M3 [overlap is not allowed] >= 0.6
  EXT M3x DUM3 < 0.6 ABUT < 90 SINGULAR REGION
  M3x AND DUM3
}
DM3.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM3 < 0.36 
}
DM3.A.2 { @ Area (maximum) <= 80
  AREA DUM3 > 80 
}

DM3.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM3 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM3
}
DM3.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM3 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM3
}
DM3.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM3
}
DM3.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM3 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM3
}

#IFDEF FULL_CHIP
DM3.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUM3 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M3 section

#IFDEF FULL_CHIP
DM3.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM3
}
#ENDIF

// DM3.R.2 is checked by CSR.R.1

DM3.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUM3
  NOT RECTANGLE DUM3 ORTHOGONAL ONLY
}

DM4.W.1 { @ Width (minimum) >= 0.4
  INT DUM4 < 0.4 ABUT < 90 SINGULAR REGION
}
DM4.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM4 BY 1.5 UNDEROVER
}
DM4.S.1 { @ Space >= 0.4
  EXT DUM4 < 0.4 ABUT < 90 SINGULAR REGION
}
DM4.S.2 { @ Space to M4 [overlap is not allowed] >= 0.6
  EXT M4x DUM4 < 0.6 ABUT < 90 SINGULAR REGION
  M4x AND DUM4
}
DM4.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM4 < 0.36 
}
DM4.A.2 { @ Area (maximum) <= 80
  AREA DUM4 > 80 
}

DM4.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM4 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM4
}
DM4.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM4 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM4
}
DM4.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM4
}
DM4.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM4 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM4
}

#IFDEF FULL_CHIP
DM4.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUM4 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M4 section

#IFDEF FULL_CHIP
DM4.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM4
}
#ENDIF

// DM4.R.2 is checked by CSR.R.1

DM4.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUM4
  NOT RECTANGLE DUM4 ORTHOGONAL ONLY
}

DM5.W.1 { @ Width (minimum) >= 0.4
  INT DUM5 < 0.4 ABUT < 90 SINGULAR REGION
}
DM5.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM5 BY 1.5 UNDEROVER
}
DM5.S.1 { @ Space >= 0.4
  EXT DUM5 < 0.4 ABUT < 90 SINGULAR REGION
}
DM5.S.2 { @ Space to M5 [overlap is not allowed] >= 0.6
  EXT M5x DUM5 < 0.6 ABUT < 90 SINGULAR REGION
  M5x AND DUM5
}
DM5.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM5 < 0.36 
}
DM5.A.2 { @ Area (maximum) <= 80
  AREA DUM5 > 80 
}

DM5.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM5 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM5
}
DM5.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM5 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM5
}
DM5.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM5
}
DM5.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM5 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM5
}

#IFDEF FULL_CHIP
DM5.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUM5 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M5 section

#IFDEF FULL_CHIP
DM5.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM5
}
#ENDIF

// DM5.R.2 is checked by CSR.R.1

DM5.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUM5
  NOT RECTANGLE DUM5 ORTHOGONAL ONLY
}


#IFDEF THICK_TOP3_METAL

DM6.W.1 { @ Width (minimum) >= 0.8
  INT DUM6 < 0.8 ABUT < 90 SINGULAR REGION
}
DM6.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM6 BY 1.5 UNDEROVER
}
DM6.S.1 { @ Space >= 0.8
  EXT DUM6 < 0.8 ABUT < 90 SINGULAR REGION
}
DM6.S.2 { @ Space to M6 [overlap is not allowed] >= 0.6
  EXT M6x DUM6 < 0.6 ABUT < 90 SINGULAR REGION
  M6x AND DUM6
}
DM6.A.1 { @ Area (minimum) >= 0.8 
  AREA DUM6 < 0.8 
}
DM6.A.2 { @ Area (maximum) <= 160 
  AREA DUM6 > 160 
}

#ELSE


DM6.W.1 { @ Width (minimum) >= 0.4
  INT DUM6 < 0.4 ABUT < 90 SINGULAR REGION
}
DM6.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM6 BY 1.5 UNDEROVER
}
DM6.S.1 { @ Space >= 0.4
  EXT DUM6 < 0.4 ABUT < 90 SINGULAR REGION
}
DM6.S.2 { @ Space to M6 [overlap is not allowed] >= 0.6
  EXT M6x DUM6 < 0.6 ABUT < 90 SINGULAR REGION
  M6x AND DUM6
}
DM6.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM6 < 0.36 
}
DM6.A.2 { @ Area (maximum) <= 80
  AREA DUM6 > 80 
}
#ENDIF

DM6.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM6 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM6
}
DM6.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM6 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM6
}
DM6.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM6
}
DM6.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM6 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM6
}

#IFDEF FULL_CHIP
DM6.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUM6 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M6 section

#IFDEF FULL_CHIP
DM6.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM6
}
#ENDIF

// DM6.R.2 is checked by CSR.R.1

DM6.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUM6
  NOT RECTANGLE DUM6 ORTHOGONAL ONLY
}


#IFDEF THICK_TOP2_METAL

DM7.W.1 { @ Width (minimum) >= 0.8
  INT DUM7 < 0.8 ABUT < 90 SINGULAR REGION
}
DM7.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM7 BY 1.5 UNDEROVER
}
DM7.S.1 { @ Space >= 0.8
  EXT DUM7 < 0.8 ABUT < 90 SINGULAR REGION
}
DM7.S.2 { @ Space to M7 [overlap is not allowed] >= 0.6
  EXT M7x DUM7 < 0.6 ABUT < 90 SINGULAR REGION
  M7x AND DUM7
}
DM7.A.1 { @ Area (minimum) >= 0.8
  AREA DUM7 < 0.8 
}
DM7.A.2 { @ Area (maximum) <= 160 
  AREA DUM7 > 160 
}

#ELSE


#IFDEF THICK_TOP3_METAL

DM7.W.1 { @ Width (minimum) >= 0.8
  INT DUM7 < 0.8 ABUT < 90 SINGULAR REGION
}
DM7.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM7 BY 1.5 UNDEROVER
}
DM7.S.1 { @ Space >= 0.8
  EXT DUM7 < 0.8 ABUT < 90 SINGULAR REGION
}
DM7.S.2 { @ Space to M7 [overlap is not allowed] >= 0.6
  EXT M7x DUM7 < 0.6 ABUT < 90 SINGULAR REGION
  M7x AND DUM7
}
DM7.A.1 { @ Area (minimum) >= 0.8 
  AREA DUM7 < 0.8 
}
DM7.A.2 { @ Area (maximum) <= 160 
  AREA DUM7 > 160 
}

#ELSE


DM7.W.1 { @ Width (minimum) >= 0.4
  INT DUM7 < 0.4 ABUT < 90 SINGULAR REGION
}
DM7.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM7 BY 1.5 UNDEROVER
}
DM7.S.1 { @ Space >= 0.4
  EXT DUM7 < 0.4 ABUT < 90 SINGULAR REGION
}
DM7.S.2 { @ Space to M7 [overlap is not allowed] >= 0.6
  EXT M7x DUM7 < 0.6 ABUT < 90 SINGULAR REGION
  M7x AND DUM7
}
DM7.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM7 < 0.36 
}
DM7.A.2 { @ Area (maximum) <= 80
  AREA DUM7 > 80 
}
#ENDIF
#ENDIF

DM7.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM7 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM7
}
DM7.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM7 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM7
}
DM7.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM7
}
DM7.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM7 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM7
}

#IFDEF FULL_CHIP
DM7.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUM7 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M7 section

#IFDEF FULL_CHIP
DM7.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM7
}
#ENDIF

// DM7.R.2 is checked by CSR.R.1

DM7.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUM7
  NOT RECTANGLE DUM7 ORTHOGONAL ONLY
}

DM8.W.1 { @ Width (minimum) >= 0.8
  INT DUM8 < 0.8 ABUT < 90 SINGULAR REGION
}
DM8.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM8 BY 1.5 UNDEROVER
}
DM8.S.1 { @ Space >= 0.8
  EXT DUM8 < 0.8 ABUT < 90 SINGULAR REGION
}
DM8.S.2 { @ Space to M8 [overlap is not allowed] >= 0.6
  EXT M8x DUM8 < 0.6 ABUT < 90 SINGULAR REGION
  M8x AND DUM8
}
DM8.A.1 { @ Area (minimum) >= 0.8 
  AREA DUM8 < 0.8 
}
DM8.A.2 { @ Area (maximum) <= 160 
  AREA DUM8 > 160 
}

DM8.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM8 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM8
}
DM8.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM8 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM8
}
DM8.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM8
}
DM8.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM8 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM8
}

#IFDEF FULL_CHIP
DM8.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUM8 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M8 section

#IFDEF FULL_CHIP
DM8.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM8
}
#ENDIF

// DM8.R.2 is checked by CSR.R.1

DM8.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUM8
  NOT RECTANGLE DUM8 ORTHOGONAL ONLY
}

DMD.W.1 { @ Width (minimum) >= 0.8
  INT DUMD < 0.8 ABUT < 90 SINGULAR REGION
}
DMD.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUMD BY 1.5 UNDEROVER
}
DMD.S.1 { @ Space >= 0.8
  EXT DUMD < 0.8 ABUT < 90 SINGULAR REGION
}
DMD.S.2 { @ Space to MD [overlap is not allowed] >= 0.6
  EXT MDx DUMD < 0.6 ABUT < 90 SINGULAR REGION
  MDx AND DUMD
}
DMD.A.1 { @ Area (minimum) >= 0.8 
  AREA DUMD < 0.8 
}
DMD.A.2 { @ Area (maximum) <= 160 
  AREA DUMD > 160 
}

DMD.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUMD < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUMD
}
DMD.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUMD < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUMD
}
DMD.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUMD
}
DMD.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUMD < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUMD
}

#IFDEF FULL_CHIP
DMD.EN.1 { @ Enclosure by chip edge  >= 2.5 
  DUMD NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in MD section

#IFDEF FULL_CHIP
DMD.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  (CHIP_CHAMFERED INTERACT MDx) NOT INTERACT DUMD
}
#ENDIF

// DMD.R.2 is checked by CSR.R.1

DMD.R.3 { @ The only shapes allowed are square (or rectangular) and solid.    
  HOLES DUMD
  NOT RECTANGLE DUMD ORTHOGONAL ONLY
}

DM7.S.8 { @ Space to CBM [CBM between Mx and Mx+1] [overlap is not allowed] >= 1.5 
  EXT CBM DUM7 < 1.5 ABUT < 90 SINGULAR REGION 
  CBM AND DUM7
}



//LAT CHECKS
//==========

PMOSi = (PACTi INTERACT POLYGi) INTERACT CONTi //Interact CONTi to filter out filler cell.
NMOSi = (NACTi INTERACT POLYGi) INTERACT CONTi

// LUP.1 is not able to check

LUP.2 { @ For I/O buffers and ESD devices, space between each NMOS and PMOS. >= 15 
  EXT EPMOS ENMOS < 15 ABUT <90 >0 SINGULAR
}

CO_pact = CONTi OR (PSDi NOT OUTSIDE CONTi)
LUP.3P { @ For I/O and internal circuits, space from any point inside the source/drain OD area to the nearest pickup OD in the same N-well or P-well. For only NMOS in the DNW [without the PMOS in NW overlapping with the DNW], there is no latch-up risk. The space from any point inside the source/drain OD area to the nearest pickup OD depends on the maximum allowed back bias. <= 30 
  NPUi = NSTPi INTERACT CO_pact
  NSTPi_OS = SIZE NPUi BY 30 INSIDE OF NWELLi STEP 0.438 TRUNCATE 0.438
  PMOSi NOT NSTPi_OS
}
CO_nact = CONTi OR (NSDi NOT OUTSIDE CONTi)
LUP.3N { @ For I/O and internal circuits, space from any point inside the source/drain OD area to the nearest pickup OD in the same N-well or P-well. For only NMOS in the DNW [without the PMOS in NW overlapping with the DNW], there is no latch-up risk. The space from any point inside the source/drain OD area to the nearest pickup OD depends on the maximum allowed back bias. <= 30 
  PPUi = PSTPi INTERACT CO_nact
  PSTPi_OS = SIZE PPUi BY 30 INSIDE OF PWELi STEP 0.438 TRUNCATE 0.438
  NMOSi NOT PSTPi_OS
}
// LUP.4 is not able to check
// LUP.5 is not able to check
// LUP.6 is not able to check
// LUP.7 is not able to check
// LUP.8 is not able to check
// LUP.9 is not able to check
 


#IFDEF GUIDELINE_ESD

// I/O ESD Guidance
//==================

EPSD  = SDI  AND PASD
ENSD  = SDI  AND NASD
ED    = EPSD OR  ENSD
ECO = (CO AND SDI) AND OD
EGTE = SDI AND GATE
EGTE_W = GATE_W INSIDE EDGE SDI
EGTEN_W  = EGTE_W INSIDE EDGE NP
ENSD_NCO = (ENSD NOT INTERACT ECO) NOT INTERACT PSTP
ENSD_WCO = ENSD NOT ENSD_NCO
ENSD_SRC = ENSD_WCO OUTSIDE RPO

ESD1_GATE = EGTE AND ESD1DMY

ESD2_GATE = EGTE AND ESD2DMY
ESD2_REG_GATE = ESD2_GATE NOT INTERACT ENSD_NCO
ESD2_REG_GATE_W = ESD2_REG_GATE INSIDE EDGE OD

ESD2_TOL = (ENMOS AND ESD2DMY) INTERACT ENSD_NCO
ESD2_TOL_GATE = ESD2_GATE INTERACT ENSD_NCO
ESD2_TOL_GATE1 = ESD2_TOL_GATE NOT INTERACT ENSD_SRC
ESD2_TOL_GATE2 = ESD2_TOL_GATE INTERACT ENSD_SRC 
ESD2_TOL_GATE2_W = ESD2_TOL_GATE2 INSIDE EDGE OD

ERPO = RPO AND SDI
RPO0 = (ERPO OUTSIDE ESD1DMY) OUTSIDE ESD2DMY
EGTE0 = (EGTE OUTSIDE ESD1DMY) OUTSIDE ESD2DMY

HEGT = EGTE AND OD2
LEGT = EGTE NOT OD2
HEGN = HEGT AND NP
HEGP = HEGT AND PP


ESD.0 { @ CO can't inserted between gate and RPO for 1.0V, 1.2V NMOS and all PMOS I/O pattern 
  RED  = ED INTERACT RPO0
  XRPO = RED NOT RPO0
  XRPG = XRPO TOUCH EGTE0
  XRPG INTERACT ECO
}

// ESD.1 is not able to check

ESD.2 { @ Unit finger width of NMOS and PMOS for I/O buffer and Vdd to Vss protection. 20 - 60um
  PATH LENGTH EGTE_W < 20
  PATH LENGTH EGTE_W > 60
}

// ESD.3 is not able to check
// ESD.4 is not able to check
// ESD.5 is not able to check
// ESD.6 is not able to check
// ESD.7 is not able to check
// ESD.8 is not able to check


#IFDEF 3.3V
VARIABLE HighVoltage 3.3
VARIABLE WiESDVdd 0.35
VARIABLE WiESD1st 0.37
VARIABLE WiESD2nd 0.35
VARIABLE WoESD 0.4
#ENDIF

#IFDEF 2.5V
VARIABLE HighVoltage 2.5
VARIABLE WiESDVdd 0.33
VARIABLE WiESD1st 0.35
VARIABLE WiESD2nd 0.33
VARIABLE WoESD 0.33
#ENDIF

#IFDEF 1.8V
VARIABLE HighVoltage 1.8
VARIABLE WiESDVdd 0.20
VARIABLE WiESD1st 0.20
VARIABLE WiESD2nd 0.33
VARIABLE WoESD 0.20
#ENDIF

ESD.9A { @ ^HighVoltage V NMOS for VDD/VSS protection gate length < ^WiESDVdd um
  HEGN1 = HEGN AND ESD1DMY
  INT HEGN1 < WiESDVdd ABUT < 90 SINGULAR REGION
}
ESD.9B { @ 1.0V, 1.2V NMOS for VDD/VSS protection gate length < 0.18 um
  LEGN = LEGT AND NP
  LEGN1 = LEGN AND ESD1DMY
  INT LEGN1 < 0.18 ABUT < 90 SINGULAR REGION
}
ESD.9C { @ Min. length of 1st gate of ^HighVoltage V NMOS for HV tolerant I/O (with ESD implant) is ^WiESD1st um
  HEGN5 = ESD2_TOL_GATE1 INTERACT ESD3DMY
  INT HEGN5 < WiESD1st ABUT < 90 SINGULAR REGION
}
ESD.9D { @ Min. length of 2nd gate of ^HighVoltage V NMOS for HV tolerant I/O (with ESD implant) is ^WiESD2nd um
  HEGN6 = ESD2_TOL_GATE2 INTERACT ESD3DMY
  INT HEGN6 < WiESD2nd ABUT < 90 SINGULAR REGION
}
ESD.9E { @ ^HighVoltage V IO ESD NMOS (without ESD implant) gate length < ^WoESD um
  A = HEGN NOT INTERACT ESD3DMY
  HEGN2 = A NOT ESD1DMY
  INT HEGN2 < WoESD ABUT < 90 SINGULAR REGION
}
ESD.9F { @ ^HighVoltage V IO ESD PMOS gate length < 0.3 um
  INT HEGP < 0.3 ABUT < 90 SINGULAR REGION
}
ESD.9G { @ 1.0V, 1.2V IO ESD NMOS/PMOS gate length < 0.18 um
  INT LEGT < 0.18 ABUT < 90 SINGULAR REGION
}

// ESD.10 is not able to check
// ESD.11 is not able to check
// ESD.12 is not able to check
// ESD.13 is not able to check
// ESD.14 is not able to check
// ESD.15 is not able to check

ESD.16 { @ for 1.0V, 1.2V I/O, min. RPO space to poly in NMOS is 0.45um
	 @ for all PMOS, min. RPO space to poly is 0.45um
  EXT RPO0 EGTE0 < 0.45 ABUT < 90 SINGULAR REGION
}
ESD.17 { @ For 3.3V or 2.5V I/O, RPO on the drain side of NMOS region needs to overlap the poly gate by 0.06um
  X = ESD2_REG_GATE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY 0.06
  (ESD2_REG_GATE AND RPO) XOR Y
}
ESD.18A { @ For high voltage tolerant I/O design by 3.3V or 2.5V NMOS
	  @ RPO needs to complete cover all inactive gates
  ESD2_TOL_GATE1 NOT RPO
}
ESD.18B { @ For high voltage tolerant I/O design by 3.3V or 2.5V NMOS
	  @ RPO needs to overlap second poly gate by 0.06um
  ESD2_TOL_GATE2 OUTSIDE RPO
  X = ESD2_TOL_GATE NOT RPO
  ESD2_TOL NOT INTERACT X
  Y = ESD2_TOL_GATE2_W INSIDE EDGE RPO
  Z = EXPAND EDGE Y INSIDE BY 0.06
  (ESD2_TOL_GATE2 AND RPO) XOR Z
}
ESD.18C { @ For high voltage tolerant I/O design by 3.3V or 2.5V NMOS 
	  @ the 1st poly gate space to 2st poly gate == 0.25um
  X = ENSD_NCO INTERACT ESD2DMY
  INT X < 0.25 ABUT < 90 REGION
  SIZE X BY 0.125 UNDEROVER
}

// ESD.19 is checked by ESD.16

ESD.20 { @ For grounded gate ESD protection device between Vdd/Vss, the RPO should fully cover source/drain and the poly gate on top of channel.
  ESD1_GATE NOT RPO	 
}

// ESD.21 is not able to check

ESD.22 { @ I/O Min. RPO width on drain side & RPO edge to OD edge for 3.3V or 2.5V NMOS is 1.95 um
  X = (ENSD_WCO AND ESD2DMY) AND RPO
  INT X < 1.95 ABUT < 90 REGION
}
ESD.23 { @ For 1.0V, 1.2V NMOS or 1.0V, 1.2V/3.3V or 2.5V PMOS 
         @ min. width of RPO on drain side and RPO edge to OD edge 1.5um
  X = RPO0 AND ED
  INT X < 1.5 ABUT < 90 REGION
}
ESD.24 { @ ESD1DMY is for NMOS only / ESD2DMY is for 3.3V or 2.5V NMOS only
  ESD1DMY AND GATE_PP
  ESD2DMY AND GATE_PP
  ESD2DMY AND (GATE_NP NOT OD2)
}
ESD.25 { @ Min. extension of ESD3DMY over OD 0.1 um
  ENC OD ESD3DMY < 0.1 SINGULAR REGION
}
ESD.26 { @ Min. space between CO on source side to poly gate 0.75um
  EXT ECO EGTEN_W < 0.75 ABUT < 90 OPPOSITE REGION
}

// ESD.27 is not able to check
// ESD.28 is not able to check
// ESD.29 is not able to check
// ESD.30 is not able to check
// ESD.31 is not able to check
// ESD.32 is not able to check
// ESD.33 is not able to check
// ESD.34 is not able to check
// ESD.35 is not able to check
// ESD.36 is not able to check
// ESD.37 is not able to check

#ENDIF  // GUIDELINE_ESD


#IFDEF SUGGESTED

SUGGESTED.EXCL_DMSRM { @ Boundary of overlapped EXCL and DMSRM layers must be aligned 
  A = EXCLi NOT OUTSIDE DMSRMi
  B = DMSRMi NOT OUTSIDE EXCLi
  A XOR B
} 

SUGGESTED.EXCL_SRM.NW { @ Spacing between NW along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.62 + 0.005)
  B = SIZE EXCL_SRM BY -(0.62 + 0.005)
  C = A NOT B
  D = NWELLi NOT OUTSIDE C
  E = EXT D < 0.62 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.OD { @ Spacing between OD along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.21 + 0.005)
  B = SIZE EXCL_SRM BY -(0.21 + 0.005)
  C = A NOT B
  D = ODi NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.PO { @ Spacing between POLY along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.13 + 0.005)
  B = SIZE EXCL_SRM BY -(0.13 + 0.005)
  C = A NOT B
  D = POLYGi NOT OUTSIDE C
  E = EXT D < 0.13 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.NP { @ Spacing between NP along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.31 + 0.005)
  B = SIZE EXCL_SRM BY -(0.31 + 0.005)
  C = A NOT B
  D = NIMPi NOT OUTSIDE C
  E = EXT D < 0.31 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.PP { @ Spacing between PP along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.31 + 0.005)
  B = SIZE EXCL_SRM BY -(0.31 + 0.005)
  C = A NOT B
  D = PIMPi NOT OUTSIDE C
  E = EXT D < 0.31 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.CO { @ Spacing between CO along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.18 + 0.005)
  B = SIZE EXCL_SRM BY -(0.18 + 0.005)
  C = A NOT B
  D = CONTi NOT OUTSIDE C
  E = EXT D < 0.18 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.M1 { @ Spacing between M1 along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.18 + 0.005)
  B = SIZE EXCL_SRM BY -(0.18 + 0.005)
  C = A NOT B
  D = M1x NOT OUTSIDE C
  E = EXT D < 0.18 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.VIA1 { @ Spacing between VIA1 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA12i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M2 { @ Spacing between M2 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M2x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA2 { @ Spacing between VIA2 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA23i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M3 { @ Spacing between M3 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M3x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA3 { @ Spacing between VIA3 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA34i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M4 { @ Spacing between M4 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M4x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA4 { @ Spacing between VIA4 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA45i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M5 { @ Spacing between M5 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M5x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA5 { @ Spacing between VIA5 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA56i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M6 { @ Spacing between M6 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M6x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA6 { @ Spacing between VIA6 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA67i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M7 { @ Spacing between M7 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M7x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA7 { @ Spacing between VIA7 along the boundary of EXCL
  A = SIZE EXCL BY (0.35 + 0.005)
  B = SIZE EXCL BY -(0.35 + 0.005)
  C = A NOT B
  D = VIA78i NOT OUTSIDE C
  E = EXT D < 0.35 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M8 { @ Spacing between M8 along the boundary of EXCL
  A = SIZE EXCL BY (0.42 + 0.005)
  B = SIZE EXCL BY -(0.42 + 0.005)
  C = A NOT B
  D = M8x NOT OUTSIDE C
  E = EXT D < 0.42 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}


OD_NO_IMP = (((OD NOT ODWR) NOT LOGO) NOT CDUDMY) NOT IMP

SUGGESTED.OD.IMP { @ OD without IMP
  COPY OD_NO_IMP
}

SUGGESTED.OD.NW { @ OD straddle on NW without IMP
  OD_NO_IMP CUT NONWR
//  ENC OD_NO_IMP NONWR < 0.24 ABUT < 90 OVERLAP SINGULAR REGION
//  EXT NONWR OD_NO_IMP < 0.24 ABUT < 90 SINGULAR REGION
}

SUGGESTED.SDI_RHDMY { @ SDI should be for ESD devices only 
  SDI AND RHDMY
}

SUGGESTED.SDI_RPDMY { @ SDI should be for ESD devices only 
  SDI AND RPDMY
}

SUGGESTED.MS.M1 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M1HoleD NOT INTERACT (SIZE M1HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M2 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M2HoleD NOT INTERACT (SIZE M2HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M3 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M3HoleD NOT INTERACT (SIZE M3HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M4 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M4HoleD NOT INTERACT (SIZE M4HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M5 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M5HoleD NOT INTERACT (SIZE M5HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M6 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M6HoleD NOT INTERACT (SIZE M6HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M7 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M7HoleD NOT INTERACT (SIZE M7HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M8 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M8HoleD NOT INTERACT (SIZE M8HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}

SUGGESTED.MS.MD { @ Avoid long (>200um) and narrow (<3um) slots
  X = MDHoleD NOT INTERACT (SIZE MDHoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}

#ENDIF



// Analog Checks
//==============

PP_EMOD = PACT AND BJTDMY
NP_EMOD = NACT AND BJTDMY
EMOD = PP_EMOD OR NP_EMOD

BJT.R.1 { @ RPO needs to cover ^BJT_R_1 on EM OD edge from OD and STI sides
     X = ( SIZE EMOD BY BJT_R_1 ) NOT ( SIZE EMOD BY -BJT_R_1 )
     Y = RPO INTERACT EMOD
     X XOR Y
}

RES2m_POCellIn = INSIDE CELL POLYGi CellsForRRuleAnalog  
RES2m_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleAnalog 
RES2m_POCell = RES2m_POCellIn AND RES2m_POCellOut
RES2m_POMarker = POLYGi AND RRuleAnalog
RES2m_PO = (( RES2m_POCell OR RES2m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RES2m_PORES = PORES AND RES2m_PO

RES.2m { @ Width >= 1.0um and length >= 2.0um for unsilicided PO resistor
  INT RES2m_PORES < 1.0 ABUT < 90 SINGULAR REGION
  RES_L = RES2m_PORES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < 2.0
  CHECK_RES = RES2m_PORES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 1.0 - GRID*2 ) INSIDE OF RES2m_PORES STEP PO_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}

RES3m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
RES3m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
RES3m_ODCell = RES3m_ODCellIn AND RES3m_ODCellOut
RES3m_ODMarker = ODi AND RRuleAnalog
RES3m_OD = (( RES3m_ODCell OR RES3m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RES3m_POCellIn = INSIDE CELL POLYGi CellsForRRuleAnalog  
RES3m_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleAnalog 
RES3m_POCell = RES3m_POCellIn AND RES3m_POCellOut
RES3m_POMarker = POLYGi AND RRuleAnalog
RES3m_PO = (( RES3m_POCell OR RES3m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RES3m_PORES = ( PORES AND HRI ) AND RES3m_PO
RES3m_ODRES = ( ODRES AND RES3m_OD ) OR RES3m_PORES
RES.2m.OD { @ Width >= 2.0um and length >= 10.0um for unsilicided OD/HRI resistor
  INT RES3m_ODRES < 2.0 ABUT < 90 SINGULAR REGION
  RES_L = RES3m_ODRES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < 10.0
  CHECK_RES = RES3m_ODRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 2.0 - GRID*2 ) INSIDE OF RES3m_ODRES STEP OD_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  Y = CHECK_RES INTERACT D
  Y NOT INSIDE DIODMY
}

NWRODR1m_NWCellIn = INSIDE CELL NWELLi CellsForRRuleAnalog  
NWRODR1m_NWCellOut = NOT INSIDE CELL NWELLi ExclCellsForRRuleAnalog 
NWRODR1m_NWCell = NWRODR1m_NWCellIn AND NWRODR1m_NWCellOut
NWRODR1m_NWMarker = NWELLi AND RRuleAnalog
NWRODR1m_NW = (( NWRODR1m_NWCell OR NWRODR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

NWRODR1m_NWRES = ( NWRODR1m_NW AND NWRES ) AND NWDMY
NWROD.R.1m { @ Width >= 1.8um and length >= 20um for NW resistor with OD
  INT NWRODR1m_NWRES < 1.8 ABUT < 90 SINGULAR REGION
  RES_L = NWRODR1m_NWRES INSIDE EDGE NWDMY
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRODR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRODR1m_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}

NWRSTIR1m_NWCellIn = INSIDE CELL NWELLi CellsForRRuleAnalog  
NWRSTIR1m_NWCellOut = NOT INSIDE CELL NWELLi ExclCellsForRRuleAnalog 
NWRSTIR1m_NWCell = NWRSTIR1m_NWCellIn AND NWRSTIR1m_NWCellOut
NWRSTIR1m_NWMarker = NWELLi AND RRuleAnalog
NWRSTIR1m_NW = (( NWRSTIR1m_NWCell OR NWRSTIR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

NWRSTIR1m_NWRES = ( NWRSTIR1m_NW AND NWRES_STI ) AND NWDMY
NWRSTI.R.1m { @ Width >= 1.8um and length >= 20um for NW resistor under STI
  INT NWRSTIR1m_NWRES < 1.8 ABUT < 90 SINGULAR REGION
  RES_L = NWRSTIR1m_NWRES INSIDE EDGE NWDMY
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRSTIR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRSTIR1m_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}


// For TSMC's internal use only
GROUP SINGLE_VIA VIA?.R.2?
//DRC UNSELECT CHECK SINGLE_VIA 
#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY
GROUP DENSITY_DRC OD.DN.?  DM?.DN.?
#ELSE
GROUP DENSITY_DRC OD.DN.?  M?.DN.? 
#ENDIF
//DRC UNSELECT CHECK DENSITY_DRC  
#ENDIF  // DFM_ONLY

#IFDEF DFM

#IFDEF Required
#IFDEF _POS2_
POS2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS2_ODCell = POS2_ODCellIn AND POS2_ODCellOut
POS2_ODMarker = ODi AND RRuleRequired
POS2_OD = (( POS2_ODCell OR POS2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

POS2_GATE_W = POLY INSIDE EDGE POS2_OD
POS2_GATE  = POLY AND POS2_OD
RR:AR:POS2 { @ Recommended gate space in the same OD >= 0.23
    EXT POS2_GATE_W < 0.23 ABUT < 90 REGION 
    EXT POS2_GATE < 0.23 ABUT < 90 REGION CORNER TO CORNER
}
#ENDIF // _POS2_

POMergeOD = POLY OR OD
UShapeEdge = CONVEX EDGE POMergeOD ANGLE1==270 ANGLE2==270
ODCorner = EXT OD < 0.01 ABUT == 90 INTERSECTING ONLY REGION
POCorner = EXT POLY < 0.01 ABUT == 90 INTERSECTING ONLY REGION
POS4_GATE_W = LENGTH GATE_W <= 0.3
POS4_GATE_L = GATE_L COIN INSIDE EDGE ( GATE WITH EDGE POS4_GATE_W )


#IFDEF _POS4_
POS4_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS4_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS4_ODCell = POS4_ODCellIn AND POS4_ODCellOut
POS4_ODMarker = ODi AND RRuleRequired
POS4_OD = (( POS4_ODCell OR POS4_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

POS4_POCellIn = INSIDE CELL POLYGi CellsForRRuleRequired  
POS4_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleRequired 
POS4_POCell = POS4_POCellIn AND POS4_POCellOut
POS4_POMarker = POLYGi AND RRuleRequired
POS4_PO = (( POS4_POCell OR POS4_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

LPO = ( UShapeEdge COIN INSIDE EDGE POS4_PO ) TOUCH EDGE POCorner
ValidLPOExp = ( EXPAND EDGE LPO INSIDE BY 0.01 ) WITH EDGE POS4_GATE_L
RR:AR:POS4:PO = LPO COIN INSIDE EDGE ValidLPOExp
RR:AR:POS4:PO { @ space of L-shape PO  >= 0.12um
    LENGTH RR:AR:POS4:PO < 0.12
}

LOD = ( UShapeEdge COIN INSIDE EDGE POS4_OD ) TOUCH EDGE ODCorner
ValidLODExp = ( EXPAND EDGE LOD INSIDE BY 0.01 ) WITH EDGE POS4_GATE_W
LOD0.07 = EXPAND EDGE ( LENGTH ( LOD COIN INSIDE EDGE ValidLODExp ) == 0.07 ) INSIDE BY 0.01
POS4GATE = GATE INTERACT LOD0.07
RR:AR:POS4:OD { @ H-OD is better when space == 0.07um
    POS4GATE NOT INTERACT ValidLODExp == 4
}

#ENDIF // _POS4_

#IFDEF _POEX2_
POEX2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POEX2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POEX2_ODCell = POEX2_ODCellIn AND POEX2_ODCellOut
POEX2_ODMarker = ODi AND RRuleRequired
POEX2_OD = (( POEX2_ODCell OR POEX2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:AR:POEX2 { @ Recommended OD extension on PO >= 0.34 um
    (ENC POLY POEX2_OD < 0.34 ABUT < 89.5 SINGULAR REGION OPPOSITE ) NOT INSIDE LOGO
}
#ENDIF // _POEX2_

#ENDIF // Required

#IFDEF Recommended

#IFDEF _OPCR1_
OPCR1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
OPCR1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
OPCR1_ODCell = OPCR1_ODCellIn AND OPCR1_ODCellOut
OPCR1_ODMarker = ODi AND RRuleRecommended
OPCR1_OD = (( OPCR1_ODCell OR OPCR1_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_OD_ShortExp = EXPAND EDGE ( LENGTH OPCR1_OD < OD_W_1 ) BY 0.01
OPCR1_OD_SmallJog = (VERTEX OPCR1_OD_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:OD { @ Consecutive small OD jogs are not recommended.
    ODi INSIDE EDGE OPCR1_OD_SmallJog
}
OPCR1_POCellIn = INSIDE CELL POLYGi CellsForRRuleRecommended  
OPCR1_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleRecommended 
OPCR1_POCell = OPCR1_POCellIn AND OPCR1_POCellOut
OPCR1_POMarker = POLYGi AND RRuleRecommended
OPCR1_PO = (( OPCR1_POCell OR OPCR1_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_PO_ShortExp = EXPAND EDGE ( LENGTH OPCR1_PO < PO_W_3 ) BY 0.01
OPCR1_PO_SmallJog = (VERTEX OPCR1_PO_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:PO { @ Consecutive small PO jogs are not recommended.
    POLYGi INSIDE EDGE OPCR1_PO_SmallJog
}
OPCR1_NPCellIn = INSIDE CELL NIMPi CellsForRRuleRecommended  
OPCR1_NPCellOut = NOT INSIDE CELL NIMPi ExclCellsForRRuleRecommended 
OPCR1_NPCell = OPCR1_NPCellIn AND OPCR1_NPCellOut
OPCR1_NPMarker = NIMPi AND RRuleRecommended
OPCR1_NP = (( OPCR1_NPCell OR OPCR1_NPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_NP_ShortExp = EXPAND EDGE ( LENGTH OPCR1_NP < NP_W_1 ) BY 0.01
OPCR1_NP_SmallJog = (VERTEX OPCR1_NP_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:NP { @ Consecutive small NP jogs are not recommended.
    NIMPi INSIDE EDGE OPCR1_NP_SmallJog
}
OPCR1_PPCellIn = INSIDE CELL PIMPi CellsForRRuleRecommended  
OPCR1_PPCellOut = NOT INSIDE CELL PIMPi ExclCellsForRRuleRecommended 
OPCR1_PPCell = OPCR1_PPCellIn AND OPCR1_PPCellOut
OPCR1_PPMarker = PIMPi AND RRuleRecommended
OPCR1_PP = (( OPCR1_PPCell OR OPCR1_PPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_PP_ShortExp = EXPAND EDGE ( LENGTH OPCR1_PP < PP_W_1 ) BY 0.01
OPCR1_PP_SmallJog = (VERTEX OPCR1_PP_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:PP { @ Consecutive small PP jogs are not recommended.
    PIMPi INSIDE EDGE OPCR1_PP_SmallJog
}
OPCR1_VTHNCellIn = INSIDE CELL VTH_Ni CellsForRRuleRecommended  
OPCR1_VTHNCellOut = NOT INSIDE CELL VTH_Ni ExclCellsForRRuleRecommended 
OPCR1_VTHNCell = OPCR1_VTHNCellIn AND OPCR1_VTHNCellOut
OPCR1_VTHNMarker = VTH_Ni AND RRuleRecommended
OPCR1_VTHN = (( OPCR1_VTHNCell OR OPCR1_VTHNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_VTHN_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VTHN < VTH_N_W_1 ) BY 0.01
OPCR1_VTHN_SmallJog = (VERTEX OPCR1_VTHN_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:VTHN { @ Consecutive small VTH_N jogs are not recommended.
    VTH_Ni INSIDE EDGE OPCR1_VTHN_SmallJog
}
OPCR1_VTHPCellIn = INSIDE CELL VTH_Pi CellsForRRuleRecommended  
OPCR1_VTHPCellOut = NOT INSIDE CELL VTH_Pi ExclCellsForRRuleRecommended 
OPCR1_VTHPCell = OPCR1_VTHPCellIn AND OPCR1_VTHPCellOut
OPCR1_VTHPMarker = VTH_Pi AND RRuleRecommended
OPCR1_VTHP = (( OPCR1_VTHPCell OR OPCR1_VTHPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_VTHP_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VTHP < VTH_P_W_1 ) BY 0.01
OPCR1_VTHP_SmallJog = (VERTEX OPCR1_VTHP_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:VTHP { @ Consecutive small VTH_P jogs are not recommended.
    VTH_Pi INSIDE EDGE OPCR1_VTHP_SmallJog
}
OPCR1_VTLNCellIn = INSIDE CELL VTL_Ni CellsForRRuleRecommended  
OPCR1_VTLNCellOut = NOT INSIDE CELL VTL_Ni ExclCellsForRRuleRecommended 
OPCR1_VTLNCell = OPCR1_VTLNCellIn AND OPCR1_VTLNCellOut
OPCR1_VTLNMarker = VTL_Ni AND RRuleRecommended
OPCR1_VTLN = (( OPCR1_VTLNCell OR OPCR1_VTLNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_VTLN_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VTLN < VTL_N_W_1 ) BY 0.01
OPCR1_VTLN_SmallJog = (VERTEX OPCR1_VTLN_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:VTLN { @ Consecutive small VTL_N jogs are not recommended.
    VTL_Ni INSIDE EDGE OPCR1_VTLN_SmallJog
}
OPCR1_VTLPCellIn = INSIDE CELL VTL_Pi CellsForRRuleRecommended  
OPCR1_VTLPCellOut = NOT INSIDE CELL VTL_Pi ExclCellsForRRuleRecommended 
OPCR1_VTLPCell = OPCR1_VTLPCellIn AND OPCR1_VTLPCellOut
OPCR1_VTLPMarker = VTL_Pi AND RRuleRecommended
OPCR1_VTLP = (( OPCR1_VTLPCell OR OPCR1_VTLPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_VTLP_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VTLP < VTL_P_W_1 ) BY 0.01
OPCR1_VTLP_SmallJog = (VERTEX OPCR1_VTLP_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:VTLP { @ Consecutive small VTL_P jogs are not recommended.
    VTL_Pi INSIDE EDGE OPCR1_VTLP_SmallJog
}

OPCR1_M1CellIn = INSIDE CELL METAL1i CellsForRRuleRecommended  
OPCR1_M1CellOut = NOT INSIDE CELL METAL1i ExclCellsForRRuleRecommended 
OPCR1_M1Cell = OPCR1_M1CellIn AND OPCR1_M1CellOut
OPCR1_M1Marker = METAL1i AND RRuleRecommended
OPCR1_M1 = (( OPCR1_M1Cell OR OPCR1_M1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR1_M1_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M1 < M1_W_1 ) BY 0.01
OPCR1_M1_SmallJog = (VERTEX OPCR1_M1_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
RR:RE:OPCR1:M1 { @ Consecutive small M1 jogs are not recommended.
    METAL1i INSIDE EDGE OPCR1_M1_SmallJog
}

OPCR1_M2CellIn = INSIDE CELL METAL2i CellsForRRuleRecommended  
OPCR1_M2CellOut = NOT INSIDE CELL METAL2i ExclCellsForRRuleRecommended 
OPCR1_M2Cell = OPCR1_M2CellIn AND OPCR1_M2CellOut
OPCR1_M2Marker = METAL2i AND RRuleRecommended
OPCR1_M2 = (OPCR1_M2Cell OR OPCR1_M2Marker) NOT Block

OPCR1_M2_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M2 < M2_W_1 ) BY 0.01
OPCR1_M2_SmallJog = VERTEX OPCR1_M2_ShortExp > 4
RR:RE:OPCR1:M2 { @ Consecutive small M2 jogs are not recommended.
    METAL2i INSIDE EDGE OPCR1_M2_SmallJog
}
OPCR1_M3CellIn = INSIDE CELL METAL3i CellsForRRuleRecommended  
OPCR1_M3CellOut = NOT INSIDE CELL METAL3i ExclCellsForRRuleRecommended 
OPCR1_M3Cell = OPCR1_M3CellIn AND OPCR1_M3CellOut
OPCR1_M3Marker = METAL3i AND RRuleRecommended
OPCR1_M3 = (OPCR1_M3Cell OR OPCR1_M3Marker) NOT Block

OPCR1_M3_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M3 < M3_W_1 ) BY 0.01
OPCR1_M3_SmallJog = VERTEX OPCR1_M3_ShortExp > 4
RR:RE:OPCR1:M3 { @ Consecutive small M3 jogs are not recommended.
    METAL3i INSIDE EDGE OPCR1_M3_SmallJog
}
OPCR1_M4CellIn = INSIDE CELL METAL4i CellsForRRuleRecommended  
OPCR1_M4CellOut = NOT INSIDE CELL METAL4i ExclCellsForRRuleRecommended 
OPCR1_M4Cell = OPCR1_M4CellIn AND OPCR1_M4CellOut
OPCR1_M4Marker = METAL4i AND RRuleRecommended
OPCR1_M4 = (OPCR1_M4Cell OR OPCR1_M4Marker) NOT Block

OPCR1_M4_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M4 < M4_W_1 ) BY 0.01
OPCR1_M4_SmallJog = VERTEX OPCR1_M4_ShortExp > 4
RR:RE:OPCR1:M4 { @ Consecutive small M4 jogs are not recommended.
    METAL4i INSIDE EDGE OPCR1_M4_SmallJog
}
OPCR1_M5CellIn = INSIDE CELL METAL5i CellsForRRuleRecommended  
OPCR1_M5CellOut = NOT INSIDE CELL METAL5i ExclCellsForRRuleRecommended 
OPCR1_M5Cell = OPCR1_M5CellIn AND OPCR1_M5CellOut
OPCR1_M5Marker = METAL5i AND RRuleRecommended
OPCR1_M5 = (OPCR1_M5Cell OR OPCR1_M5Marker) NOT Block

OPCR1_M5_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M5 < M5_W_1 ) BY 0.01
OPCR1_M5_SmallJog = VERTEX OPCR1_M5_ShortExp > 4
RR:RE:OPCR1:M5 { @ Consecutive small M5 jogs are not recommended.
    METAL5i INSIDE EDGE OPCR1_M5_SmallJog
}
OPCR1_M6CellIn = INSIDE CELL METAL6i CellsForRRuleRecommended  
OPCR1_M6CellOut = NOT INSIDE CELL METAL6i ExclCellsForRRuleRecommended 
OPCR1_M6Cell = OPCR1_M6CellIn AND OPCR1_M6CellOut
OPCR1_M6Marker = METAL6i AND RRuleRecommended
OPCR1_M6 = (OPCR1_M6Cell OR OPCR1_M6Marker) NOT Block

OPCR1_M6_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M6 < M6_W_1 ) BY 0.01
OPCR1_M6_SmallJog = VERTEX OPCR1_M6_ShortExp > 4
RR:RE:OPCR1:M6 { @ Consecutive small M6 jogs are not recommended.
    METAL6i INSIDE EDGE OPCR1_M6_SmallJog
}
OPCR1_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
OPCR1_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
OPCR1_M7Cell = OPCR1_M7CellIn AND OPCR1_M7CellOut
OPCR1_M7Marker = METAL7i AND RRuleRecommended
OPCR1_M7 = (OPCR1_M7Cell OR OPCR1_M7Marker) NOT Block

OPCR1_M7_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M7 < M7_W_1 ) BY 0.01
OPCR1_M7_SmallJog = VERTEX OPCR1_M7_ShortExp > 4
RR:RE:OPCR1:M7 { @ Consecutive small M7 jogs are not recommended.
    METAL7i INSIDE EDGE OPCR1_M7_SmallJog
}
OPCR1_M8CellIn = INSIDE CELL METAL8i CellsForRRuleRecommended  
OPCR1_M8CellOut = NOT INSIDE CELL METAL8i ExclCellsForRRuleRecommended 
OPCR1_M8Cell = OPCR1_M8CellIn AND OPCR1_M8CellOut
OPCR1_M8Marker = METAL8i AND RRuleRecommended
OPCR1_M8 = (OPCR1_M8Cell OR OPCR1_M8Marker) NOT Block

OPCR1_M8_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M8 < M8_W_1 ) BY 0.01
OPCR1_M8_SmallJog = VERTEX OPCR1_M8_ShortExp > 4
RR:RE:OPCR1:M8 { @ Consecutive small M8 jogs are not recommended.
    METAL8i INSIDE EDGE OPCR1_M8_SmallJog
}
#ENDIF // _OPCR1_

#IFDEF _OPCR3_
OPCR3_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
OPCR3_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
OPCR3_ODCell = OPCR3_ODCellIn AND OPCR3_ODCellOut
OPCR3_ODMarker = ODi AND RRuleRecommended
OPCR3_OD = (( OPCR3_ODCell OR OPCR3_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR3_OD_45ANGLE = OPCR3_OD ANGLE == 45 
RR:RE:OPCR3:OD { @ Recommended 45-degree edge length >= 0.5um 
    LENGTH OPCR3_OD_45ANGLE < 0.5
}
OPCR3_POCellIn = INSIDE CELL POLYGi CellsForRRuleRecommended  
OPCR3_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleRecommended 
OPCR3_POCell = OPCR3_POCellIn AND OPCR3_POCellOut
OPCR3_POMarker = POLYGi AND RRuleRecommended
OPCR3_PO = (( OPCR3_POCell OR OPCR3_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR3_PO_45ANGLE = OPCR3_PO ANGLE == 45
RR:RE:OPCR3:PO { @ Recommended 45-degree edge length >= 0.5um 
    LENGTH OPCR3_PO_45ANGLE < 0.5
}
OPCR3_M1CellIn = INSIDE CELL METAL1i CellsForRRuleRecommended  
OPCR3_M1CellOut = NOT INSIDE CELL METAL1i ExclCellsForRRuleRecommended 
OPCR3_M1Cell = OPCR3_M1CellIn AND OPCR3_M1CellOut
OPCR3_M1Marker = METAL1i AND RRuleRecommended
OPCR3_M1 = (( OPCR3_M1Cell OR OPCR3_M1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

OPCR3_M1_45ANGLE = OPCR3_M1 ANGLE == 45
RR:RE:OPCR3:M1 { @ Consecutive small M1 jogs are not recommended.
    (LENGTH OPCR3_M1_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_M2CellIn = INSIDE CELL METAL2i CellsForRRuleRecommended  
OPCR3_M2CellOut = NOT INSIDE CELL METAL2i ExclCellsForRRuleRecommended 
OPCR3_M2Cell = OPCR3_M2CellIn AND OPCR3_M2CellOut
OPCR3_M2Marker = METAL2i AND RRuleRecommended
OPCR3_M2 = (OPCR3_M2Cell OR OPCR3_M2Marker) NOT Block

OPCR3_M2_45ANGLE = METAL2i ANGLE == 45
RR:RE:OPCR3:M2 { @ Consecutive small M2 jogs are not recommended.
    LENGTH OPCR3_M2_45ANGLE < 0.5
}
OPCR3_M3CellIn = INSIDE CELL METAL3i CellsForRRuleRecommended  
OPCR3_M3CellOut = NOT INSIDE CELL METAL3i ExclCellsForRRuleRecommended 
OPCR3_M3Cell = OPCR3_M3CellIn AND OPCR3_M3CellOut
OPCR3_M3Marker = METAL3i AND RRuleRecommended
OPCR3_M3 = (OPCR3_M3Cell OR OPCR3_M3Marker) NOT Block

OPCR3_M3_45ANGLE = METAL3i ANGLE == 45
RR:RE:OPCR3:M3 { @ Consecutive small M3 jogs are not recommended.
    LENGTH OPCR3_M3_45ANGLE < 0.5
}
OPCR3_M4CellIn = INSIDE CELL METAL4i CellsForRRuleRecommended  
OPCR3_M4CellOut = NOT INSIDE CELL METAL4i ExclCellsForRRuleRecommended 
OPCR3_M4Cell = OPCR3_M4CellIn AND OPCR3_M4CellOut
OPCR3_M4Marker = METAL4i AND RRuleRecommended
OPCR3_M4 = (OPCR3_M4Cell OR OPCR3_M4Marker) NOT Block

OPCR3_M4_45ANGLE = METAL4i ANGLE == 45
RR:RE:OPCR3:M4 { @ Consecutive small M4 jogs are not recommended.
    LENGTH OPCR3_M4_45ANGLE < 0.5
}
OPCR3_M5CellIn = INSIDE CELL METAL5i CellsForRRuleRecommended  
OPCR3_M5CellOut = NOT INSIDE CELL METAL5i ExclCellsForRRuleRecommended 
OPCR3_M5Cell = OPCR3_M5CellIn AND OPCR3_M5CellOut
OPCR3_M5Marker = METAL5i AND RRuleRecommended
OPCR3_M5 = (OPCR3_M5Cell OR OPCR3_M5Marker) NOT Block

OPCR3_M5_45ANGLE = METAL5i ANGLE == 45
RR:RE:OPCR3:M5 { @ Consecutive small M5 jogs are not recommended.
    LENGTH OPCR3_M5_45ANGLE < 0.5
}
OPCR3_M6CellIn = INSIDE CELL METAL6i CellsForRRuleRecommended  
OPCR3_M6CellOut = NOT INSIDE CELL METAL6i ExclCellsForRRuleRecommended 
OPCR3_M6Cell = OPCR3_M6CellIn AND OPCR3_M6CellOut
OPCR3_M6Marker = METAL6i AND RRuleRecommended
OPCR3_M6 = (OPCR3_M6Cell OR OPCR3_M6Marker) NOT Block

OPCR3_M6_45ANGLE = METAL6i ANGLE == 45
RR:RE:OPCR3:M6 { @ Consecutive small M6 jogs are not recommended.
    LENGTH OPCR3_M6_45ANGLE < 0.5
}
OPCR3_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
OPCR3_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
OPCR3_M7Cell = OPCR3_M7CellIn AND OPCR3_M7CellOut
OPCR3_M7Marker = METAL7i AND RRuleRecommended
OPCR3_M7 = (OPCR3_M7Cell OR OPCR3_M7Marker) NOT Block

OPCR3_M7_45ANGLE = METAL7i ANGLE == 45
RR:RE:OPCR3:M7 { @ Consecutive small M7 jogs are not recommended.
    LENGTH OPCR3_M7_45ANGLE < 0.5
}
OPCR3_M8CellIn = INSIDE CELL METAL8i CellsForRRuleRecommended  
OPCR3_M8CellOut = NOT INSIDE CELL METAL8i ExclCellsForRRuleRecommended 
OPCR3_M8Cell = OPCR3_M8CellIn AND OPCR3_M8CellOut
OPCR3_M8Marker = METAL8i AND RRuleRecommended
OPCR3_M8 = (OPCR3_M8Cell OR OPCR3_M8Marker) NOT Block

OPCR3_M8_45ANGLE = METAL8i ANGLE == 45
RR:RE:OPCR3:M8 { @ Consecutive small M8 jogs are not recommended.
    LENGTH OPCR3_M8_45ANGLE < 0.5
}
#ENDIF // _OPCR3_

#IFDEF _DNWEN1_
DNWEN1_DNWCellIn = INSIDE CELL DNWELLi CellsForRRuleRecommended  
DNWEN1_DNWCellOut = NOT INSIDE CELL DNWELLi ExclCellsForRRuleRecommended 
DNWEN1_DNWCell = DNWEN1_DNWCellIn AND DNWEN1_DNWCellOut
DNWEN1_DNWMarker = DNWELLi AND RRuleRecommended
DNWEN1_DNW = (( DNWEN1_DNWCell OR DNWEN1_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

RR:RE:DNWEN1 { @ Enclosure by NW >= 1.5um 
    ENC DNWEN1_DNW NWEL < 1.5 ABUT < 90 SINGULAR REGION
    DNWEN1_DNW OUTSIDE EDGE NWEL	
}
#ENDIF // _DNWEN1_

#IFDEF _ODW1_
ODW1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODW1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODW1_ODCell = ODW1_ODCellIn AND ODW1_ODCellOut
ODW1_ODMarker = ODi AND RRuleRecommended
ODW1_OD = (( ODW1_ODCell OR ODW1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

ODW1_POCellIn = INSIDE CELL POLYGi CellsForRRuleRecommended  
ODW1_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleRecommended 
ODW1_POCell = ODW1_POCellIn AND ODW1_POCellOut
ODW1_POMarker = POLYGi AND RRuleRecommended
ODW1_PO = (( ODW1_POCell OR ODW1_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:RE:ODW1 = ( ODW1_PO INSIDE EDGE ODW1_OD ) NOT INSIDE EDGE OD2
RR:RE:ODW1 { @ Recommended Width of Active >= 0.30 um
    LENGTH RR:RE:ODW1 < 0.30
}
#ENDIF // _ODW1_

#IFDEF _ODS1_
ODS1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS1_ODCell = ODS1_ODCellIn AND ODS1_ODCellOut
ODS1_ODMarker = ODi AND RRuleRecommended
ODS1_OD = (( ODS1_ODCell OR ODS1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:RE:ODS1 { @ OD space 0.26 um
    EXT ODS1_OD < 0.26 ABUT < 90 SINGULAR REGION 
}
#ENDIF // _ODS1_

#IFDEF _ODS7_
ODS7_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS7_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS7_ODCell = ODS7_ODCellIn AND ODS7_ODCellOut
ODS7_ODMarker = ODi AND RRuleRecommended
ODS7_OD = (( ODS7_ODCell OR ODS7_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

ODS7Area = AREA ( ODi NOT INTERACT SEALRING ) > BIG_AREA
RR:RE:ODS7 { @ OD space 0.35um [OD area > ^BIG_AREA]
    (EXT ODS7Area ODi < 0.35 SPACE ABUT < 90 SINGULAR REGION) INTERACT ODS7_OD

}
#ENDIF // _ODS7_

#IFDEF _POS1_
POS1_POCellIn = INSIDE CELL POLYGi CellsForRRuleRecommended  
POS1_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleRecommended 
POS1_POCell = POS1_POCellIn AND POS1_POCellOut
POS1_POMarker = POLYGi AND RRuleRecommended
POS1_PO = (( POS1_POCell OR POS1_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

POS1Err = EXT [POS1_PO] < 0.23 ABUT < 90 
POS1ErrLong = POS1Err NOT TOUCH EDGE GATE
RR:RE:POS1 { @ PO space 0.23um
    EXT POS1ErrLong < 0.23 ABUT < 90 REGION 
}
#ENDIF // _POS1_

#IFDEF _POS5_
POS5_POCellIn = INSIDE CELL POLYGi CellsForRRuleRecommended  
POS5_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleRecommended 
POS5_POCell = POS5_POCellIn AND POS5_POCellOut
POS5_POMarker = POLYGi AND RRuleRecommended
POS5_PO = (( POS5_POCell OR POS5_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

POS5Area = AREA ( POLYGi NOT INTERACT SEALRING ) > BIG_AREA
RR:RE:POS5 { @ PO space 0.35um [PO area > ^BIG_AREA]
    (EXT POS5Area POLYGi < 0.35 SPACE ABUT < 90 SINGULAR REGION) INTERACT POS5_PO
}
#ENDIF // _POS5_

RPOBig = (SIZE RPO BY ( 10 / 2 - 0.001 ) UNDEROVER) AND RPO
#IFDEF _RPOEX1_
RPOEX1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
RPOEX1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
RPOEX1_ODCell = RPOEX1_ODCellIn AND RPOEX1_ODCellOut
RPOEX1_ODMarker = ODi AND RRuleRecommended
RPOEX1_OD = (( RPOEX1_ODCell OR RPOEX1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RPOEX1 = RPOEX1_OD INSIDE EDGE RPOBig
RR:RE:RPOEX1 { @ RPO over OD >= 0.3um
    ENC RPOEX1_OD RPOBig < 0.3 ABUT < 90 REGION 
}
#ENDIF // _RPOEX1_

#IFDEF _RPOEX3_
RPOEX3_POCellIn = INSIDE CELL POLYGi CellsForRRuleRecommended  
RPOEX3_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleRecommended 
RPOEX3_POCell = RPOEX3_POCellIn AND RPOEX3_POCellOut
RPOEX3_POMarker = POLYGi AND RRuleRecommended
RPOEX3_PO = (( RPOEX3_POCell OR RPOEX3_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RPOEX3 = RPOEX3_PO INSIDE EDGE RPOBig
RR:RE:RPOEX3 { @ RPO over PO >= 0.3um
    ENC RPOEX3_PO RPOBig < 0.3 ABUT < 90 REGION 
}
#ENDIF // _RPOEX3_


#IFDEF _VARS2_
VARS2_VARCellIn = INSIDE CELL VARDMY CellsForRRuleRecommended  
VARS2_VARCellOut = NOT INSIDE CELL VARDMY ExclCellsForRRuleRecommended 
VARS2_VARCell = VARS2_VARCellIn AND VARS2_VARCellOut
VARS2_VARMarker = VARDMY AND RRuleRecommended
VARS2_VAR = (VARS2_VARCell OR VARS2_VARMarker) NOT Block

VARS2_GATE = GATE AND VARS2_VAR
VARS2_CO = COOD AND VARS2_VAR
VARS2_ERR1 = EXT VARS2_CO VARS2_GATE < 0.13 ABUT < 90 REGION
VARS2_GATE_EDGE = POLYGi COIN INSIDE EDGE VARS2_GATE
VARS2_GATE_EXP = EXPAND EDGE VARS2_GATE_EDGE OUTSIDE BY 0.13
VARS2_ERR2 = VARS2_GATE_EXP NOT INTERACT VARS2_CO
RR:RE:VARS2 { @ VAR CO w/i OD space to gate == 0.13um
    VARS2_GATE INTERACT ( VARS2_ERR1 OR VARS2_ERR2 )
}
#ENDIF // _VARS2_   

#IFDEF _VARA1_
VARA1_VARCellIn = INSIDE CELL VARDMY CellsForRRuleRecommended  
VARA1_VARCellOut = NOT INSIDE CELL VARDMY ExclCellsForRRuleRecommended 
VARA1_VARCell = VARA1_VARCellIn AND VARA1_VARCellOut
VARA1_VARMarker = VARDMY AND RRuleRecommended
VARA1_VAR = (VARA1_VARCell OR VARA1_VARMarker) NOT Block

VARA1_GATE = GATE AND VARA1_VAR
RR:RE:VARA1 { @ VAR gate area >= 0.15um2
    AREA VARA1_GATE < 0.15
}
#ENDIF // _VARA1_

#IFDEF _COS3_
  #IFDEF 2.5V
COS3_COCellIn = INSIDE CELL CONTi CellsForRRuleRecommended  
COS3_COCellOut = NOT INSIDE CELL CONTi ExclCellsForRRuleRecommended 
COS3_COCell = COS3_COCellIn AND COS3_COCellOut
COS3_COMarker = CONTi AND RRuleRecommended
COS3_CO = (( COS3_COCell OR COS3_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

COS3_COOD = COS3_CO AND OD
RR:RE:COS3 { @ CO space to 2.5V GATE 0.13um
    EXT COS3_COOD HV_GATE < 0.13 ABUT < 90 SINGULAR REGION
}
  #ENDIF
#ENDIF // _COS3_

#IFDEF _COEN1_
COEN1_COCellIn = INSIDE CELL CONTi CellsForRRuleRecommended  
COEN1_COCellOut = NOT INSIDE CELL CONTi ExclCellsForRRuleRecommended 
COEN1_COCell = COEN1_COCellIn AND COEN1_COCellOut
COEN1_COMarker = CONTi AND RRuleRecommended
COEN1_CO = (( COEN1_COCell OR COEN1_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:RE:COEN1 { @ Enclosure by Active >= 0.13
  ENC COEN1_CO DACT < 0.12 ABUT < 90 SINGULAR REGION
}
#ENDIF // _COEN1_

#IFDEF _COEN2_
COEN2_COCellIn = INSIDE CELL CONTi CellsForRRuleRecommended  
COEN2_COCellOut = NOT INSIDE CELL CONTi ExclCellsForRRuleRecommended 
COEN2_COCell = COEN2_COCellIn AND COEN2_COCellOut
COEN2_COMarker = CONTi AND RRuleRecommended
COEN2_CO = (( COEN2_COCell OR COEN2_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:RE:COEN2 { @ Enclosure by PO [at least two opposite sides] >= 0.12 
  X = RECTANGLE ENCLOSURE COEN2_CO POLY ABUT < 90 SINGULAR GOOD CO_EN_2 0.12 OPPOSITE CO_EN_2 0.12 OPPOSITE
  Y = ENC [X] POLY < 0.12 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF // _COEN2_

#IFDEF _M1S5_
M1S5_M1CellIn = INSIDE CELL METAL1i CellsForRRuleRecommended  
M1S5_M1CellOut = NOT INSIDE CELL METAL1i ExclCellsForRRuleRecommended 
M1S5_M1Cell = M1S5_M1CellIn AND M1S5_M1CellOut
M1S5_M1Marker = METAL1i AND RRuleRecommended
M1S5_M1 = (M1S5_M1Cell OR M1S5_M1Marker) NOT Block

M1S5_DM1CellIn = INSIDE CELL DUM1 CellsForRRuleRecommended  
M1S5_DM1CellOut = NOT INSIDE CELL DUM1 ExclCellsForRRuleRecommended 
M1S5_DM1Cell = M1S5_DM1CellIn AND M1S5_DM1CellOut
M1S5_DM1Marker = DUM1 AND RRuleRecommended
M1S5_DM1 = (M1S5_DM1Cell OR M1S5_DM1Marker) NOT Block

M1S5_M1x = M1S5_M1 OR M1S5_DM1
M1S5_NOT_M1x = CHIP NOT M1x
M1S5_BIGAREA = AREA M1S5_NOT_M1x > BIG_AREA
M1S5_ERROR = (EXT M1S5_BIGAREA M1S5_NOT_M1x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M1S5_M1x 

RR:RE:M1S5 { @ Space between two non-M1 regions 0.35 [ one area > ^BIG_AREA ]
    COPY M1S5_ERROR
}
#ENDIF // _M1S5_

#IFDEF _M1EN21_
M1EN21_COCellIn = INSIDE CELL CONTi CellsForRRuleRecommended  
M1EN21_COCellOut = NOT INSIDE CELL CONTi ExclCellsForRRuleRecommended 
M1EN21_COCell = M1EN21_COCellIn AND M1EN21_COCellOut
M1EN21_COMarker = CONTi AND RRuleRecommended
M1EN21_CO = (( M1EN21_COCell OR M1EN21_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:RE:M1EN21 { @ Enclosure of CO at least two opposite sides 0.08
  A = RECTANGLE ENCLOSURE M1EN21_CO M1 ABUT > 0 < 90 GOOD 0 0.08 OPPOSITE 0 0.08 OPPOSITE
  X = ENC [A] M1 < 0.08 ABUT < 90 OPPOSITE
  Y = A TOUCH EDGE X
  INT [Y] < CO_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narr
}
#ENDIF  // _M1EN21_

#IFDEF _M1EN22_
M1EN22_COCellIn = INSIDE CELL CONTi CellsForRRuleRecommended  
M1EN22_COCellOut = NOT INSIDE CELL CONTi ExclCellsForRRuleRecommended 
M1EN22_COCell = M1EN22_COCellIn AND M1EN22_COCellOut
M1EN22_COMarker = CONTi AND RRuleRecommended
M1EN22_CO = (( M1EN22_COCell OR M1EN22_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block

M1EN22_M1_BIG = SIZE M1 BY 0.6 / 2 UNDEROVER
M1EN22_M1_BIG_CO = M1EN22_CO NOT OUTSIDE M1EN22_M1_BIG
RR:RE:M1EN22 { @ Recommended M1 [ width > 0.6um ] enclosure CO >= 0.08 um
    ENC M1EN22_M1_BIG_CO M1 < 0.08 ABUT < 90 REGION
}
#ENDIF // _M1EN22_




#IFDEF _VIA1EN1_VIA1EN2_
VIA1EN1_VIA1EN2_VIA1CellIn = INSIDE CELL VIA12i CellsForRRuleRecommended  
VIA1EN1_VIA1EN2_VIA1CellOut = NOT INSIDE CELL VIA12i ExclCellsForRRuleRecommended 
VIA1EN1_VIA1EN2_VIA1Cell = VIA1EN1_VIA1EN2_VIA1CellIn AND VIA1EN1_VIA1EN2_VIA1CellOut
VIA1EN1_VIA1EN2_VIA1Marker = VIA12i AND RRuleRecommended
VIA1EN1_VIA1EN2_VIA1 = (( VIA1EN1_VIA1EN2_VIA1Cell OR VIA1EN1_VIA1EN2_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:RE:VIA1EN1_VIA1EN2 { @ Recommended enclosure of VIA1 at least two opposite sides >= 0.08 um or enclosure of VIA1 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA1EN1_VIA1EN2_VIA1 M1 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M1 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF





#IFDEF _VIA2EN1_VIA2EN2_
VIA2EN1_VIA2EN2_VIA2CellIn = INSIDE CELL VIA23i CellsForRRuleRecommended  
VIA2EN1_VIA2EN2_VIA2CellOut = NOT INSIDE CELL VIA23i ExclCellsForRRuleRecommended 
VIA2EN1_VIA2EN2_VIA2Cell = VIA2EN1_VIA2EN2_VIA2CellIn AND VIA2EN1_VIA2EN2_VIA2CellOut
VIA2EN1_VIA2EN2_VIA2Marker = VIA23i AND RRuleRecommended
VIA2EN1_VIA2EN2_VIA2 = (VIA2EN1_VIA2EN2_VIA2Cell OR VIA2EN1_VIA2EN2_VIA2Marker) NOT Block

RR:RE:VIA2EN1_VIA2EN2 { @ Recommended enclosure of VIA2 at least two opposite sides >= 0.08 um or enclosure of VIA2 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA2EN1_VIA2EN2_VIA2 M2 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M2 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF





#IFDEF _VIA3EN1_VIA3EN2_
VIA3EN1_VIA3EN2_VIA3CellIn = INSIDE CELL VIA34i CellsForRRuleRecommended  
VIA3EN1_VIA3EN2_VIA3CellOut = NOT INSIDE CELL VIA34i ExclCellsForRRuleRecommended 
VIA3EN1_VIA3EN2_VIA3Cell = VIA3EN1_VIA3EN2_VIA3CellIn AND VIA3EN1_VIA3EN2_VIA3CellOut
VIA3EN1_VIA3EN2_VIA3Marker = VIA34i AND RRuleRecommended
VIA3EN1_VIA3EN2_VIA3 = (VIA3EN1_VIA3EN2_VIA3Cell OR VIA3EN1_VIA3EN2_VIA3Marker) NOT Block

RR:RE:VIA3EN1_VIA3EN2 { @ Recommended enclosure of VIA3 at least two opposite sides >= 0.08 um or enclosure of VIA3 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA3EN1_VIA3EN2_VIA3 M3 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M3 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF





#IFDEF _VIA4EN1_VIA4EN2_
VIA4EN1_VIA4EN2_VIA4CellIn = INSIDE CELL VIA45i CellsForRRuleRecommended  
VIA4EN1_VIA4EN2_VIA4CellOut = NOT INSIDE CELL VIA45i ExclCellsForRRuleRecommended 
VIA4EN1_VIA4EN2_VIA4Cell = VIA4EN1_VIA4EN2_VIA4CellIn AND VIA4EN1_VIA4EN2_VIA4CellOut
VIA4EN1_VIA4EN2_VIA4Marker = VIA45i AND RRuleRecommended
VIA4EN1_VIA4EN2_VIA4 = (VIA4EN1_VIA4EN2_VIA4Cell OR VIA4EN1_VIA4EN2_VIA4Marker) NOT Block

RR:RE:VIA4EN1_VIA4EN2 { @ Recommended enclosure of VIA4 at least two opposite sides >= 0.08 um or enclosure of VIA4 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA4EN1_VIA4EN2_VIA4 M4 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M4 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF



#IFNDEF THICK_TOP3_METAL


#IFDEF _VIA5EN1_VIA5EN2_
VIA5EN1_VIA5EN2_VIA5CellIn = INSIDE CELL VIA56i CellsForRRuleRecommended  
VIA5EN1_VIA5EN2_VIA5CellOut = NOT INSIDE CELL VIA56i ExclCellsForRRuleRecommended 
VIA5EN1_VIA5EN2_VIA5Cell = VIA5EN1_VIA5EN2_VIA5CellIn AND VIA5EN1_VIA5EN2_VIA5CellOut
VIA5EN1_VIA5EN2_VIA5Marker = VIA56i AND RRuleRecommended
VIA5EN1_VIA5EN2_VIA5 = (VIA5EN1_VIA5EN2_VIA5Cell OR VIA5EN1_VIA5EN2_VIA5Marker) NOT Block

RR:RE:VIA5EN1_VIA5EN2 { @ Recommended enclosure of VIA5 at least two opposite sides >= 0.08 um or enclosure of VIA5 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA5EN1_VIA5EN2_VIA5 M5 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M5 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF

#ENDIF // THICK_TOP3_METAL


#IFNDEF THICK_TOP2_METAL
#IFNDEF THICK_TOP3_METAL


#IFDEF _VIA6EN1_VIA6EN2_
VIA6EN1_VIA6EN2_VIA6CellIn = INSIDE CELL VIA67i CellsForRRuleRecommended  
VIA6EN1_VIA6EN2_VIA6CellOut = NOT INSIDE CELL VIA67i ExclCellsForRRuleRecommended 
VIA6EN1_VIA6EN2_VIA6Cell = VIA6EN1_VIA6EN2_VIA6CellIn AND VIA6EN1_VIA6EN2_VIA6CellOut
VIA6EN1_VIA6EN2_VIA6Marker = VIA67i AND RRuleRecommended
VIA6EN1_VIA6EN2_VIA6 = (VIA6EN1_VIA6EN2_VIA6Cell OR VIA6EN1_VIA6EN2_VIA6Marker) NOT Block

RR:RE:VIA6EN1_VIA6EN2 { @ Recommended enclosure of VIA6 at least two opposite sides >= 0.08 um or enclosure of VIA6 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA6EN1_VIA6EN2_VIA6 M6 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M6 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF

#ENDIF // THICK_TOP2_METAL
#ENDIF // THICK_TOP3_METAL


#IFNDEF THICK_TOP2_METAL
#IFNDEF THICK_TOP3_METAL

#IFDEF _VIA7EN2_
VIA7EN2_VIA7CellIn = INSIDE CELL VIA78i CellsForRRuleRecommended  
VIA7EN2_VIA7CellOut = NOT INSIDE CELL VIA78i ExclCellsForRRuleRecommended 
VIA7EN2_VIA7Cell = VIA7EN2_VIA7CellIn AND VIA7EN2_VIA7CellOut
VIA7EN2_VIA7Marker = VIA78i AND RRuleRecommended
VIA7EN2_VIA7 = (VIA7EN2_VIA7Cell OR VIA7EN2_VIA7Marker) NOT Block

RR:RE:VIA7EN2 { @ Recommended VIA7 enclosure by M7 [at least two opposite sides] >= 0.08 um
  X = RECTANGLE ENCLOSURE VIA7EN2_VIA7 M7 ABUT > 0 < 90 GOOD VIA7_EN_1 0.08 OPPOSITE VIA7_EN_1 0.08 OPPOSITE
  Y = ENC [X] M7 < 0.08 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA7_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides

}
#ENDIF  // _VIA7EN2_

#ENDIF // THICK_TOP2_METAL
#ENDIF // THICK_TOP3_METAL

#IFDEF _M2W3_
M2W3_M2CellIn = INSIDE CELL METAL2i CellsForRRuleRecommended  
M2W3_M2CellOut = NOT INSIDE CELL METAL2i ExclCellsForRRuleRecommended 
M2W3_M2Cell = M2W3_M2CellIn AND M2W3_M2CellOut
M2W3_M2Marker = METAL2i AND RRuleRecommended
M2W3_M2 = (M2W3_M2Cell OR M2W3_M2Marker) NOT Block

RR:AR:M2W3 = M1 OR DUM1
M2W3_EXT = CHIP NOT ( SIZE RR:AR:M2W3 BY (5/2-0.001) OVERUNDER )
M2W3_BIG = SIZE( SIZE M2W3_EXT BY (5/2-0.001) UNDEROVER ) BY 1.0
M2W3_CHECK = M2W3_M2 INSIDE EDGE M2W3_BIG
RR:RE:M2W3 { @ Recommended M2 width on (M1 OR DM1 with space>= 5x5 sizing 1) >= 0.22
    INT M2W3_CHECK < 0.22 ABUT < 90 REGION 
}
#ENDIF // _M2W3_


#IFDEF _M3W3_
M3W3_M3CellIn = INSIDE CELL METAL3i CellsForRRuleRecommended  
M3W3_M3CellOut = NOT INSIDE CELL METAL3i ExclCellsForRRuleRecommended 
M3W3_M3Cell = M3W3_M3CellIn AND M3W3_M3CellOut
M3W3_M3Marker = METAL3i AND RRuleRecommended
M3W3_M3 = (M3W3_M3Cell OR M3W3_M3Marker) NOT Block

RR:AR:M3W3 = M2 OR DUM2
M3W3_EXT = CHIP NOT ( SIZE RR:AR:M3W3 BY (5/2-0.001) OVERUNDER )
M3W3_BIG = SIZE( SIZE M3W3_EXT BY (5/2-0.001) UNDEROVER ) BY 1.0
M3W3_CHECK = M3W3_M3 INSIDE EDGE M3W3_BIG
RR:RE:M3W3 { @ Recommended M3 width on (M2 OR DM2 with space>= 5x5 sizing 1) >= 0.22
    INT M3W3_CHECK < 0.22 ABUT < 90 REGION 
}
#ENDIF // _M3W3_


#IFDEF _M4W3_
M4W3_M4CellIn = INSIDE CELL METAL4i CellsForRRuleRecommended  
M4W3_M4CellOut = NOT INSIDE CELL METAL4i ExclCellsForRRuleRecommended 
M4W3_M4Cell = M4W3_M4CellIn AND M4W3_M4CellOut
M4W3_M4Marker = METAL4i AND RRuleRecommended
M4W3_M4 = (M4W3_M4Cell OR M4W3_M4Marker) NOT Block

RR:AR:M4W3 = M3 OR DUM3
M4W3_EXT = CHIP NOT ( SIZE RR:AR:M4W3 BY (5/2-0.001) OVERUNDER )
M4W3_BIG = SIZE( SIZE M4W3_EXT BY (5/2-0.001) UNDEROVER ) BY 1.0
M4W3_CHECK = M4W3_M4 INSIDE EDGE M4W3_BIG
RR:RE:M4W3 { @ Recommended M4 width on (M3 OR DM3 with space>= 5x5 sizing 1) >= 0.22
    INT M4W3_CHECK < 0.22 ABUT < 90 REGION 
}
#ENDIF // _M4W3_


#IFDEF _M5W3_
M5W3_M5CellIn = INSIDE CELL METAL5i CellsForRRuleRecommended  
M5W3_M5CellOut = NOT INSIDE CELL METAL5i ExclCellsForRRuleRecommended 
M5W3_M5Cell = M5W3_M5CellIn AND M5W3_M5CellOut
M5W3_M5Marker = METAL5i AND RRuleRecommended
M5W3_M5 = (M5W3_M5Cell OR M5W3_M5Marker) NOT Block

RR:AR:M5W3 = M4 OR DUM4
M5W3_EXT = CHIP NOT ( SIZE RR:AR:M5W3 BY (5/2-0.001) OVERUNDER )
M5W3_BIG = SIZE( SIZE M5W3_EXT BY (5/2-0.001) UNDEROVER ) BY 1.0
M5W3_CHECK = M5W3_M5 INSIDE EDGE M5W3_BIG
RR:RE:M5W3 { @ Recommended M5 width on (M4 OR DM4 with space>= 5x5 sizing 1) >= 0.22
    INT M5W3_CHECK < 0.22 ABUT < 90 REGION 
}
#ENDIF // _M5W3_


#IFNDEF THICK_TOP3_METAL
#IFDEF _M6W3_
M6W3_M6CellIn = INSIDE CELL METAL6i CellsForRRuleRecommended  
M6W3_M6CellOut = NOT INSIDE CELL METAL6i ExclCellsForRRuleRecommended 
M6W3_M6Cell = M6W3_M6CellIn AND M6W3_M6CellOut
M6W3_M6Marker = METAL6i AND RRuleRecommended
M6W3_M6 = (M6W3_M6Cell OR M6W3_M6Marker) NOT Block

RR:AR:M6W3 = M5 OR DUM5
M6W3_EXT = CHIP NOT ( SIZE RR:AR:M6W3 BY (5/2-0.001) OVERUNDER )
M6W3_BIG = SIZE( SIZE M6W3_EXT BY (5/2-0.001) UNDEROVER ) BY 1.0
M6W3_CHECK = M6W3_M6 INSIDE EDGE M6W3_BIG
RR:RE:M6W3 { @ Recommended M6 width on (M5 OR DM5 with space>= 5x5 sizing 1) >= 0.22
    INT M6W3_CHECK < 0.22 ABUT < 90 REGION 
}
#ENDIF // _M6W3_

#ENDIF // THICK_TOP3_METAL

#IFNDEF THICK_TOP2_METAL
#IFNDEF THICK_TOP3_METAL
#IFDEF _M7W3_
M7W3_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
M7W3_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
M7W3_M7Cell = M7W3_M7CellIn AND M7W3_M7CellOut
M7W3_M7Marker = METAL7i AND RRuleRecommended
M7W3_M7 = (M7W3_M7Cell OR M7W3_M7Marker) NOT Block

RR:AR:M7W3 = M6 OR DUM6
M7W3_EXT = CHIP NOT ( SIZE RR:AR:M7W3 BY (5/2-0.001) OVERUNDER )
M7W3_BIG = SIZE( SIZE M7W3_EXT BY (5/2-0.001) UNDEROVER ) BY 1.0
M7W3_CHECK = M7W3_M7 INSIDE EDGE M7W3_BIG
RR:RE:M7W3 { @ Recommended M7 width on (M6 OR DM6 with space>= 5x5 sizing 1) >= 0.22
    INT M7W3_CHECK < 0.22 ABUT < 90 REGION 
}
#ENDIF // _M7W3_

#ENDIF // THICK_TOP2_METAL
#ENDIF // THICK_TOP3_METAL


M1S5W_M1CellIn = INSIDE CELL METAL1i CellsForRRuleRecommended  
M1S5W_M1CellOut = NOT INSIDE CELL METAL1i ExclCellsForRRuleRecommended 
M1S5W_M1Cell = M1S5W_M1CellIn AND M1S5W_M1CellOut
M1S5W_M1Marker = METAL1i AND RRuleRecommended
M1S5W_M1 = (( M1S5W_M1Cell OR M1S5W_M1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

M1Wide5 = ( SIZE ( SIZE M1S5W_M1 BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND M1S5W_M1
M1Wide5Ext = ( SIZE M1Wide5 BY 1 + 0.1 ) AND M1 // 0.1um is an arbitrary small number
M2S5W_M2CellIn = INSIDE CELL METAL2i CellsForRRuleRecommended  
M2S5W_M2CellOut = NOT INSIDE CELL METAL2i ExclCellsForRRuleRecommended 
M2S5W_M2Cell = M2S5W_M2CellIn AND M2S5W_M2CellOut
M2S5W_M2Marker = METAL2i AND RRuleRecommended
M2S5W_M2 = (M2S5W_M2Cell OR M2S5W_M2Marker) NOT Block

M2Wide5 = ( SIZE ( SIZE M2S5W_M2 BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND M2S5W_M2
M2Wide5Ext = ( SIZE M2Wide5 BY 1 + 0.1 ) AND M2 // 0.1um is an arbitrary small number
M3S5W_M3CellIn = INSIDE CELL METAL3i CellsForRRuleRecommended  
M3S5W_M3CellOut = NOT INSIDE CELL METAL3i ExclCellsForRRuleRecommended 
M3S5W_M3Cell = M3S5W_M3CellIn AND M3S5W_M3CellOut
M3S5W_M3Marker = METAL3i AND RRuleRecommended
M3S5W_M3 = (M3S5W_M3Cell OR M3S5W_M3Marker) NOT Block

M3Wide5 = ( SIZE ( SIZE M3S5W_M3 BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND M3S5W_M3
M3Wide5Ext = ( SIZE M3Wide5 BY 1 + 0.1 ) AND M3 // 0.1um is an arbitrary small number
M4S5W_M4CellIn = INSIDE CELL METAL4i CellsForRRuleRecommended  
M4S5W_M4CellOut = NOT INSIDE CELL METAL4i ExclCellsForRRuleRecommended 
M4S5W_M4Cell = M4S5W_M4CellIn AND M4S5W_M4CellOut
M4S5W_M4Marker = METAL4i AND RRuleRecommended
M4S5W_M4 = (M4S5W_M4Cell OR M4S5W_M4Marker) NOT Block

M4Wide5 = ( SIZE ( SIZE M4S5W_M4 BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND M4S5W_M4
M4Wide5Ext = ( SIZE M4Wide5 BY 1 + 0.1 ) AND M4 // 0.1um is an arbitrary small number
M5S5W_M5CellIn = INSIDE CELL METAL5i CellsForRRuleRecommended  
M5S5W_M5CellOut = NOT INSIDE CELL METAL5i ExclCellsForRRuleRecommended 
M5S5W_M5Cell = M5S5W_M5CellIn AND M5S5W_M5CellOut
M5S5W_M5Marker = METAL5i AND RRuleRecommended
M5S5W_M5 = (M5S5W_M5Cell OR M5S5W_M5Marker) NOT Block

M5Wide5 = ( SIZE ( SIZE M5S5W_M5 BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND M5S5W_M5
M5Wide5Ext = ( SIZE M5Wide5 BY 1 + 0.1 ) AND M5 // 0.1um is an arbitrary small number
M6S5W_M6CellIn = INSIDE CELL METAL6i CellsForRRuleRecommended  
M6S5W_M6CellOut = NOT INSIDE CELL METAL6i ExclCellsForRRuleRecommended 
M6S5W_M6Cell = M6S5W_M6CellIn AND M6S5W_M6CellOut
M6S5W_M6Marker = METAL6i AND RRuleRecommended
M6S5W_M6 = (M6S5W_M6Cell OR M6S5W_M6Marker) NOT Block

M6Wide5 = ( SIZE ( SIZE M6S5W_M6 BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND M6S5W_M6
M6Wide5Ext = ( SIZE M6Wide5 BY 1 + 0.1 ) AND M6 // 0.1um is an arbitrary small number
M7S5W_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
M7S5W_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
M7S5W_M7Cell = M7S5W_M7CellIn AND M7S5W_M7CellOut
M7S5W_M7Marker = METAL7i AND RRuleRecommended
M7S5W_M7 = (M7S5W_M7Cell OR M7S5W_M7Marker) NOT Block

M7Wide5 = ( SIZE ( SIZE M7S5W_M7 BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND M7S5W_M7
M7Wide5Ext = ( SIZE M7Wide5 BY 1 + 0.1 ) AND M7 // 0.1um is an arbitrary small number
M8S5W_M8CellIn = INSIDE CELL METAL8i CellsForRRuleRecommended  
M8S5W_M8CellOut = NOT INSIDE CELL METAL8i ExclCellsForRRuleRecommended 
M8S5W_M8Cell = M8S5W_M8CellIn AND M8S5W_M8CellOut
M8S5W_M8Marker = METAL8i AND RRuleRecommended
M8S5W_M8 = (M8S5W_M8Cell OR M8S5W_M8Marker) NOT Block

M8Wide5 = ( SIZE ( SIZE M8S5W_M8 BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND M8S5W_M8
M8Wide5Ext = ( SIZE M8Wide5 BY 1 + 0.1 ) AND M8 // 0.1um is an arbitrary small number

M2WideStack = M1Wide5Ext AND ( M2Wide5Ext AND M3Wide5Ext )

M3WideStack = ( M2Wide5Ext AND  M3Wide5Ext ) AND M4Wide5Ext

M4WideStack = M3Wide5Ext AND ( M4Wide5Ext AND M5Wide5Ext )

M5WideStack = ( M4Wide5Ext AND  M5Wide5Ext ) AND M6Wide5Ext

M6WideStack = M5Wide5Ext AND ( M6Wide5Ext AND M7Wide5Ext )

M7WideStack = ( M6Wide5Ext AND  M7Wide5Ext ) AND M8Wide5Ext



#IFDEF _M2S5_ 
M2BigStack = ( SIZE M2WideStack BY 5 / 2 UNDEROVER TRUNCATE 5 /2 ) AND M2WideStack
M2StackSpace = EXT M2BigStack M2WideStack < 0.6 OPPOSITE MEASURE ALL REGION
M2StackViol = ( ( M2StackSpace NOT INSIDE M1 ) NOT INSIDE M2 ) NOT INSIDE M3
RR:RE:M2S5 { @ Recommended space of 2 adjacent stacked metals( metal layers >= 3 ) width > 5um and
             @ run length > 5um >= 0.6um
    ENCLOSE RECTANGLE M2StackViol 0.005 5+0.005 
}
#ENDIF // _M2S5_

#IFDEF _M2S6_
M2S6_M2CellIn = INSIDE CELL METAL2i CellsForRRuleRecommended  
M2S6_M2CellOut = NOT INSIDE CELL METAL2i ExclCellsForRRuleRecommended 
M2S6_M2Cell = M2S6_M2CellIn AND M2S6_M2CellOut
M2S6_M2Marker = METAL2i AND RRuleRecommended
M2S6_M2 = (M2S6_M2Cell OR M2S6_M2Marker) NOT Block

M1Wide5Exp5 = SIZE ( ( SIZE ( SIZE METAL1i BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND METAL1i ) BY 5
M2OnM1Wide5 = M2S6_M2 AND M1Wide5Exp5
M2S6ToCheck = M2S6_M2 INTERACT M2OnM1Wide5
M2S6Pre = EXT M2S6ToCheck < 0.3 ABUT < 90 REGION
RR:RE:M2S6 { @ Recommended space of [M2 AND (wide M1 sizing 5um)] >= 0.3um
    M2S6Pre AND M1Wide5Exp5
}
#ENDIF // _M2S6_

#IFDEF _M2S7_
M2S7_M2CellIn = INSIDE CELL METAL2i CellsForRRuleRecommended  
M2S7_M2CellOut = NOT INSIDE CELL METAL2i ExclCellsForRRuleRecommended 
M2S7_M2Cell = M2S7_M2CellIn AND M2S7_M2CellOut
M2S7_M2Marker = METAL2i AND RRuleRecommended
M2S7_M2 = (M2S7_M2Cell OR M2S7_M2Marker) NOT Block

M2S7_DM2CellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
M2S7_DM2CellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
M2S7_DM2Cell = M2S7_DM2CellIn AND M2S7_DM2CellOut
M2S7_DM2Marker = DUM2 AND RRuleRecommended
M2S7_DM2 = (M2S7_DM2Cell OR M2S7_DM2Marker) NOT Block

M2S7_M2x = M2S7_M2 OR M2S7_DM2
M2S7_NOT_M2x = CHIP NOT M2x
M2S7_BIGAREA = AREA M2S7_NOT_M2x > BIG_AREA
M2S7_ERROR = (EXT M2S7_BIGAREA M2S7_NOT_M2x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M2S7_M2x 

RR:RE:M2S7 { @ Space between two non-M2 regions 0.35 [ one area > ^BIG_AREA ]
    COPY M2S7_ERROR
}
#ENDIF // _M2S7_

#IFDEF _M2EN1_M2EN2_
M2EN1_M2EN2_VIA1CellIn = INSIDE CELL VIA12i CellsForRRuleRecommended  
M2EN1_M2EN2_VIA1CellOut = NOT INSIDE CELL VIA12i ExclCellsForRRuleRecommended 
M2EN1_M2EN2_VIA1Cell = M2EN1_M2EN2_VIA1CellIn AND M2EN1_M2EN2_VIA1CellOut
M2EN1_M2EN2_VIA1Marker = VIA12i AND RRuleRecommended
M2EN1_M2EN2_VIA1 = (M2EN1_M2EN2_VIA1Cell OR M2EN1_M2EN2_VIA1Marker) NOT Block

RR:RE:M2EN1_M2EN2 { @ Recommended enclosure of VIA1 at least two opposite sides >= 0.08 um or enclosure of VIA1 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M2EN1_M2EN2_VIA1 M2 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M2 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF



#IFDEF _M3S5_ 
M3BigStack = ( SIZE M3WideStack BY 5 / 2 UNDEROVER TRUNCATE 5 /2 ) AND M3WideStack
M3StackSpace = EXT M3BigStack M3WideStack < 0.6 OPPOSITE MEASURE ALL REGION
M3StackViol = ( ( M3StackSpace NOT INSIDE M2 ) NOT INSIDE M3 ) NOT INSIDE M4
RR:RE:M3S5 { @ Recommended space of 2 adjacent stacked metals( metal layers >= 3 ) width > 5um and
             @ run length > 5um >= 0.6um
    ENCLOSE RECTANGLE M3StackViol 0.005 5+0.005 
}
#ENDIF // _M3S5_

#IFDEF _M3S6_
M3S6_M3CellIn = INSIDE CELL METAL3i CellsForRRuleRecommended  
M3S6_M3CellOut = NOT INSIDE CELL METAL3i ExclCellsForRRuleRecommended 
M3S6_M3Cell = M3S6_M3CellIn AND M3S6_M3CellOut
M3S6_M3Marker = METAL3i AND RRuleRecommended
M3S6_M3 = (M3S6_M3Cell OR M3S6_M3Marker) NOT Block

M2Wide5Exp5 = SIZE ( ( SIZE ( SIZE METAL2i BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND METAL2i ) BY 5
M3OnM2Wide5 = M3S6_M3 AND M2Wide5Exp5
M3S6ToCheck = M3S6_M3 INTERACT M3OnM2Wide5
M3S6Pre = EXT M3S6ToCheck < 0.3 ABUT < 90 REGION
RR:RE:M3S6 { @ Recommended space of [M3 AND (wide M2 sizing 5um)] >= 0.3um
    M3S6Pre AND M2Wide5Exp5
}
#ENDIF // _M3S6_

#IFDEF _M3S7_
M3S7_M3CellIn = INSIDE CELL METAL3i CellsForRRuleRecommended  
M3S7_M3CellOut = NOT INSIDE CELL METAL3i ExclCellsForRRuleRecommended 
M3S7_M3Cell = M3S7_M3CellIn AND M3S7_M3CellOut
M3S7_M3Marker = METAL3i AND RRuleRecommended
M3S7_M3 = (M3S7_M3Cell OR M3S7_M3Marker) NOT Block

M3S7_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
M3S7_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
M3S7_DM3Cell = M3S7_DM3CellIn AND M3S7_DM3CellOut
M3S7_DM3Marker = DUM3 AND RRuleRecommended
M3S7_DM3 = (M3S7_DM3Cell OR M3S7_DM3Marker) NOT Block

M3S7_M3x = M3S7_M3 OR M3S7_DM3
M3S7_NOT_M3x = CHIP NOT M3x
M3S7_BIGAREA = AREA M3S7_NOT_M3x > BIG_AREA
M3S7_ERROR = (EXT M3S7_BIGAREA M3S7_NOT_M3x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M3S7_M3x 

RR:RE:M3S7 { @ Space between two non-M3 regions 0.35 [ one area > ^BIG_AREA ]
    COPY M3S7_ERROR
}
#ENDIF // _M3S7_

#IFDEF _M3EN1_M3EN2_
M3EN1_M3EN2_VIA2CellIn = INSIDE CELL VIA23i CellsForRRuleRecommended  
M3EN1_M3EN2_VIA2CellOut = NOT INSIDE CELL VIA23i ExclCellsForRRuleRecommended 
M3EN1_M3EN2_VIA2Cell = M3EN1_M3EN2_VIA2CellIn AND M3EN1_M3EN2_VIA2CellOut
M3EN1_M3EN2_VIA2Marker = VIA23i AND RRuleRecommended
M3EN1_M3EN2_VIA2 = (M3EN1_M3EN2_VIA2Cell OR M3EN1_M3EN2_VIA2Marker) NOT Block

RR:RE:M3EN1_M3EN2 { @ Recommended enclosure of VIA2 at least two opposite sides >= 0.08 um or enclosure of VIA2 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M3EN1_M3EN2_VIA2 M3 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M3 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF



#IFDEF _M4S5_ 
M4BigStack = ( SIZE M4WideStack BY 5 / 2 UNDEROVER TRUNCATE 5 /2 ) AND M4WideStack
M4StackSpace = EXT M4BigStack M4WideStack < 0.6 OPPOSITE MEASURE ALL REGION
M4StackViol = ( ( M4StackSpace NOT INSIDE M3 ) NOT INSIDE M4 ) NOT INSIDE M5
RR:RE:M4S5 { @ Recommended space of 2 adjacent stacked metals( metal layers >= 3 ) width > 5um and
             @ run length > 5um >= 0.6um
    ENCLOSE RECTANGLE M4StackViol 0.005 5+0.005 
}
#ENDIF // _M4S5_

#IFDEF _M4S6_
M4S6_M4CellIn = INSIDE CELL METAL4i CellsForRRuleRecommended  
M4S6_M4CellOut = NOT INSIDE CELL METAL4i ExclCellsForRRuleRecommended 
M4S6_M4Cell = M4S6_M4CellIn AND M4S6_M4CellOut
M4S6_M4Marker = METAL4i AND RRuleRecommended
M4S6_M4 = (M4S6_M4Cell OR M4S6_M4Marker) NOT Block

M3Wide5Exp5 = SIZE ( ( SIZE ( SIZE METAL3i BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND METAL3i ) BY 5
M4OnM3Wide5 = M4S6_M4 AND M3Wide5Exp5
M4S6ToCheck = M4S6_M4 INTERACT M4OnM3Wide5
M4S6Pre = EXT M4S6ToCheck < 0.3 ABUT < 90 REGION
RR:RE:M4S6 { @ Recommended space of [M4 AND (wide M3 sizing 5um)] >= 0.3um
    M4S6Pre AND M3Wide5Exp5
}
#ENDIF // _M4S6_

#IFDEF _M4S7_
M4S7_M4CellIn = INSIDE CELL METAL4i CellsForRRuleRecommended  
M4S7_M4CellOut = NOT INSIDE CELL METAL4i ExclCellsForRRuleRecommended 
M4S7_M4Cell = M4S7_M4CellIn AND M4S7_M4CellOut
M4S7_M4Marker = METAL4i AND RRuleRecommended
M4S7_M4 = (M4S7_M4Cell OR M4S7_M4Marker) NOT Block

M4S7_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
M4S7_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
M4S7_DM4Cell = M4S7_DM4CellIn AND M4S7_DM4CellOut
M4S7_DM4Marker = DUM4 AND RRuleRecommended
M4S7_DM4 = (M4S7_DM4Cell OR M4S7_DM4Marker) NOT Block

M4S7_M4x = M4S7_M4 OR M4S7_DM4
M4S7_NOT_M4x = CHIP NOT M4x
M4S7_BIGAREA = AREA M4S7_NOT_M4x > BIG_AREA
M4S7_ERROR = (EXT M4S7_BIGAREA M4S7_NOT_M4x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M4S7_M4x 

RR:RE:M4S7 { @ Space between two non-M4 regions 0.35 [ one area > ^BIG_AREA ]
    COPY M4S7_ERROR
}
#ENDIF // _M4S7_

#IFDEF _M4EN1_M4EN2_
M4EN1_M4EN2_VIA3CellIn = INSIDE CELL VIA34i CellsForRRuleRecommended  
M4EN1_M4EN2_VIA3CellOut = NOT INSIDE CELL VIA34i ExclCellsForRRuleRecommended 
M4EN1_M4EN2_VIA3Cell = M4EN1_M4EN2_VIA3CellIn AND M4EN1_M4EN2_VIA3CellOut
M4EN1_M4EN2_VIA3Marker = VIA34i AND RRuleRecommended
M4EN1_M4EN2_VIA3 = (M4EN1_M4EN2_VIA3Cell OR M4EN1_M4EN2_VIA3Marker) NOT Block

RR:RE:M4EN1_M4EN2 { @ Recommended enclosure of VIA3 at least two opposite sides >= 0.08 um or enclosure of VIA3 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M4EN1_M4EN2_VIA3 M4 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M4 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF



#IFDEF _M5S5_ 
M5BigStack = ( SIZE M5WideStack BY 5 / 2 UNDEROVER TRUNCATE 5 /2 ) AND M5WideStack
M5StackSpace = EXT M5BigStack M5WideStack < 0.6 OPPOSITE MEASURE ALL REGION
M5StackViol = ( ( M5StackSpace NOT INSIDE M4 ) NOT INSIDE M5 ) NOT INSIDE M6
RR:RE:M5S5 { @ Recommended space of 2 adjacent stacked metals( metal layers >= 3 ) width > 5um and
             @ run length > 5um >= 0.6um
    ENCLOSE RECTANGLE M5StackViol 0.005 5+0.005 
}
#ENDIF // _M5S5_

#IFDEF _M5S6_
M5S6_M5CellIn = INSIDE CELL METAL5i CellsForRRuleRecommended  
M5S6_M5CellOut = NOT INSIDE CELL METAL5i ExclCellsForRRuleRecommended 
M5S6_M5Cell = M5S6_M5CellIn AND M5S6_M5CellOut
M5S6_M5Marker = METAL5i AND RRuleRecommended
M5S6_M5 = (M5S6_M5Cell OR M5S6_M5Marker) NOT Block

M4Wide5Exp5 = SIZE ( ( SIZE ( SIZE METAL4i BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND METAL4i ) BY 5
M5OnM4Wide5 = M5S6_M5 AND M4Wide5Exp5
M5S6ToCheck = M5S6_M5 INTERACT M5OnM4Wide5
M5S6Pre = EXT M5S6ToCheck < 0.3 ABUT < 90 REGION
RR:RE:M5S6 { @ Recommended space of [M5 AND (wide M4 sizing 5um)] >= 0.3um
    M5S6Pre AND M4Wide5Exp5
}
#ENDIF // _M5S6_

#IFDEF _M5S7_
M5S7_M5CellIn = INSIDE CELL METAL5i CellsForRRuleRecommended  
M5S7_M5CellOut = NOT INSIDE CELL METAL5i ExclCellsForRRuleRecommended 
M5S7_M5Cell = M5S7_M5CellIn AND M5S7_M5CellOut
M5S7_M5Marker = METAL5i AND RRuleRecommended
M5S7_M5 = (M5S7_M5Cell OR M5S7_M5Marker) NOT Block

M5S7_DM5CellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
M5S7_DM5CellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
M5S7_DM5Cell = M5S7_DM5CellIn AND M5S7_DM5CellOut
M5S7_DM5Marker = DUM5 AND RRuleRecommended
M5S7_DM5 = (M5S7_DM5Cell OR M5S7_DM5Marker) NOT Block

M5S7_M5x = M5S7_M5 OR M5S7_DM5
M5S7_NOT_M5x = CHIP NOT M5x
M5S7_BIGAREA = AREA M5S7_NOT_M5x > BIG_AREA
M5S7_ERROR = (EXT M5S7_BIGAREA M5S7_NOT_M5x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M5S7_M5x 

RR:RE:M5S7 { @ Space between two non-M5 regions 0.35 [ one area > ^BIG_AREA ]
    COPY M5S7_ERROR
}
#ENDIF // _M5S7_

#IFDEF _M5EN1_M5EN2_
M5EN1_M5EN2_VIA4CellIn = INSIDE CELL VIA45i CellsForRRuleRecommended  
M5EN1_M5EN2_VIA4CellOut = NOT INSIDE CELL VIA45i ExclCellsForRRuleRecommended 
M5EN1_M5EN2_VIA4Cell = M5EN1_M5EN2_VIA4CellIn AND M5EN1_M5EN2_VIA4CellOut
M5EN1_M5EN2_VIA4Marker = VIA45i AND RRuleRecommended
M5EN1_M5EN2_VIA4 = (M5EN1_M5EN2_VIA4Cell OR M5EN1_M5EN2_VIA4Marker) NOT Block

RR:RE:M5EN1_M5EN2 { @ Recommended enclosure of VIA4 at least two opposite sides >= 0.08 um or enclosure of VIA4 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M5EN1_M5EN2_VIA4 M5 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M5 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFNDEF THICK_TOP3_METAL

#IFDEF _M6S5_ 
M6BigStack = ( SIZE M6WideStack BY 5 / 2 UNDEROVER TRUNCATE 5 /2 ) AND M6WideStack
M6StackSpace = EXT M6BigStack M6WideStack < 0.6 OPPOSITE MEASURE ALL REGION
M6StackViol = ( ( M6StackSpace NOT INSIDE M5 ) NOT INSIDE M6 ) NOT INSIDE M7
RR:RE:M6S5 { @ Recommended space of 2 adjacent stacked metals( metal layers >= 3 ) width > 5um and
             @ run length > 5um >= 0.6um
    ENCLOSE RECTANGLE M6StackViol 0.005 5+0.005 
}
#ENDIF // _M6S5_

#IFDEF _M6S6_
M6S6_M6CellIn = INSIDE CELL METAL6i CellsForRRuleRecommended  
M6S6_M6CellOut = NOT INSIDE CELL METAL6i ExclCellsForRRuleRecommended 
M6S6_M6Cell = M6S6_M6CellIn AND M6S6_M6CellOut
M6S6_M6Marker = METAL6i AND RRuleRecommended
M6S6_M6 = (M6S6_M6Cell OR M6S6_M6Marker) NOT Block

M5Wide5Exp5 = SIZE ( ( SIZE ( SIZE METAL5i BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND METAL5i ) BY 5
M6OnM5Wide5 = M6S6_M6 AND M5Wide5Exp5
M6S6ToCheck = M6S6_M6 INTERACT M6OnM5Wide5
M6S6Pre = EXT M6S6ToCheck < 0.3 ABUT < 90 REGION
RR:RE:M6S6 { @ Recommended space of [M6 AND (wide M5 sizing 5um)] >= 0.3um
    M6S6Pre AND M5Wide5Exp5
}
#ENDIF // _M6S6_

#IFDEF _M6S7_
M6S7_M6CellIn = INSIDE CELL METAL6i CellsForRRuleRecommended  
M6S7_M6CellOut = NOT INSIDE CELL METAL6i ExclCellsForRRuleRecommended 
M6S7_M6Cell = M6S7_M6CellIn AND M6S7_M6CellOut
M6S7_M6Marker = METAL6i AND RRuleRecommended
M6S7_M6 = (M6S7_M6Cell OR M6S7_M6Marker) NOT Block

M6S7_DM6CellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
M6S7_DM6CellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
M6S7_DM6Cell = M6S7_DM6CellIn AND M6S7_DM6CellOut
M6S7_DM6Marker = DUM6 AND RRuleRecommended
M6S7_DM6 = (M6S7_DM6Cell OR M6S7_DM6Marker) NOT Block

M6S7_M6x = M6S7_M6 OR M6S7_DM6
M6S7_NOT_M6x = CHIP NOT M6x
M6S7_BIGAREA = AREA M6S7_NOT_M6x > BIG_AREA
M6S7_ERROR = (EXT M6S7_BIGAREA M6S7_NOT_M6x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M6S7_M6x 

RR:RE:M6S7 { @ Space between two non-M6 regions 0.35 [ one area > ^BIG_AREA ]
    COPY M6S7_ERROR
}
#ENDIF // _M6S7_

#IFDEF _M6EN1_M6EN2_
M6EN1_M6EN2_VIA5CellIn = INSIDE CELL VIA56i CellsForRRuleRecommended  
M6EN1_M6EN2_VIA5CellOut = NOT INSIDE CELL VIA56i ExclCellsForRRuleRecommended 
M6EN1_M6EN2_VIA5Cell = M6EN1_M6EN2_VIA5CellIn AND M6EN1_M6EN2_VIA5CellOut
M6EN1_M6EN2_VIA5Marker = VIA56i AND RRuleRecommended
M6EN1_M6EN2_VIA5 = (M6EN1_M6EN2_VIA5Cell OR M6EN1_M6EN2_VIA5Marker) NOT Block

RR:RE:M6EN1_M6EN2 { @ Recommended enclosure of VIA5 at least two opposite sides >= 0.08 um or enclosure of VIA5 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M6EN1_M6EN2_VIA5 M6 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M6 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF

#ENDIF // THICK_TOP3_METAL

#IFNDEF THICK_TOP2_METAL
#IFNDEF THICK_TOP3_METAL

#IFDEF _M7S5_ 
M7BigStack = ( SIZE M7WideStack BY 5 / 2 UNDEROVER TRUNCATE 5 /2 ) AND M7WideStack
M7StackSpace = EXT M7BigStack M7WideStack < 0.6 OPPOSITE MEASURE ALL REGION
M7StackViol = ( ( M7StackSpace NOT INSIDE M6 ) NOT INSIDE M7 ) NOT INSIDE M8
RR:RE:M7S5 { @ Recommended space of 2 adjacent stacked metals( metal layers >= 3 ) width > 5um and
             @ run length > 5um >= 0.6um
    ENCLOSE RECTANGLE M7StackViol 0.005 5+0.005 
}
#ENDIF // _M7S5_

#IFDEF _M7S6_
M7S6_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
M7S6_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
M7S6_M7Cell = M7S6_M7CellIn AND M7S6_M7CellOut
M7S6_M7Marker = METAL7i AND RRuleRecommended
M7S6_M7 = (M7S6_M7Cell OR M7S6_M7Marker) NOT Block

M6Wide5Exp5 = SIZE ( ( SIZE ( SIZE METAL6i BY 1/2 UNDEROVER TRUNCATE 1/2 ) BY 5/2 UNDEROVER TRUNCATE 5/2 ) AND METAL6i ) BY 5
M7OnM6Wide5 = M7S6_M7 AND M6Wide5Exp5
M7S6ToCheck = M7S6_M7 INTERACT M7OnM6Wide5
M7S6Pre = EXT M7S6ToCheck < 0.3 ABUT < 90 REGION
RR:RE:M7S6 { @ Recommended space of [M7 AND (wide M6 sizing 5um)] >= 0.3um
    M7S6Pre AND M6Wide5Exp5
}
#ENDIF // _M7S6_

#IFDEF _M7S7_
M7S7_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
M7S7_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
M7S7_M7Cell = M7S7_M7CellIn AND M7S7_M7CellOut
M7S7_M7Marker = METAL7i AND RRuleRecommended
M7S7_M7 = (M7S7_M7Cell OR M7S7_M7Marker) NOT Block

M7S7_DM7CellIn = INSIDE CELL DUM7 CellsForRRuleRecommended  
M7S7_DM7CellOut = NOT INSIDE CELL DUM7 ExclCellsForRRuleRecommended 
M7S7_DM7Cell = M7S7_DM7CellIn AND M7S7_DM7CellOut
M7S7_DM7Marker = DUM7 AND RRuleRecommended
M7S7_DM7 = (M7S7_DM7Cell OR M7S7_DM7Marker) NOT Block

M7S7_M7x = M7S7_M7 OR M7S7_DM7
M7S7_NOT_M7x = CHIP NOT M7x
M7S7_BIGAREA = AREA M7S7_NOT_M7x > BIG_AREA
M7S7_ERROR = (EXT M7S7_BIGAREA M7S7_NOT_M7x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M7S7_M7x 

RR:RE:M7S7 { @ Space between two non-M7 regions 0.35 [ one area > ^BIG_AREA ]
    COPY M7S7_ERROR
}
#ENDIF // _M7S7_

#IFDEF _M7EN1_M7EN2_
M7EN1_M7EN2_VIA6CellIn = INSIDE CELL VIA67i CellsForRRuleRecommended  
M7EN1_M7EN2_VIA6CellOut = NOT INSIDE CELL VIA67i ExclCellsForRRuleRecommended 
M7EN1_M7EN2_VIA6Cell = M7EN1_M7EN2_VIA6CellIn AND M7EN1_M7EN2_VIA6CellOut
M7EN1_M7EN2_VIA6Marker = VIA67i AND RRuleRecommended
M7EN1_M7EN2_VIA6 = (M7EN1_M7EN2_VIA6Cell OR M7EN1_M7EN2_VIA6Marker) NOT Block

RR:RE:M7EN1_M7EN2 { @ Recommended enclosure of VIA6 at least two opposite sides >= 0.08 um or enclosure of VIA6 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M7EN1_M7EN2_VIA6 M7 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M7 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF

#ENDIF // THICK_TOP2_METAL
#ENDIF // THICK_TOP3_METAL


M1DN3_M1CellIn = INSIDE CELL METAL1i CellsForRRuleRecommended  
M1DN3_M1CellOut = NOT INSIDE CELL METAL1i ExclCellsForRRuleRecommended 
M1DN3_M1Cell = M1DN3_M1CellIn AND M1DN3_M1CellOut
M1DN3_M1Marker = METAL1i AND RRuleRecommended
M1DN3_M1 = (M1DN3_M1Cell OR M1DN3_M1Marker) NOT Block

ERR_M1_D0 = DENSITY M1DN3_M1 CHIP < 0.15 WINDOW 100 STEP 50 BACKUP 
	            [ AREA(M1DN3_M1)/AREA(CHIP) ]
M2DN3_M2CellIn = INSIDE CELL METAL2i CellsForRRuleRecommended  
M2DN3_M2CellOut = NOT INSIDE CELL METAL2i ExclCellsForRRuleRecommended 
M2DN3_M2Cell = M2DN3_M2CellIn AND M2DN3_M2CellOut
M2DN3_M2Marker = METAL2i AND RRuleRecommended
M2DN3_M2 = (M2DN3_M2Cell OR M2DN3_M2Marker) NOT Block

ERR_M2_D0 = DENSITY M2DN3_M2 CHIP < 0.15 WINDOW 100 STEP 50 BACKUP 
	            [ AREA(M2DN3_M2)/AREA(CHIP) ]
M3DN3_M3CellIn = INSIDE CELL METAL3i CellsForRRuleRecommended  
M3DN3_M3CellOut = NOT INSIDE CELL METAL3i ExclCellsForRRuleRecommended 
M3DN3_M3Cell = M3DN3_M3CellIn AND M3DN3_M3CellOut
M3DN3_M3Marker = METAL3i AND RRuleRecommended
M3DN3_M3 = (M3DN3_M3Cell OR M3DN3_M3Marker) NOT Block

ERR_M3_D0 = DENSITY M3DN3_M3 CHIP < 0.15 WINDOW 100 STEP 50 BACKUP 
	            [ AREA(M3DN3_M3)/AREA(CHIP) ]
M4DN3_M4CellIn = INSIDE CELL METAL4i CellsForRRuleRecommended  
M4DN3_M4CellOut = NOT INSIDE CELL METAL4i ExclCellsForRRuleRecommended 
M4DN3_M4Cell = M4DN3_M4CellIn AND M4DN3_M4CellOut
M4DN3_M4Marker = METAL4i AND RRuleRecommended
M4DN3_M4 = (M4DN3_M4Cell OR M4DN3_M4Marker) NOT Block

ERR_M4_D0 = DENSITY M4DN3_M4 CHIP < 0.15 WINDOW 100 STEP 50 BACKUP 
	            [ AREA(M4DN3_M4)/AREA(CHIP) ]
M5DN3_M5CellIn = INSIDE CELL METAL5i CellsForRRuleRecommended  
M5DN3_M5CellOut = NOT INSIDE CELL METAL5i ExclCellsForRRuleRecommended 
M5DN3_M5Cell = M5DN3_M5CellIn AND M5DN3_M5CellOut
M5DN3_M5Marker = METAL5i AND RRuleRecommended
M5DN3_M5 = (M5DN3_M5Cell OR M5DN3_M5Marker) NOT Block

ERR_M5_D0 = DENSITY M5DN3_M5 CHIP < 0.15 WINDOW 100 STEP 50 BACKUP 
	            [ AREA(M5DN3_M5)/AREA(CHIP) ]
M6DN3_M6CellIn = INSIDE CELL METAL6i CellsForRRuleRecommended  
M6DN3_M6CellOut = NOT INSIDE CELL METAL6i ExclCellsForRRuleRecommended 
M6DN3_M6Cell = M6DN3_M6CellIn AND M6DN3_M6CellOut
M6DN3_M6Marker = METAL6i AND RRuleRecommended
M6DN3_M6 = (M6DN3_M6Cell OR M6DN3_M6Marker) NOT Block

ERR_M6_D0 = DENSITY M6DN3_M6 CHIP < 0.15 WINDOW 100 STEP 50 BACKUP 
	            [ AREA(M6DN3_M6)/AREA(CHIP) ]
M7DN3_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
M7DN3_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
M7DN3_M7Cell = M7DN3_M7CellIn AND M7DN3_M7CellOut
M7DN3_M7Marker = METAL7i AND RRuleRecommended
M7DN3_M7 = (M7DN3_M7Cell OR M7DN3_M7Marker) NOT Block

ERR_M7_D0 = DENSITY M7DN3_M7 CHIP < 0.15 WINDOW 100 STEP 50 BACKUP 
	            [ AREA(M7DN3_M7)/AREA(CHIP) ]

//3 consecutive		    
		    
#IFDEF _M1DN3_
RR:RE:M1DN3 { @ 3 consecutive metal layer(M1,M2,M3) over any 100umx100um window step 50um must >= 15%
    
    X = (ERR_M1_D0 AND ERR_M2_D0) AND ERR_M3_D0 
    AREA ( X NOT METAL_DEN_EXC ) >= 2500	
}
#ENDIF // _M1DN3_

		    
#IFDEF _M2DN3_
RR:RE:M2DN3 { @ 3 consecutive metal layer(M2,M3,M4) over any 100umx100um window step 50um must >= 15%
    
    X = (ERR_M2_D0 AND ERR_M3_D0) AND ERR_M4_D0 
    AREA ( X NOT METAL_DEN_EXC ) >= 2500	
}
#ENDIF // _M2DN3_

		    
#IFDEF _M3DN3_
RR:RE:M3DN3 { @ 3 consecutive metal layer(M3,M4,M5) over any 100umx100um window step 50um must >= 15%
    
    X = (ERR_M3_D0 AND ERR_M4_D0) AND ERR_M5_D0 
    AREA ( X NOT METAL_DEN_EXC ) >= 2500	
}
#ENDIF // _M3DN3_

#IFNDEF THICK_TOP3_METAL
		    
#IFDEF _M4DN3_
RR:RE:M4DN3 { @ 3 consecutive metal layer(M4,M5,M6) over any 100umx100um window step 50um must >= 15%
    
    X = (ERR_M4_D0 AND ERR_M5_D0) AND ERR_M6_D0 
    AREA ( X NOT METAL_DEN_EXC ) >= 2500	
}
#ENDIF // _M4DN3_
#ENDIF // THICK_TOP3_METAL

#IFNDEF THICK_TOP2_METAL
#IFNDEF THICK_TOP3_METAL
		    
#IFDEF _M5DN3_
RR:RE:M5DN3 { @ 3 consecutive metal layer(M5,M6,M7) over any 100umx100um window step 50um must >= 15%
    
    X = (ERR_M5_D0 AND ERR_M6_D0) AND ERR_M7_D0 
    AREA ( X NOT METAL_DEN_EXC ) >= 2500	
}
#ENDIF // _M5DN3_
#ENDIF // THICK_TOP2_METAL
#ENDIF // THICK_TOP3_METAL


#IFDEF THICK_TOP3_METAL
#IFDEF _M6W2_
M6W2_M6CellIn = INSIDE CELL METAL6i CellsForRRuleRecommended  
M6W2_M6CellOut = NOT INSIDE CELL METAL6i ExclCellsForRRuleRecommended 
M6W2_M6Cell = M6W2_M6CellIn AND M6W2_M6CellOut
M6W2_M6Marker = METAL6i AND RRuleRecommended
M6W2_M6 = (M6W2_M6Cell OR M6W2_M6Marker) NOT Block

RR:AR:M6W2 = M5 OR DUM5
M6W2_EXT = CHIP NOT ( SIZE RR:AR:M6W2 BY (5/2 - 0.001) OVERUNDER )
M6W2_BIG = SIZE( SIZE M6W2_EXT BY (5/2 - 0.001) UNDEROVER ) BY 1.0
M6W2_CHECK = M6W2_M6 INSIDE EDGE M6W2_BIG
RR:RE:M6W2 { @ Recommended M6 width on (M5 OR DM5 with space>= 5x5 sizing 1) >= 0.42
    INT M6W2_CHECK < 0.42 ABUT < 90 REGION 
}
#ENDIF // _M6W2_
#ENDIF // THICK_TOP3_METAL

#IFDEF THICK_TOP2_METAL
#IFDEF _M7W2_
M7W2_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
M7W2_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
M7W2_M7Cell = M7W2_M7CellIn AND M7W2_M7CellOut
M7W2_M7Marker = METAL7i AND RRuleRecommended
M7W2_M7 = (M7W2_M7Cell OR M7W2_M7Marker) NOT Block

RR:AR:M7W2 = M6 OR DUM6
M7W2_EXT = CHIP NOT ( SIZE RR:AR:M7W2 BY (5/2 - 0.001) OVERUNDER )
M7W2_BIG = SIZE( SIZE M7W2_EXT BY (5/2 - 0.001) UNDEROVER ) BY 1.0
M7W2_CHECK = M7W2_M7 INSIDE EDGE M7W2_BIG
RR:RE:M7W2 { @ Recommended M7 width on (M6 OR DM6 with space>= 5x5 sizing 1) >= 0.42
    INT M7W2_CHECK < 0.42 ABUT < 90 REGION 
}
#ENDIF // _M7W2_
#ENDIF  // THICK_TOP2_METAL
#IFDEF THICK_TOP3_METAL
#IFDEF _M7W2_
M7W2_M7CellIn = INSIDE CELL METAL7i CellsForRRuleRecommended  
M7W2_M7CellOut = NOT INSIDE CELL METAL7i ExclCellsForRRuleRecommended 
M7W2_M7Cell = M7W2_M7CellIn AND M7W2_M7CellOut
M7W2_M7Marker = METAL7i AND RRuleRecommended
M7W2_M7 = (M7W2_M7Cell OR M7W2_M7Marker) NOT Block

RR:AR:M7W2 = M6 OR DUM6
M7W2_EXT = CHIP NOT ( SIZE RR:AR:M7W2 BY (5/2 - 0.001) OVERUNDER )
M7W2_BIG = SIZE( SIZE M7W2_EXT BY (5/2 - 0.001) UNDEROVER ) BY 1.0
M7W2_CHECK = M7W2_M7 INSIDE EDGE M7W2_BIG
RR:RE:M7W2 { @ Recommended M7 width on (M6 OR DM6 with space>= 5x5 sizing 1) >= 0.42
    INT M7W2_CHECK < 0.42 ABUT < 90 REGION 
}
#ENDIF // _M7W2_
#ENDIF // THICK_TOP3_METAL


#IFDEF _M8W2_
M8W2_M8CellIn = INSIDE CELL METAL8i CellsForRRuleRecommended  
M8W2_M8CellOut = NOT INSIDE CELL METAL8i ExclCellsForRRuleRecommended 
M8W2_M8Cell = M8W2_M8CellIn AND M8W2_M8CellOut
M8W2_M8Marker = METAL8i AND RRuleRecommended
M8W2_M8 = (M8W2_M8Cell OR M8W2_M8Marker) NOT Block

RR:AR:M8W2 = M7 OR DUM7
M8W2_EXT = CHIP NOT ( SIZE RR:AR:M8W2 BY (5/2 - 0.001) OVERUNDER )
M8W2_BIG = SIZE( SIZE M8W2_EXT BY (5/2 - 0.001) UNDEROVER ) BY 1.0
M8W2_CHECK = M8W2_M8 INSIDE EDGE M8W2_BIG
RR:RE:M8W2 { @ Recommended M8 width on (M7 OR DM7 with space>= 5x5 sizing 1) >= 0.42
    INT M8W2_CHECK < 0.42 ABUT < 90 REGION 
}
#ENDIF // _M8W2_

#ENDIF // Recommended

#IFDEF Analog

#IFDEF _POEX1m_
POEX1m_POCellIn = INSIDE CELL POLYGi CellsForRRuleAnalog  
POEX1m_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleAnalog 
POEX1m_POCell = POEX1m_POCellIn AND POEX1m_POCellOut
POEX1m_POMarker = POLYGi AND RRuleAnalog
POEX1m_PO = (( POEX1m_POCell OR POEX1m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:AN:POEX1m { @ Recommended PO extension on OD >= 0.20
    ENC OD POEX1m_PO < 0.20 ABUT < 90 REGION OPPOSITE
}
#ENDIF // _POEX1m_

#IFDEF _POS4m_
POS4m_POCellIn = INSIDE CELL POLYGi CellsForRRuleAnalog  
POS4m_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleAnalog 
POS4m_POCell = POS4m_POCellIn AND POS4m_POCellOut
POS4m_POMarker = POLYGi AND RRuleAnalog
POS4m_PO = (( POS4m_POCell OR POS4m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

POS4m_GATE = POS4m_PO AND ODi
LongGateL = GATE_L COIN INSIDE EDGE POS4m_GATE 
LongGateLExp = EXPAND EDGE LongGateL INSIDE BY Grid EXTEND BY PO_S_1
LongGateLExe = ODi COIN INSIDE EDGE LongGateLExp
RR:AN:POS4m:LPO { @ L-PO space to OD >= 0.12um
    EXT LongGateLExe POS4m_PO < 0.12 ABUT < 90 OPPOSITE REGION
}

LongGateW = GATE_W COIN INSIDE EDGE POS4m_GATE 
LongGateWExp = EXPAND EDGE LongGateW INSIDE BY Grid EXTEND BY OD_S_1
LongGateWExe = POS4m_PO COIN INSIDE EDGE LongGateWExp
RR:AN:POS4m:LOD { @ L-OD space to PO >= 0.12um
    EXT LongGateWExe ODi < 0.12 ABUT < 90 OPPOSITE REGION
}

#ENDIF // _POS4m_

#IFDEF _POEX2m_
POEX2m_POCellIn = INSIDE CELL POLYGi CellsForRRuleAnalog  
POEX2m_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleAnalog 
POEX2m_POCell = POEX2m_POCellIn AND POEX2m_POCellOut
POEX2m_POMarker = POLYGi AND RRuleAnalog
POEX2m_PO = (( POEX2m_POCell OR POEX2m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

RR:AN:POEX2m { @ OD over PO >= 0.34um
    (ENC POEX2m_PO ODi < 0.34 ABUT < 89.5 SINGULAR OPPOSITE REGION) NOT INSIDE LOGO
}
#ENDIF // _POEX2m_


BJTR_PP_EMOD = PACT AND BJTDMY
BJTR_NP_EMOD = NACT AND BJTDMY
BJTR_EMOD = BJTR_PP_EMOD OR BJTR_NP_EMOD
#IFDEF _BJTR2R_
BJT.R.2R { @ OD( Emitter size ) is ^BJT_R_2R_A x ^BJT_R_2R_A, ^BJT_R_2R_B x ^BJT_R_2R_B, ^BJT_R_2R_C x ^BJT_R_2R_C 
    X = NOT RECTANGLE BJTR_EMOD == BJT_R_2R_A BY == BJT_R_2R_A
    Y = NOT RECTANGLE X == BJT_R_2R_B BY == BJT_R_2R_B
    NOT RECTANGLE Y == BJT_R_2R_C BY == BJT_R_2R_C
}
#ENDIF // _BJTR2R_

#IFDEF _BJTR3R_
BJT.R.3R { @ NW enclosure of P+OD ( Emitter OD ) for PNP == ^BJT_R_3R
    X = SIZE BJTR_PP_EMOD BY BJT_R_3R
    Y = NWEL INTERACT BJTR_PP_EMOD
    X XOR Y
}
#ENDIF // _BJTR3R_

BJT_NW = NWEL AND BJTDMY
BJT_DNW = DNW AND BJTDMY
BJT_RW = BJT_DNW NOT BJT_NW 

#IFDEF _BJTR4R_
BJT.R.4R { @ NW space to N+OD ( Emitter OD ) for NPN == ^BJT_R_4R
    X = SIZE BJTR_NP_EMOD BY BJT_R_4R
    Y = BJT_RW INTERACT BJTR_NP_EMOD
    X NOT Y  // min. check 
    // max. check : DRC un-checkable.  
}
#ENDIF // _BJTR4R_

#IFDEF _BJTR5R_
BJT.R.5R { @ NW enclosure of DNW for NPN >= ^BJT_R_5R
    ENC BJT_DNW BJT_NW < BJT_R_5R ABUT < 90 SINGULAR REGION
}
#ENDIF // _BJTR5R_

#IFDEF _BJTR6R_
BJT.R.6R { @ DNW enclosure of PW for NPN ( three side ) = ^BJT_R_6R
   X = SIZE BJT_RW BY BJT_R_6R
   X NOT BJT_DNW    
   Y = X XOR BJT_DNW
   Y NOT INTERACT ( NSTP AND BJTDMY )
}
#ENDIF // _BJTR6R_

#IFDEF _BJTR7R_
BJT.R.7R { @ BJTDMY overlap of NT_N, PO, VTH_N, VTH_P, VTL_N, VTL_P, RH, VAR and SRM is not recommended
    BJTDMY AND NTN
    BJTDMY AND POLY
    BJTDMY AND VTHN
    BJTDMY AND VTHP
    BJTDMY AND VTLN
    BJTDMY AND VTLP
    BJTDMY AND RHDMY
    BJTDMY AND VARDMY
    BJTDMY AND DMSRMi
}
#ENDIF // _BJTR7R

#IFDEF _ANR17mg_
ANR17mg_POCellIn = INSIDE CELL POLYGi CellsForRRuleAnalog  
ANR17mg_POCellOut = NOT INSIDE CELL POLYGi ExclCellsForRRuleAnalog 
ANR17mg_POCell = ANR17mg_POCellIn AND ANR17mg_POCellOut
ANR17mg_POMarker = POLYGi AND RRuleAnalog
ANR17mg_PO = (( ANR17mg_POCell OR ANR17mg_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block

ANR17mg_PORES = ANR17mg_PO AND PORES
RR:AN:ANR17mg { @ PO resistor on NW for better noise immunity; P+ PO resistor is recommended
    ANR17mg_PORES NOT NWEL
    ANR17mg_PORES NOT INTERACT PP
}
#ENDIF // _ANR17mg_

#IFDEF _ANR19mg_
ANR19mg_VARCellIn = INSIDE CELL VARDMY CellsForRRuleAnalog  
ANR19mg_VARCellOut = NOT INSIDE CELL VARDMY ExclCellsForRRuleAnalog 
ANR19mg_VARCell = ANR19mg_VARCellIn AND ANR19mg_VARCellOut
ANR19mg_VARMarker = VARDMY AND RRuleAnalog
ANR19mg_VAR = (ANR19mg_VARCell OR ANR19mg_VARMarker) NOT Block

ANR19mg_VAROD = ANR19mg_VAR AND OD
RR:AN:ANR19mg { @ Use OD2 MOS varactor is recommended.
   ANR19mg_VAROD NOT OD2
}
#ENDIF // _ANR19mg_

#ENDIF // Analog
#ENDIF  //DFM

